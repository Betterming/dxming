<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dxming</title>
  <icon>https://www.gravatar.com/avatar/8b270e34727df778402d99257198190e</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://looby.coding.me/betterming/"/>
  <updated>2019-10-20T05:46:43.717Z</updated>
  <id>http://looby.coding.me/betterming/</id>
  
  <author>
    <name>dxming</name>
    <email>2652214420@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>五种单例模式</title>
    <link href="http://looby.coding.me/betterming/post/2b3b0ec1.html"/>
    <id>http://looby.coding.me/betterming/post/2b3b0ec1.html</id>
    <published>2019-10-20T05:37:53.793Z</published>
    <updated>2019-10-20T05:46:43.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-单例模式简介"><a href="#1-单例模式简介" class="headerlink" title="1. 单例模式简介"></a>1. 单例模式简介</h2><p>Java中单例(Singleton)模式是一种广泛使用的设计模式。单例模式的主要作用一些管理器和控制器常被设计成单例模式。</p><a id="more"></a><ul><li>单例模式有很多好处，它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；</li><li>能够避免由于操作多个实例导致的逻辑错误。</li><li>如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。<blockquote><p>例如:</p><ul><li>一个班级只有一个班主任。</li><li>要求生产唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li></ul></blockquote></li></ul><h2 id="2-五种常见的单例模式"><a href="#2-五种常见的单例模式" class="headerlink" title="2.五种常见的单例模式"></a>2.五种常见的单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 懒汉式：需要用时才实例化对象，线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. 加同步所的懒汉模式：线程安全，效率低，其余线程要等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazySyn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazySyn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazySyn instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazySyn <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazySyn();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 双重检查锁定懒汉模式：这种比第二种效率高一些，减少了加锁的范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazyDoubleCheckSyn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazyDoubleCheckSyn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazyDoubleCheckSyn instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazyDoubleCheckSyn <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonLazyDoubleCheckSyn.class) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonLazyDoubleCheckSyn();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4. 饿汉模式：在程序启动时，类加载就初始化了，线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonHungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonHungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonHungry instance = <span class="keyword">new</span> SingletonHungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonHungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5. 静态内部类懒汉模式: 借助内部类的静态语句块实现，线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonStatic instance;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonStatic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonStatic <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NestClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-单例模式简介&quot;&gt;&lt;a href=&quot;#1-单例模式简介&quot; class=&quot;headerlink&quot; title=&quot;1. 单例模式简介&quot;&gt;&lt;/a&gt;1. 单例模式简介&lt;/h2&gt;&lt;p&gt;Java中单例(Singleton)模式是一种广泛使用的设计模式。单例模式的主要作用一些管理器和控制器常被设计成单例模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://looby.coding.me/betterming/categories/Design-Pattern/"/>
    
    
      <category term="Singleton" scheme="http://looby.coding.me/betterming/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Chap6_HashMapAndString</title>
    <link href="http://looby.coding.me/betterming/post/284d6ace.html"/>
    <id>http://looby.coding.me/betterming/post/284d6ace.html</id>
    <published>2019-08-18T15:16:34.332Z</published>
    <updated>2019-08-18T16:01:05.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六节：哈希表和字符串"><a href="#第六节：哈希表和字符串" class="headerlink" title="第六节：哈希表和字符串"></a>第六节：哈希表和字符串</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p>&emsp;&emsp;哈希表(Hashtable，也叫散列表)，是根据关键字值(key)直接进行访问的数据结构，它通过把关键字值映射到表中一个位置(数组下标)来直接访问，以加快查找关键字值的速度。这个映射函数叫做哈希(散列)函数，存放记录的数组叫做哈希(散列)表。给定表M，存在函数f(key)，对任意的关键字值key，代入函数后若能得到包含该关键字的表中地址，称表M为哈希(Hash)表，函数f(key)为哈希(Hash)函数。</p><ul><li>1.当遇到负数或非常大的整数，如何进行哈希(映射)？如：-5、99999999、…</li><li>2.当遇到字符串，如何进行哈希(映射)？如：abcdefg、XYZ、…</li><li>3.当遇其他到无法直接映射的数据类型，如浮点数、数组、浮点数对象等等，如何进行哈希(映射)？如：1.2345、[1,2,3]、…<br><strong>解决</strong>:利用哈希函数，将关键字值(key)(大整数、字符串、浮点数等)转换为整数再对表长取余，从而关键字值被转换为哈希表的表长范围内的整数。采用<strong>除留取余法</strong></li></ul><p><strong>发生冲突</strong></p><ul><li>开放定址法 线性探测再散列，二次探测再散列</li><li>在哈希法</li><li>链地址法</li><li>建立公共溢出区</li></ul><p><strong>在这里重点也是主要用链地址法</strong><br><a id="more"></a></p><h2 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2. 预备知识"></a>2. 预备知识</h2><blockquote><ol><li>关键点: key -&gt; hash_key -&gt; 挂链头指针 -&gt; found_value<pre><code>格式转换    哈希函数        挂链</code></pre></li><li>STL: map: 不但能判断在不在map中，还有知道映射位置可以将string映射到int,用find查找有无元素，用迭代器遍历元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hash_map;</span><br><span class="line">hash_map[str1] = <span class="number">123</span>;</span><br><span class="line">hash_map.find(str1) != hash_map.end()   <span class="comment">//表示str在hash_map中</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it-&gt;first.c_str <span class="comment">// first表示key值，c_str表示char转换成string</span></span><br><span class="line">it-&gt;second<span class="comment">//表示value值</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>地址法创建哈希表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) :val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 由key到hash_key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_func</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> table_len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> key % table_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法来创建挂链</span></span><br><span class="line"><span class="comment">// node为插入的节点，经过hash_func变成int hash_key,经过hash_table再到原节点下一个节点：node-&gt;next，</span></span><br><span class="line"><span class="comment">// 最后哈希表中装的指针为node即hash_table[hash_key] = node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ListNode *hash_table[], ListNode *node, <span class="keyword">int</span> table_len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash_key = hash_func(node-&gt;val, table_len);</span><br><span class="line">node-&gt;next = hash_table[hash_key];  </span><br><span class="line">hash_table[hash_key] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(ListNode *hash_table[], <span class="keyword">int</span> value, <span class="keyword">int</span> table_len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash_key = hash_func(value, table_len);</span><br><span class="line">ListNode *head = hash_table[hash_key];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;val == value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> table_len = <span class="number">11</span>;  <span class="comment">// 表长一般为质数，使数据分散，产生冲突少一些</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> test_len = <span class="number">8</span>;</span><br><span class="line">ListNode *hash_table[table_len] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ListNode *&gt; hash_node_vec;</span><br><span class="line"><span class="keyword">int</span> test[test_len] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">150</span>, <span class="number">500</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_len; i++)</span><br><span class="line">&#123;</span><br><span class="line">hash_node_vec.push_back(<span class="keyword">new</span> ListNode(test[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash_node_vec.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">insert(hash_table, hash_node_vec[i], table_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hash table:\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table_len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:"</span>, i);</span><br><span class="line">ListNode *head = hash_table[i];</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-&gt;%d"</span>, head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Test search:\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (search(hash_table, i, table_len)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d is in the hash table.\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d is not in the hash table.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h2><h3 id="3-1-LeetCode409-Longest-Palindrome"><a href="#3-1-LeetCode409-Longest-Palindrome" class="headerlink" title="3.1 LeetCode409.Longest Palindrome"></a>3.1 LeetCode409.Longest Palindrome</h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。<br>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。<br>注意:<br>假设字符串的长度不会超过 1010。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"><span class="section">输入:</span></span><br><span class="line"><span class="string">"abccccdd"</span></span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">7</span><br><span class="line"><span class="section">解释:</span></span><br><span class="line">我们可以构造的最长的回文串是<span class="string">"dccaccd"</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：对于给定字符串，</p><ol><li>字符数量为偶数时，全部使用</li><li>奇数时，丢掉一个，其余全部使用</li><li>若有剩余字符，随便用一个放中间</li></ol><p>统计包含给定字符串中最长子串</p><ol><li>利用hash_map统计字符数量</li><li>设置最长回文串偶数字符偶数字符长度为max_length=0；</li><li>设置是否是否有中心点 标记flag=0;</li><li>遍历每一个字符，字符数字符数为count，若count为偶数，<br> max_length+=count；若count为奇数，max_length+=count–1，flag=1；</li><li>最终最长回文子串长度:max_length+flag。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> char_map[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">char_map[s[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (char_map[i] % <span class="number">2</span> == <span class="number">0</span>) max_len += char_map[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">max_len += char_map[i] - <span class="number">1</span>;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  max_len + flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"abccccddaa"</span>;</span><br><span class="line"><span class="keyword">int</span> result = solve.longestPalindrome(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-LeetCode290-Word-Pattern"><a href="#3-2-LeetCode290-Word-Pattern" class="headerlink" title="3.2 LeetCode290.Word Pattern"></a>3.2 LeetCode290.Word Pattern</h3><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。<br>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span>:</span><br><span class="line">输入: <span class="attr">pattern</span> = <span class="string">"abba"</span>, <span class="attr">str</span> = <span class="string">"dog cat cat dog"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入:<span class="attr">pattern</span> = <span class="string">"abba"</span>, <span class="attr">str</span> = <span class="string">"dog cat cat fish"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="attr">pattern</span> = <span class="string">"aaaa"</span>, <span class="attr">str</span> = <span class="string">"dog cat cat dog"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="attr">pattern</span> = <span class="string">"abba"</span>, <span class="attr">str</span> = <span class="string">"dog dog dog dog"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">说明:</span><br><span class="line">你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：考虑几种情况</p><ol><li>当拆解出一个单词，若单词出现，则当前单词对应的pattern字符必为该单词曾经对应的pattern字符</li><li>当拆解出一个单词，若单词没有出现时，则对应字符也应该未出现。</li><li>单词个数应该与pattern字符数匹配。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt; mp;  <span class="comment">// 单词到字符的映射</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;  <span class="comment">// 指向pattern当前字符</span></span><br><span class="line"><span class="built_in">string</span> word;  <span class="comment">// 保存str拆下来的临时单词</span></span><br><span class="line">str.push_back(<span class="string">' '</span>);  <span class="comment">// str尾部push一个空格， 使得最后一个单词也能和其他单词一样被拆分出来</span></span><br><span class="line"><span class="keyword">char</span> used[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 判断pattern字符是否出现，判断单词是否出现直接用mp.find(word) == mp.end();</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">' '</span>) &#123;</span><br><span class="line">word += str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pos == pattern.length()) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 分割出来的单词没有字符可对应时直接false</span></span><br><span class="line"><span class="keyword">if</span> (mp.find(word) == mp.end()) &#123;  <span class="comment">// 分割出来的单词如果没有出现，判断对此时对应的字符是否出现</span></span><br><span class="line"><span class="keyword">if</span> (used[pattern[pos]]) <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当对应的字符未出现时，要做映射，改变used</span></span><br><span class="line">mp[word] = pattern[pos];  </span><br><span class="line">used[pattern[pos]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[word] != pattern[pos]) &#123;  <span class="comment">// 分割出来的单词已经出现，但是对应的字符与pos当前对应的字符不匹配时直接返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">word = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos != pattern.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> pattern = <span class="string">"abba"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"dog cat cat dog"</span>;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.wordPattern(pattern, str));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-LeetCode49-Group-Anagrams"><a href="#3-3-LeetCode49-Group-Anagrams" class="headerlink" title="3.3 LeetCode49.Group Anagrams"></a>3.3 LeetCode49.Group Anagrams</h3><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">所有输入均为小写字母。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：哈希表以内部进行排序的单词为key, 以字符串向量vector<string> 为value<br>设置字符串到字符向量的哈希表anagram，遍历字符串向量strs中的单词strs[i];<br>1) 设置临时变量str = strs[i],对str进行排序<br>2) 若str未出现在anagram中，设置str到一个空字符串向量的映射。<br>3) 将strs[i] 添加至字符串向量anagram[str]中，<br>遍历哈希表anagram，将全部key对应的value push到最终结果种树</string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; anagram;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++) &#123;</span><br><span class="line"><span class="built_in">string</span> str = strs[i];</span><br><span class="line">sort(str.begin(), str.end());</span><br><span class="line"><span class="keyword">if</span> (anagram.find(str) == anagram.end()) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; item;</span><br><span class="line">anagram[str] = item;</span><br><span class="line">&#125;</span><br><span class="line">anagram[str].push_back(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = anagram.begin(); it != anagram.end(); it++) &#123;</span><br><span class="line">result.push_back((*it).second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; strs;</span><br><span class="line">strs.push_back(<span class="string">"eat"</span>);</span><br><span class="line">strs.push_back(<span class="string">"tea"</span>);</span><br><span class="line">strs.push_back(<span class="string">"tan"</span>);</span><br><span class="line">strs.push_back(<span class="string">"ate"</span>);</span><br><span class="line">strs.push_back(<span class="string">"nat"</span>);</span><br><span class="line">strs.push_back(<span class="string">"bat"</span>);</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &gt; result</span><br><span class="line">= solve.groupAnagrams(strs);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s]"</span>, result[i][j].c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-LeetCode3-Longest-Substring-Without-Repeating-Characters"><a href="#3-4-LeetCode3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.4 LeetCode3.Longest Substring Without Repeating Characters"></a>3.4 LeetCode3.Longest Substring Without Repeating Characters</h3><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"><span class="section">输入: "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: "bbbbb"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：使用双指针窗口的方式，记录中间的单词，返回最大的长度<br>有几个重要的数据结构：<br>begin, i(双指针窗口)， word: 记录begin，i之间未重复字符串<br>result: 记录变化的word中最大长度<br>char_map[128]：用于判重,记录begin,i之间的字符个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> char_map[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> word = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">char_map[s[i]]++;</span><br><span class="line"><span class="keyword">if</span> (char_map[s[i]] == <span class="number">1</span>) &#123; <span class="comment">// 若s[i]只在前面出现一次</span></span><br><span class="line">word += s[i];          <span class="comment">// word更新</span></span><br><span class="line"><span class="keyword">if</span> (result &lt; word.length()) &#123;  <span class="comment">// 更新 result</span></span><br><span class="line">result = word.length();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; i &amp;&amp; char_map[s[i]] &gt; <span class="number">1</span>) &#123;  <span class="comment">// 当s[i]在前面已经出现时，跟新char_map[]，begin至到char_map[]中该重复的字符减为1为止</span></span><br><span class="line">char_map[s[begin]]--;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新word</span></span><br><span class="line">word = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt;= i; j++) &#123;</span><br><span class="line">word += s[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> word = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> char_map[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">char_map[s[i]]++;</span><br><span class="line"><span class="keyword">if</span> (char_map[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">word += s[i];</span><br><span class="line"><span class="keyword">if</span> (result &lt; word.length()) &#123;</span><br><span class="line">result = word.length();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; i &amp;&amp; char_map[s[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">char_map[s[begin]]--;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line">word = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt;= i; j++) &#123;</span><br><span class="line">word += s[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"abcbadab"</span>;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="comment">// Solution1 solve;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.lengthOfLongestSubstring(s));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-LeetCode187-Repeated-DNA-Sequences"><a href="#3-5-LeetCode187-Repeated-DNA-Sequences" class="headerlink" title="3.5.LeetCode187.Repeated DNA Sequences"></a>3.5.LeetCode187.Repeated DNA Sequences</h3><p>所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。<br>编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: <span class="attr">s</span> = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span></span><br><span class="line">输出: [<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>]</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>：</p><ol><li>枚举DNA所有长度为10的子串，将其插入map&lt;string, int&gt; str_map中;遍历map,将出现次数超过1次的子串都放进result中</li><li>对ACGT四个字符编码<a href="二进制编码为00，01，10，11">0,1,2,3</a>,所以长度为10的子串可以用20bit的整数表示，比如：<br>11010101010000000000=873472 ，<ul><li>用g_hash_map[1048576];1048576=2^10，表示所有长度为10的DNA序列的出现次数</li><li>DNA前10个字符使用左移位运算转换成整数key，g_hash_map[key]++;</li><li>DNA从第11字符开始，遇到一个字符即将key右移2位，并且将新的DNA字符s[i]转换成整数，或到最高位，g_hash_map[key]++;</li><li>遍历哈希表g_hash_map,若g_hash_map[i]&gt;1， 将从低位到高位转换10个字符的DNA序列，push到result中</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRepeatedDnaSequences(<span class="built_in">string</span> s) &#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; str_map;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="built_in">string</span> word = s.substr(i, <span class="number">10</span>);  <span class="comment">// 求i字符串字串函数，i为word的结束位置，10为子串大小</span></span><br><span class="line"><span class="keyword">if</span> (str_map.find(word) != str_map.end()) &#123;</span><br><span class="line">str_map[word] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">str_map[word] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = str_map.begin(); it != str_map.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">result.push_back(it-&gt;first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_hash_map[<span class="number">1048576</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 太大用全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRepeatedDnaSequences(<span class="built_in">string</span> s) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (s.length() &lt; <span class="number">10</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g_hash_map初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1048576</span>; i++) &#123;</span><br><span class="line">g_hash_map[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> char_map[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">char_map[<span class="string">'A'</span>] = <span class="number">0</span>;</span><br><span class="line">char_map[<span class="string">'C'</span>] = <span class="number">1</span>;</span><br><span class="line">char_map[<span class="string">'G'</span>] = <span class="number">2</span>;</span><br><span class="line">char_map[<span class="string">'T'</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">key = (key &lt;&lt; <span class="number">2</span>) + char_map[s[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_hash_map[key] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">key = key &gt;&gt; <span class="number">2</span>;</span><br><span class="line">key = key | (char_map[s[i]] &lt;&lt; <span class="number">18</span>);</span><br><span class="line">g_hash_map[key]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1048576</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (g_hash_map[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">result.push_back(int2DNA(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2DNA</span><span class="params">(<span class="keyword">int</span> DNA)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> DNA_CHAR[] = &#123; <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'G'</span>, <span class="string">'T'</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">str += DNA_CHAR[DNA &amp; <span class="number">3</span>];</span><br><span class="line">DNA = DNA &gt;&gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span>;</span><br><span class="line"><span class="comment">//Solution solve;</span></span><br><span class="line">Solution1 solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; result = solve.findRepeatedDnaSequences(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result[i].c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-LeetCode76-Minimum-Window-Substring"><a href="#3-6-LeetCode76-Minimum-Window-Substring" class="headerlink" title="3.6 LeetCode76.Minimum Window Substring"></a>3.6 LeetCode76.Minimum Window Substring</h3><p>给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: <span class="attr">S</span> = <span class="string">"ADOBECODEBANC"</span>, <span class="attr">T</span> = <span class="string">"ABC"</span></span><br><span class="line">输出: <span class="string">"BANC"</span></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">如果 S 中不存这样的子串，则返回空字符串 <span class="string">""</span>。</span><br><span class="line">如果 S 中存在这样的子串，我们保证它是唯一的答案。</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong>:</p><ol><li>map_t,map_s两个数组，记录t字符数量，s当前窗口的字符数量</li><li>begin, i双指针窗口</li><li>i移动，每移动一个字符检查是否可以更新窗口的结果（找到最小的包含T中各个字符的窗口）</li><li>i指针向后逐个扫描逐个扫描逐个扫描逐个扫描字符串中的字符，在这个过程中，循环检查begin指针是否可以向前移动:<ul><li>如果当前begin指向的字符T中没出现，直接前移前移前移前移begin；</li><li>如果begin指向的字符T中出现了，但是当前区间窗口中的该字符数量足够，向前移动begin，并更新map_s；</li><li>否则不能移动begin，跳出检查</li></ul></li></ol><p>在整个过程中，使用begin与i维护一个窗口，该窗口中的子串满足题目条件(包含T中所有字符)，窗口线性向前滑动，整体时间复杂度为O(n)O</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isWindow</span><span class="params">(<span class="keyword">int</span> map_s[], <span class="keyword">int</span> <span class="keyword">map_t</span>[], <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="keyword">vec_t</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">vec_t</span>.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map_s[<span class="keyword">vec_t</span>[i]] &lt; <span class="keyword">map_t</span>[<span class="keyword">vec_t</span>[i]]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">map_t</span>[MAX_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> map_s[MAX_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">vec_t</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line"><span class="keyword">map_t</span>[t[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_LEN; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">map_t</span>[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">vec_t</span>.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">map_s[s[i]]++;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; i) &#123;</span><br><span class="line"><span class="keyword">char</span> begin_ch = s[begin];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">map_t</span>[begin_ch] == <span class="number">0</span>) &#123;  <span class="comment">// 如果begin_ch不在map_t中，begin移动</span></span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map_s[begin_ch] &gt; <span class="keyword">map_t</span>[begin_ch]) &#123;</span><br><span class="line">map_s[begin_ch]--;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// 当begin不能移动时，直接跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isWindow(map_s, <span class="keyword">map_t</span>, <span class="keyword">vec_t</span>)) &#123;  <span class="comment">// 能进入到这的窗口是，s中begin指向t中一个字符且begin所指字符满足map_s[begin_ch] &lt;= map_t[begin_ch], i从1开始且大于begin</span></span><br><span class="line"><span class="keyword">int</span> newWindowLen = i - begin + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="string">""</span> || result.length() &gt; newWindowLen) &#123;</span><br><span class="line">result = s.substr(begin, newWindowLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> result = solve.minWindow(<span class="string">"ADOBECODEBANC"</span>, <span class="string">"ABC"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result.c_str());</span><br><span class="line">result = solve.minWindow(<span class="string">"MADOBCCABEC"</span>, <span class="string">"ABCC"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result.c_str());</span><br><span class="line">result = solve.minWindow(<span class="string">"aa"</span>, <span class="string">"aa"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result.c_str());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第六节：哈希表和字符串&quot;&gt;&lt;a href=&quot;#第六节：哈希表和字符串&quot; class=&quot;headerlink&quot; title=&quot;第六节：哈希表和字符串&quot;&gt;&lt;/a&gt;第六节：哈希表和字符串&lt;/h1&gt;&lt;h2 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1. 基础&quot;&gt;&lt;/a&gt;1. 基础&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;哈希表(Hashtable，也叫散列表)，是根据关键字值(key)直接进行访问的数据结构，它通过把关键字值映射到表中一个位置(数组下标)来直接访问，以加快查找关键字值的速度。这个映射函数叫做哈希(散列)函数，存放记录的数组叫做哈希(散列)表。给定表M，存在函数f(key)，对任意的关键字值key，代入函数后若能得到包含该关键字的表中地址，称表M为哈希(Hash)表，函数f(key)为哈希(Hash)函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.当遇到负数或非常大的整数，如何进行哈希(映射)？如：-5、99999999、…&lt;/li&gt;
&lt;li&gt;2.当遇到字符串，如何进行哈希(映射)？如：abcdefg、XYZ、…&lt;/li&gt;
&lt;li&gt;3.当遇其他到无法直接映射的数据类型，如浮点数、数组、浮点数对象等等，如何进行哈希(映射)？如：1.2345、[1,2,3]、…&lt;br&gt;&lt;strong&gt;解决&lt;/strong&gt;:利用哈希函数，将关键字值(key)(大整数、字符串、浮点数等)转换为整数再对表长取余，从而关键字值被转换为哈希表的表长范围内的整数。采用&lt;strong&gt;除留取余法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;发生冲突&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放定址法 线性探测再散列，二次探测再散列&lt;/li&gt;
&lt;li&gt;在哈希法&lt;/li&gt;
&lt;li&gt;链地址法&lt;/li&gt;
&lt;li&gt;建立公共溢出区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在这里重点也是主要用链地址法&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="HashMap" scheme="http://looby.coding.me/betterming/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Crawl_1_maoyan</title>
    <link href="http://looby.coding.me/betterming/post/565e459b.html"/>
    <id>http://looby.coding.me/betterming/post/565e459b.html</id>
    <published>2019-06-12T15:24:20.552Z</published>
    <updated>2019-08-31T09:13:27.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爬取猫眼TOP100榜"><a href="#爬取猫眼TOP100榜" class="headerlink" title="爬取猫眼TOP100榜"></a>爬取猫眼TOP100榜</h1><h2 id="1-爬取流程"><a href="#1-爬取流程" class="headerlink" title="1. 爬取流程"></a>1. 爬取流程</h2><p>主要有以下四步：</p><ol><li>爬取单页内容：利利⽤用requests请求⽬目标站点，得 到单个⽹网⻚页HTML代码，返回结果。 </li><li>正则表达式分析：根据HTML代码分析得到电影的 名称、主演、上映时间、评分、 图⽚片链接等信息。 </li><li>保存至文件：通过⽂文件的形式将结果保存，每 一部电影一个结果一行Json字符串，图片保存成jpg格式。</li><li>开启循环及多线程：对多⻚页内容遍历，开启多线程提 ⾼高抓取速度。 <a id="more"></a> <h2 id="2-具体分析"><a href="#2-具体分析" class="headerlink" title="2. 具体分析"></a>2. 具体分析</h2></li></ol><h3 id="1-爬取单页内容"><a href="#1-爬取单页内容" class="headerlink" title="1. 爬取单页内容"></a>1. 爬取单页内容</h3><p>观察到每页的页数有offset 这个变量来控制，100条数据，10页，每页10条，所以offset从0到9。以offset作为变量，先爬取单页，然后循环爬取所有页。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">base_url = <span class="string">'https://maoyan.com'</span></span><br><span class="line">url = <span class="string">'https://maoyan.com/board/4?offset='</span> + str(offset)</span><br><span class="line">html = get_one_page(url)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></p><p>爬取部分通过requests中的get方法来实现，这是基本套路。正常情况下返回200状态码，非正常情况下返回None</p><h3 id="2-正则表达式分析"><a href="#2-正则表达式分析" class="headerlink" title="2. 正则表达式分析"></a>2. 正则表达式分析</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(base_url, html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'&lt;dd&gt;.*?&lt;i.*?board-index.*?"&gt;(\d+)&lt;/i&gt;.*?href="(.*?)".*?data-src="(.*?)".*?data-val=.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;'</span></span><br><span class="line">                         <span class="string">'.*?releasetime"&gt;(.*?)&lt;/p&gt;.*?score.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'url'</span>: base_url + item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">2</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">3</span>],</span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">4</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">5</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">6</span>] + item[<span class="number">7</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这部分主要是正则表达式的书写，对于学爬虫的童鞋，正则是基本功，既基础又重要，不会的自行谷歌。虽然对于网页的解析有很多中方法，比如BeautifulSoup，PyQuery等，会一些网页前端的知识就能掌握，但是别人问你学了爬虫会正则吗，你好意思说不会吗？模式串写好了，然后通过findall方法爬取所有符合模式串的字符串，并返回给items，这是一个列表。最后通过yield生成器生成一个字典返回</p><h3 id="3-保存文件"><a href="#3-保存文件" class="headerlink" title="3. 保存文件"></a>3. 保存文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>,<span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当在下面打印出来是中文汉字，而写成的文件出现编码格式则在json转换时出问题了</span></span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=<span class="literal">False</span>) + <span class="string">'\n'</span>)  <span class="comment"># 每行字典转换成json，再加上'\n',最后写入到文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_image</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'Downloading'</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            save_image(response.content)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_image</span><span class="params">(content)</span>:</span></span><br><span class="line">    file_path = <span class="string">'&#123;0&#125;/&#123;1&#125;.&#123;2&#125;'</span>.format(os.getcwd() + <span class="string">r'/images/'</span>, md5(content).hexdigest(), <span class="string">'jpg'</span>)</span><br><span class="line">    print(file_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">with</span> open(file_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">            f.close()</span><br></pre></td></tr></table></figure><p>这部分其实是很简单，非常套路，不过要注意的是文件的编码问题，中文编码要用’utf-8’，当让还有其他编码，源码中可以找到。</p><h3 id="4-开启循环及多线程"><a href="#4-开启循环及多线程" class="headerlink" title="4. 开启循环及多线程"></a>4. 开启循环及多线程</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool = Pool()</span><br><span class="line">pool.map(main, [i*<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure><p>就是开一进程池，然后用调用map方法，写上循环次数搞定。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  <span class="comment"># 通过进程池实现多进程抓取</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(base_url, html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'&lt;dd&gt;.*?&lt;i.*?board-index.*?"&gt;(\d+)&lt;/i&gt;.*?href="(.*?)".*?data-src="(.*?)".*?data-val=.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;'</span></span><br><span class="line">                         <span class="string">'.*?releasetime"&gt;(.*?)&lt;/p&gt;.*?score.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'url'</span>: base_url + item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">2</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">3</span>],</span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">4</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">5</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">6</span>] + item[<span class="number">7</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>,<span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当在下面打印出来是中文汉字，而写成的文件出现编码格式则在json转换时出问题了</span></span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=<span class="literal">False</span>) + <span class="string">'\n'</span>)  <span class="comment"># 每行字典转换成json，再加上'\n',最后写入到文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_image</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'Downloading'</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            save_image(response.content)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_image</span><span class="params">(content)</span>:</span></span><br><span class="line">    file_path = <span class="string">'&#123;0&#125;/&#123;1&#125;.&#123;2&#125;'</span>.format(os.getcwd() + <span class="string">r'/images/'</span>, md5(content).hexdigest(), <span class="string">'jpg'</span>)</span><br><span class="line">    print(file_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">with</span> open(file_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    base_url = <span class="string">'https://maoyan.com'</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4?offset='</span> + str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="comment"># print(html)</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(base_url, html):</span><br><span class="line">        print(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line">        download_image(item[<span class="string">'image'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># for i in range(10):</span></span><br><span class="line">    <span class="comment">#     main(i*10)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先构造一个进程池，然后使用map方法，让进程进入进程池</span></span><br><span class="line">    pool = Pool()</span><br><span class="line">    pool.map(main, [i*<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;爬取猫眼TOP100榜&quot;&gt;&lt;a href=&quot;#爬取猫眼TOP100榜&quot; class=&quot;headerlink&quot; title=&quot;爬取猫眼TOP100榜&quot;&gt;&lt;/a&gt;爬取猫眼TOP100榜&lt;/h1&gt;&lt;h2 id=&quot;1-爬取流程&quot;&gt;&lt;a href=&quot;#1-爬取流程&quot; class=&quot;headerlink&quot; title=&quot;1. 爬取流程&quot;&gt;&lt;/a&gt;1. 爬取流程&lt;/h2&gt;&lt;p&gt;主要有以下四步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;爬取单页内容：利利⽤用requests请求⽬目标站点，得 到单个⽹网⻚页HTML代码，返回结果。 &lt;/li&gt;
&lt;li&gt;正则表达式分析：根据HTML代码分析得到电影的 名称、主演、上映时间、评分、 图⽚片链接等信息。 &lt;/li&gt;
&lt;li&gt;保存至文件：通过⽂文件的形式将结果保存，每 一部电影一个结果一行Json字符串，图片保存成jpg格式。&lt;/li&gt;
&lt;li&gt;开启循环及多线程：对多⻚页内容遍历，开启多线程提 ⾼高抓取速度。
    
    </summary>
    
      <category term="Crawl" scheme="http://looby.coding.me/betterming/categories/Crawl/"/>
    
    
      <category term="Crawl" scheme="http://looby.coding.me/betterming/tags/Crawl/"/>
    
      <category term="regular expression" scheme="http://looby.coding.me/betterming/tags/regular-expression/"/>
    
  </entry>
  
  <entry>
    <title>Chap5_BinarySearch</title>
    <link href="http://looby.coding.me/betterming/post/d4f32829.html"/>
    <id>http://looby.coding.me/betterming/post/d4f32829.html</id>
    <published>2019-06-07T05:24:41.594Z</published>
    <updated>2019-08-18T15:18:11.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五节：二分查找与二叉查找树"><a href="#第五节：二分查找与二叉查找树" class="headerlink" title="第五节：二分查找与二叉查找树"></a>第五节：二分查找与二叉查找树</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p>&emsp;&emsp;二分查找又称折半查找，首先，假设表中元素是按升序排列，将表中间位置的关键字与查找关键字比较：</p><ol><li>如果两者相等，则查找成功；</li><li>否则利用中间位置将表分成前、后两个子表：<br> 1) 如果中间位置的关键字大于查找关键字，则进一步查找前一子表<br> 2) 否则进一步查找后一子表</li></ol><p>重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。<br><a id="more"></a></p><p><strong>基本版本</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sorted_array, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = sorted_array.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (target == sorted_array[mid]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &lt; sorted_array[mid]) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &gt; sorted_array[mid]) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：能变化的地方：while条件，三个if条件及相应的限制语句。</p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><h3 id="例1：LeetCode-35-Search-Insert-Position"><a href="#例1：LeetCode-35-Search-Insert-Position" class="headerlink" title="例1：LeetCode 35. Search Insert Position"></a>例1：LeetCode 35. Search Insert Position</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。<br>如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p><p>示例 1:<br>输入: [1,3,5,6], 5<br>输出: 2</p><p>示例 2:<br>输入: [1,3,5,6], 2<br>输出: 1</p><p>示例 3:<br>输入: [1,3,5,6], 7<br>输出: 4</p><p>示例 4:<br>输入: [1,3,5,6], 0<br>输出: 0</p><blockquote><p>思路：1.当target在nums中出现时，二分查找的流程无变化。<br>当target在nums没有出现时，按照上面的步骤，<br>若target在数组里面时，mid在变化的时候一定会出现 target 夹在nums[mid-1]和nums[mid]中间或者nums[mid]和nums[mid+1]中间。<br>若target在两边时，mid会在0或者nums.size()-1时结束循环。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="number">0</span> || target &gt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">index = mid;</span><br><span class="line">&#125;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == nums.size() - <span class="number">1</span> || target &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">index = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> test[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">nums.push_back(test[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %d index = %d\n"</span>, i, solve.searchInsert(nums, i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例2：LeetCode34-SearchforaRange"><a href="#例2：LeetCode34-SearchforaRange" class="headerlink" title="例2：LeetCode34.SearchforaRange"></a>例2：LeetCode34.SearchforaRange</h3><p>给定一个排序数组nums(nums中有重复元素)与目标值target，如果target在nums里出现，则返回target所在区间的左右端点下标，[左端点, 右端点]，<br>如果target在nums里未出现，则返回[-1, -1]。</p><blockquote><p>思路：查找区间左端点时，增加如下限制条件:<br>当target == nums[mid]时，若此时mid == 0或nums[mid-1] &lt; target，则说明mid即为区间左端点，返回；否则设置区间右端点为mid-1。</p></blockquote><blockquote><p>查找区间右端点时，增加如下限制条件:<br>当target == nums[mid]时，若此时mid == nums.size() – 1或 nums[mid + 1] &gt; target，则说明mid即为区间右端点；否则设置区间左端点为mid + 1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) <span class="keyword">return</span> mid;</span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) begin = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == nums.size() - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; target) <span class="keyword">return</span> mid;</span><br><span class="line">begin = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) begin = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result.push_back(left_bound(nums, target));</span><br><span class="line">result.push_back(right_bound(nums, target));</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> test[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">nums.push_back(test[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = solve.searchRange(nums, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d : [%d, %d]\n"</span>, i, result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例3：LeetCode33-SearchinRotatedSortedArray"><a href="#例3：LeetCode33-SearchinRotatedSortedArray" class="headerlink" title="例3：LeetCode33.SearchinRotatedSortedArray"></a>例3：LeetCode33.SearchinRotatedSortedArray</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:<br>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p><p>示例 2:<br>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p><blockquote><p>思路：将target,nums[mid],nums[begin],依次比较。<br>target,nums[mid]比较完成二分查找，nums[mid]和nums[begin]比较判断mid在递增序列还是，逆序列；nums[begin] 和target比较，判断target在递增序列还是你序列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[begin]) &#123; <span class="comment">// mid在递增序列中</span></span><br><span class="line"><span class="keyword">if</span> (target &gt;= nums[begin]) &#123;  <span class="comment">// target在递增序列中</span></span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// target 在逆序列中， mid在递增序列</span></span><br><span class="line">begin = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[begin]) begin = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[begin]) end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[begin]) &#123;  <span class="comment">// mid在递增序列中</span></span><br><span class="line">begin = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[begin]) &#123; <span class="comment">// mid不在递增序列中</span></span><br><span class="line"><span class="keyword">if</span> (nums[begin] &lt;= target) &#123;  <span class="comment">// 说明target 在递增序列中，mid不在递增序列中</span></span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// target 不在递增序列中，mid不在递增序列中</span></span><br><span class="line">begin = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[begin]) &#123;</span><br><span class="line">begin = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> test[] = &#123; <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">nums.push_back(test[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d : %d\n"</span>, i, solve.search(nums, i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树(Binary Search Tree)"></a>二叉查找树(Binary Search Tree)</h2><h3 id="l-定义："><a href="#l-定义：" class="headerlink" title="l.定义："></a>l.定义：</h3><blockquote><p>它是一颗具有下列性质的二叉树:<br>1.若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；<br>2.若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>3.左、右子树也分别为二叉排序树。<br>4.等于的情况只能出现在左子树或右子树中的某一侧。<br>其节点结构与二叉树节点一样由于二叉查找树的中序遍历是从小到大的，故又名二叉排序树(Binary Sort Tree)。</p></blockquote><h3 id="2-操作："><a href="#2-操作：" class="headerlink" title="2.操作："></a>2.操作：</h3><ol><li><p>二叉查找树插入节点：<br>将某节点(insert_node)，插入至以node为根二叉查找树中:<br>如果 insert_node节点值 小于 当前node节点值:<br> 如果node有左子树，则递归的将该节点插入至左子树为根二叉排序树中<br> 否则，将node-&gt;left赋值为该节点地址<br>否则(大于等于情况):<br> 如果node有右子树，则递归的将该节点插入至右子树为根二叉排序树中<br> 否则，将node-&gt;right赋值为该节点地址</p></li><li><p>二叉查找树查找数值:<br>查找数值value是否在二叉查找树中出现:<br>如果 value 等于当前查看node的节点值: 返回真<br>如果 value节点值 小于 当前node节点值:<br> 如果当前节点有左子树，继续在左子树中查找该值；否则，返回假<br>否则(value节点值 大于 当前node节点值):<br> 如果当前节点有右子树，继续在右子树中查找该值；否则，返回假</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_insert</span><span class="params">(TreeNode* node, TreeNode* insert_node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (insert_node-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) &#123; </span><br><span class="line">BST_insert(node-&gt;left, insert_node); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node-&gt;left = insert_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">BST_insert(node-&gt;right, insert_node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node-&gt;right = insert_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BST_search</span><span class="params">(TreeNode* node, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;val == value) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value &lt; node-&gt;val) &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) <span class="keyword">return</span> BST_search(node-&gt;left, value);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line"><span class="keyword">return</span> BST_search(node-&gt;right, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_print</span><span class="params">(TreeNode* node, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layer; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]\n"</span>, node-&gt;val);</span><br><span class="line">preorder_print(node-&gt;left, layer+<span class="number">1</span>);</span><br><span class="line">preorder_print(node-&gt;right, layer+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_print</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序排序</span></span><br><span class="line">inorder_print(node-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d] "</span>, node-&gt;val);</span><br><span class="line">inorder_print(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">TreeNode <span class="title">root</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; node_vec;</span><br><span class="line"><span class="keyword">int</span> test[] = &#123; <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">15</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> test2[] = &#123; <span class="number">10</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">node_vec.push_back(<span class="keyword">new</span> TreeNode(test[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node_vec.size(); i++) &#123;</span><br><span class="line">BST_insert(&amp;root, node_vec[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Inorder:"</span>);</span><br><span class="line">inorder_print(&amp;root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Preorder:\n"</span>);</span><br><span class="line">preorder_print(&amp;root, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (BST_search(&amp;root, test2[i])) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d in BST.\n"</span>, test2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d NOT in BST.\n"</span>, test2[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例4：LeetCode-449-Serialize-and-Deserialize-BST"><a href="#例4：LeetCode-449-Serialize-and-Deserialize-BST" class="headerlink" title="例4：LeetCode 449. Serialize and Deserialize BST"></a>例4：LeetCode 449. Serialize and Deserialize BST</h3><blockquote><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，<br>或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p></blockquote><blockquote><p>设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。<br>您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。<br>编码的字符串应尽可能紧凑。</p></blockquote><blockquote><p>注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。</p></blockquote><blockquote><p>思路：<br>对二叉查找树进行前序遍历，将遍历得到的结果按顺序重新构造为一颗新的二叉查找树，新的二叉查找树与原二叉查找树完全一样。<br>二叉查找树编码为字符串：<br>    将二叉查找树前序遍历，遍历时将整型的数据转为字符串，并将这些字符串数据进行连接，连接时使用特殊符号分隔。<br>将字符串解码为二叉查找树:<br>    将字符串按照编码时的分隔符”#” ，将各个数字逐个拆分出来，将第一个数字构建为二叉查找树的根节点，<br>    后面各个数字构建出的节点按解析时的顺序插入根节点中，返回根节点，即完成了解码工作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_insert</span><span class="params">(TreeNode* node, TreeNode* insert_node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (insert_node-&gt;val &lt; node-&gt;val) &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">BST_insert(node-&gt;left, insert_node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node-&gt;left = insert_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">BST_insert(node-&gt;right, insert_node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node-&gt;right = insert_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> val, <span class="built_in">string</span> &amp;str_val)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">while</span> (val) &#123;</span><br><span class="line">temp += val % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">val /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = temp.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">str_val += temp[i];</span><br><span class="line">&#125;</span><br><span class="line">str_val += <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_preorder</span><span class="params">(TreeNode* node, <span class="built_in">string</span> &amp;data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">string</span> str_val;</span><br><span class="line">int2string(node-&gt;val, str_val);</span><br><span class="line">data += str_val;</span><br><span class="line">BST_preorder(node-&gt;left, data);</span><br><span class="line">BST_preorder(node-&gt;right, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_print</span><span class="params">(TreeNode *node, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layer; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]\n"</span>, node-&gt;val);</span><br><span class="line">preorder_print(node-&gt;left, layer + <span class="number">1</span>);</span><br><span class="line">preorder_print(node-&gt;right, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line">BST_preorder(root, data);</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; node_vec;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (data[i] != <span class="string">'#'</span>) &#123;</span><br><span class="line">val = val * <span class="number">10</span> + data[i] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node_vec.push_back(<span class="keyword">new</span> TreeNode(val));</span><br><span class="line">val = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node_vec.size(); i++) &#123;</span><br><span class="line">BST_insert(node_vec[<span class="number">0</span>], node_vec[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node_vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">TreeNode <span class="title">a</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">TreeNode <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">TreeNode <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">TreeNode <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">TreeNode <span class="title">e</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">TreeNode <span class="title">f</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">a.left = &amp;b;</span><br><span class="line">a.right = &amp;c;</span><br><span class="line">b.left = &amp;d;</span><br><span class="line">b.right = &amp;e;</span><br><span class="line">c.left = &amp;f;</span><br><span class="line">Codec solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data = solve.serialize(&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, data.c_str());</span><br><span class="line">TreeNode *root = solve.deserialize(data);</span><br><span class="line">preorder_print(root, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例5：LeetCode315-CountofSmallerNumbersAfterSelf"><a href="#例5：LeetCode315-CountofSmallerNumbersAfterSelf" class="headerlink" title="例5：LeetCode315.CountofSmallerNumbersAfterSelf"></a>例5：LeetCode315.CountofSmallerNumbersAfterSelf</h3><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><p>示例:<br>输入: [5,2,6,1]<br>输出: [2,1,1,0]<br>解释:<br>5 的右侧有 2 个更小的元素 (2 和 1).<br>2 的右侧仅有 1 个更小的元素 (1).<br>6 的右侧有 1 个更小的元素 (1).<br>1 的右侧有 0 个更小的元素.</p><blockquote><p>思路：1. 将原数组nums[]逆置，所以count[i]为为nums[0]、nums[1]、…、nums[i-1]中有多少个比nums[i]小的数</p><ol><li>再插入节点时，当待插入节点insert_node小于等于当前node-&gt;count++</li><li>当待插入节点大于当前节点node值时，count_small += node-&gt;count+1</li></ol></blockquote><blockquote><p>算法如下:<br>设置变量count_small = 0，记录在插入过程中，有多少个元素比插入节点值小；<br>若待插入节点值小于等于当前节点node值，node-&gt;count++，递归将该节点插入到当前节点左子树；<br>若待插入节点值大于当前节点node值，count_small += node-&gt;count + 1(当前节点左子树数 量 + 1)；<br>递归将该节点插入到当前节点右子树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">BSTNode* left;</span><br><span class="line">BSTNode* right;</span><br><span class="line">BSTNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), count(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_insert</span><span class="params">(BSTNode* node, BSTNode* insert_node, <span class="keyword">int</span> &amp;count_small)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (insert_node-&gt;val &lt;= node-&gt;val) &#123;</span><br><span class="line">node-&gt;count++;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">BST_insert(node-&gt;left, insert_node, count_small);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node-&gt;left = insert_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">count_small += node-&gt;count + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">BST_insert(node-&gt;right, insert_node, count_small);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node-&gt;right = insert_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;BSTNode*&gt; node_vec;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">node_vec.push_back(<span class="keyword">new</span> BSTNode(nums[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cnt.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node_vec.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> count_small = <span class="number">0</span>;</span><br><span class="line">BST_insert(node_vec[<span class="number">0</span>], node_vec[i], count_small);</span><br><span class="line">cnt.push_back(count_small);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = node_vec.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">delete</span> node_vec[i];</span><br><span class="line">result.push_back(cnt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> test[] = &#123; <span class="number">5</span>, <span class="number">-7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">nums.push_back(test[i]);</span><br><span class="line">&#125;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = solve.countSmaller(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, result[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第五节：二分查找与二叉查找树&quot;&gt;&lt;a href=&quot;#第五节：二分查找与二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;第五节：二分查找与二叉查找树&quot;&gt;&lt;/a&gt;第五节：二分查找与二叉查找树&lt;/h1&gt;&lt;h2 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1. 基础&quot;&gt;&lt;/a&gt;1. 基础&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;二分查找又称折半查找，首先，假设表中元素是按升序排列，将表中间位置的关键字与查找关键字比较：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果两者相等，则查找成功；&lt;/li&gt;
&lt;li&gt;否则利用中间位置将表分成前、后两个子表：&lt;br&gt; 1) 如果中间位置的关键字大于查找关键字，则进一步查找前一子表&lt;br&gt; 2) 否则进一步查找后一子表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="Binary Search" scheme="http://looby.coding.me/betterming/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Chap4_BacktrackingDivideAndConquer</title>
    <link href="http://looby.coding.me/betterming/post/c8a77db1.html"/>
    <id>http://looby.coding.me/betterming/post/c8a77db1.html</id>
    <published>2019-06-06T15:07:48.395Z</published>
    <updated>2019-06-06T15:46:48.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四节：递归，回溯与分治"><a href="#第四节：递归，回溯与分治" class="headerlink" title="第四节：递归，回溯与分治"></a>第四节：递归，回溯与分治</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><blockquote><p>回溯法：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，<br>当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。<br>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。<br>但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，<br>这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p></blockquote><blockquote><p>回溯法就是对隐式图的深度优先搜索算法<br><a id="more"></a></p></blockquote><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h2><h3 id="例1：LeetCode-78-Subsets"><a href="#例1：LeetCode-78-Subsets" class="headerlink" title="例1：LeetCode 78. Subsets"></a>例1：LeetCode 78. Subsets</h3><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p><p>示例:<br>输入: nums = [1,2,3]<br>输出:<br>[<br>[3],<br>[1],<br>[2],<br>[1,2,3],<br>[1,3],<br>[2,3],<br>[1,2],<br>[]<br>]</p><blockquote><p>思路：</p><ol><li>回溯法</li><li>位运算法：<br>步骤1：构造all_set(为2的元素个数次幂)<br>步骤2：if(i &amp; (1 &lt;&lt; j)) item.push_back(nums[j])  //i for 0-&gt;all_set-1 与每个元素做与，true时表示i中有这个元素</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;item, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= nums.size()) <span class="keyword">return</span>;</span><br><span class="line">item.push_back(nums[i]);</span><br><span class="line">result.push_back(item);</span><br><span class="line">generate(i + <span class="number">1</span>, nums, item, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo, 产生[1],[1][2],[1][2][3]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">generate(<span class="number">0</span>, nums, item, result);</span><br><span class="line"><span class="comment">/*for (int i = 0; i &lt; nums.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">item.push_back(nums[i]);</span></span><br><span class="line"><span class="comment">result.push_back(item);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, result[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line">result.push_back(item);</span><br><span class="line">generate(<span class="number">0</span>, nums, item, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;item, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; nums.size()) <span class="keyword">return</span>;</span><br><span class="line">item.push_back(nums[i]);</span><br><span class="line">result.push_back(item);</span><br><span class="line">generate(i + <span class="number">1</span>, nums, item, result);</span><br><span class="line">item.pop_back();</span><br><span class="line">generate(i + <span class="number">1</span>, nums, item, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="keyword">int</span> all_set = <span class="number">1</span> &lt;&lt; nums.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all_set; i++) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span> &lt;&lt; j) &#123;</span><br><span class="line">item.push_back(nums[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="comment">//Solution solve;</span></span><br><span class="line">Solution1 solve;</span><br><span class="line">result = solve.subsets(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[i].size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, result[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例2：LeetCode-90-Subsets-II"><a href="#例2：LeetCode-90-Subsets-II" class="headerlink" title="例2：LeetCode 90. Subsets II"></a>例2：LeetCode 90. Subsets II</h3><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p><p>示例:<br>输入: [1,2,2]<br>输出:<br>[<br>[2],<br>[1],<br>[1,2,2],<br>[2,2],<br>[1,2],<br>[]<br>]</p><blockquote><p>思路：两种重复原因：</p><ol><li>不同位置的元素组成的集合是同一子集，顺序相同</li><li>不同位置的元素组成的集合是同一子集，顺序不同</li></ol></blockquote><blockquote><p>解决方法：先排序，再用set去重后放入result中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res_set;</span><br><span class="line">sort(nums.begin(), nums.end());</span><br><span class="line">result.push_back(item);</span><br><span class="line">generate(<span class="number">0</span>, nums, result, item, res_set);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res_set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= nums.size()) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">item.push_back(nums[i]);</span><br><span class="line"><span class="keyword">if</span> (res_set.find(item) == res_set.end()) &#123;</span><br><span class="line">result.push_back(item);</span><br><span class="line">res_set.insert(item);</span><br><span class="line">&#125;</span><br><span class="line">generate(i + <span class="number">1</span>, nums, result, item, res_set);</span><br><span class="line">item.pop_back();</span><br><span class="line">generate(i + <span class="number">1</span>, nums, result, item, res_set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">Solution solve;</span><br><span class="line">result = solve.subsetsWithDup(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[i].size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, result[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例3：LeetCode-40-Combination-Sum-II"><a href="#例3：LeetCode-40-Combination-Sum-II" class="headerlink" title="例3：LeetCode 40. Combination Sum II"></a>例3：LeetCode 40. Combination Sum II</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：<br>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。</p><p>示例 1:<br>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>[1, 7],<br>[1, 2, 5],<br>[2, 6],<br>[1, 1, 6]<br>]</p><p>示例 2:<br>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>[1,2,2],<br>[5]<br>]</p><blockquote><p>思路：再上一题的基础上剪枝</p></blockquote><p>python版<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">candidates.sort()</span><br><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(candidates, target, t)</span>:</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">res.append(t)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> num == candidates[i<span class="number">-1</span>]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> target &gt;= num:</span><br><span class="line">generate(candidates[i+<span class="number">1</span>:],target-num, t+ [num])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">generate(candidates, target, [])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>c++版<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res_set;</span><br><span class="line">sort(candidates.begin(), candidates.end());</span><br><span class="line">generate(<span class="number">0</span>, candidates, result, item, res_set, <span class="number">0</span>, target);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res_set, <span class="keyword">int</span> sum, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= nums.size() || sum &gt; target) &#123; <span class="keyword">return</span>; &#125;  <span class="comment">// 剪枝操作</span></span><br><span class="line">sum += nums[i];</span><br><span class="line">item.push_back(nums[i]);</span><br><span class="line"><span class="keyword">if</span> (target == sum &amp;&amp; res_set.find(item) == res_set.end()) &#123;</span><br><span class="line">result.push_back(item);</span><br><span class="line">res_set.insert(item);</span><br><span class="line">&#125;</span><br><span class="line">generate(i + <span class="number">1</span>, nums, result, item, res_set, sum, target);</span><br><span class="line">sum -= nums[i];</span><br><span class="line">item.pop_back();</span><br><span class="line">generate(i + <span class="number">1</span>, nums, result, item, res_set, sum, target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">10</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">7</span>);</span><br><span class="line">nums.push_back(<span class="number">6</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">Solution solve;</span><br><span class="line">result = solve.combinationSum2(nums, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[i].size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, result[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="例4：LeetCode-22-Generate-Parentheses"><a href="#例4：LeetCode-22-Generate-Parentheses" class="headerlink" title="例4：LeetCode 22. Generate Parentheses"></a>例4：LeetCode 22. Generate Parentheses</h3><p>生成括号：已知n组括号，开发一个程序，生成这n组括号所有的合法的组合可能。<br>例如：n=3<br>结果为： [“((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</p><blockquote><p>思路：n组括号产生所有情况，item存放括号字符串，n为组数，result为最终结果</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="built_in">string</span> item, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (item.size() == <span class="number">2</span> * n) &#123;</span><br><span class="line">result.push_back(item);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">generate(item + <span class="string">'('</span>, n, result);</span><br><span class="line">generate(item + <span class="string">')'</span>, n, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">generate(<span class="string">""</span>, <span class="number">2</span>, result);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result[i].c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">generate(<span class="string">""</span>, n, n, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="built_in">string</span> item, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">result.push_back(item);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">generate(item + <span class="string">'('</span>, left - <span class="number">1</span>, right, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">generate(item + <span class="string">')'</span>, left, right - <span class="number">1</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result = solve.generateParenthesis(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result[i].c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四节：递归，回溯与分治&quot;&gt;&lt;a href=&quot;#第四节：递归，回溯与分治&quot; class=&quot;headerlink&quot; title=&quot;第四节：递归，回溯与分治&quot;&gt;&lt;/a&gt;第四节：递归，回溯与分治&lt;/h1&gt;&lt;h2 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1. 基础&quot;&gt;&lt;/a&gt;1. 基础&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;回溯法：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，&lt;br&gt;当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。&lt;br&gt;回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。&lt;br&gt;但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，&lt;br&gt;这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。&lt;br&gt;许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回溯法就是对隐式图的深度优先搜索算法&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="Backtracking" scheme="http://looby.coding.me/betterming/tags/Backtracking/"/>
    
      <category term="DivideAndConquer" scheme="http://looby.coding.me/betterming/tags/DivideAndConquer/"/>
    
      <category term="Recursion" scheme="http://looby.coding.me/betterming/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>Chap3_Greedy</title>
    <link href="http://looby.coding.me/betterming/post/3d8555f3.html"/>
    <id>http://looby.coding.me/betterming/post/3d8555f3.html</id>
    <published>2019-06-06T13:52:18.664Z</published>
    <updated>2019-06-06T14:50:31.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>视频：<a href="https://www.bilibili.com/video/av36288901" target="_blank" rel="noopener">https://www.bilibili.com/video/av36288901</a></p></blockquote><h1 id="第三节：贪心算法"><a href="#第三节：贪心算法" class="headerlink" title="第三节：贪心算法"></a>第三节：贪心算法</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p><strong>贪心法: 遵循某种规律，不断贪心的选取当前最优策略的算法设计方法。</strong><br><a id="more"></a></p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><h3 id="例1-LeetCode-455-Assign-Cookies"><a href="#例1-LeetCode-455-Assign-Cookies" class="headerlink" title="例1.LeetCode 455. Assign Cookies"></a>例1.LeetCode 455. Assign Cookies</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>注意：<br>你可以假设胃口值为正。<br>一个小朋友最多只能拥有一块饼干。</p><p>示例 1:</p><p>输入: [1,2,3], [1,1]</p><p>输出: 1</p><p>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br>示例 2:</p><p>输入: [1,2], [1,2,3]</p><p>输出: 2</p><p>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p><blockquote><p>思路：</p><ol><li>需求因子数组g[]与糖果大小数组s[]进行从小到大的排序。</li><li>按照从小到大的顺序使用各种糖果尝试是否可满足某个孩子，每个孩子只尝试1次；若尝试成功，<br>则换下一个孩子尝试；直到发现没更多的孩子或没更多的糖果，循环结束。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::sort(g.begin(), g.end());</span><br><span class="line"><span class="built_in">std</span>::sort(s.begin(), s.end());</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; g.size() &amp;&amp; cookie &lt; s.size()) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[child] &lt;= s[cookie]) &#123;</span><br><span class="line">child++;</span><br><span class="line">&#125;</span><br><span class="line">cookie++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">g.push_back(<span class="number">5</span>);</span><br><span class="line">g.push_back(<span class="number">10</span>);</span><br><span class="line">g.push_back(<span class="number">2</span>);</span><br><span class="line">g.push_back(<span class="number">9</span>);</span><br><span class="line">g.push_back(<span class="number">15</span>);</span><br><span class="line">g.push_back(<span class="number">9</span>);</span><br><span class="line">s.push_back(<span class="number">6</span>);</span><br><span class="line">s.push_back(<span class="number">1</span>);</span><br><span class="line">s.push_back(<span class="number">20</span>);</span><br><span class="line">s.push_back(<span class="number">3</span>);</span><br><span class="line">s.push_back(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.findContentChildren(g, s));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例2：LeetCode-376-Wiggle-Subsequence"><a href="#例2：LeetCode-376-Wiggle-Subsequence" class="headerlink" title="例2：LeetCode 376. Wiggle Subsequence"></a>例2：LeetCode 376. Wiggle Subsequence</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><p>输入: [1,7,4,9,2,5]<br>输出: 6<br>解释: 整个序列均为摆动序列。<br>示例 2:</p><p>输入: [1,17,5,10,13,15,10,5,16,8]<br>输出: 7<br>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。<br>示例 3:</p><p>输入: [1,2,3,4,5,6,7,8,9]<br>输出: 2</p><blockquote><p>思路：当序列有一段连续的递增(或递减)时，为形成摇摆子序列，我们只需要保留这段连续的递增(或递减)的首尾元素，这样更可能使得尾部的后一个元素成为摇摆子序列的下一个元素。可使用状态机</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wigglenMaxLength</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BEGIN = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> UP = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> DOWN = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> STATE = BEGIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (STATE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> BEGIN:</span><br><span class="line"><span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">STATE = UP;</span><br><span class="line">max_length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">STATE = DOWN;</span><br><span class="line">max_length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> UP:</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">STATE = DOWN;</span><br><span class="line">max_length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DOWN:</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">STATE = UP;</span><br><span class="line">max_length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">17</span>);</span><br><span class="line">nums.push_back(<span class="number">5</span>);</span><br><span class="line">nums.push_back(<span class="number">10</span>);</span><br><span class="line">nums.push_back(<span class="number">13</span>);</span><br><span class="line">nums.push_back(<span class="number">15</span>);</span><br><span class="line">nums.push_back(<span class="number">10</span>);</span><br><span class="line">nums.push_back(<span class="number">5</span>);</span><br><span class="line">nums.push_back(<span class="number">16</span>);</span><br><span class="line">nums.push_back(<span class="number">8</span>);</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.wigglenMaxLength(nums));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例3：LeetCode-402-Remove-K-Digits"><a href="#例3：LeetCode-402-Remove-K-Digits" class="headerlink" title="例3：LeetCode 402. Remove K Digits"></a>例3：LeetCode 402. Remove K Digits</h3><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><p>num 的长度小于 10002 且 ≥ k。<br>num 不会包含任何前导零。<br>示例 1 :</p><p>输入: num = “1432219”, k = 3<br>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。<br>示例 2 :</p><p>输入: num = “10200”, k = 1<br>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。<br>示例 3 :</p><p>输入: num = “10”, k = 2<br>输出: “0”<br>解释: 从原数字移除所有的数字，剩余为空就是0。</p><blockquote><p>思路：利用栈结构（vector实现），从高位向低位遍历，如果对应的数字大于下一位数字，则把该位数字去掉，得到的数字最小。<br>注意几个边界：<br>1.当所有数字都扫描完成后，k仍然&gt;0时，出栈直到k为0<br>2.当数字中有0出现时，且栈为空时不能入栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> number = num[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(S.size() != <span class="number">0</span> &amp;&amp; S[S.size()<span class="number">-1</span>] &gt; number &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    S.pop_back();</span><br><span class="line">    k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (number != <span class="number">0</span> || S.size() != <span class="number">0</span>)&#123;</span><br><span class="line">    S.push_back(number);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(S.size() != <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    S.pop_back();</span><br><span class="line">    k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); i++)&#123;</span><br><span class="line">    result.append(<span class="number">1</span>, <span class="string">'0'</span> + S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="string">""</span>)&#123;</span><br><span class="line">    result = <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> result = solve.removeKdigits(<span class="string">"1432219"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result.c_str());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> result2 = solve.removeKdigits(<span class="string">"100200"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, result2.c_str());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例4：LeetCode-55-Jump-Game"><a href="#例4：LeetCode-55-Jump-Game" class="headerlink" title="例4：LeetCode 55. Jump Game"></a>例4：LeetCode 55. Jump Game</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。<br>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。</p><blockquote><p>思路：i表示当前位置，初始为0；i能不能加1要判断i是否小于dist,即i能否到达该位置。<br>dist表示到目前i位置为止，可到达的最远位置。<br>最后判断dist是否为nums.size() - 1;</p></blockquote><blockquote><p>用到的贪心思想是i位置最远可以跳到j位置，故第i位置还可以跳到第i+1，i+2,….j-1, j位置；<br>那么从第i位置应该跳到那个位置呢？应该跳到index[i+1],index[i+2],…..,index[j-1],index[j]中最大的哪一个位置<br>此处用到了贪心算法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span> &amp;&amp; dist &gt;= i; i++) &#123;</span><br><span class="line">dist = <span class="built_in">std</span>::max(dist, i + nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist &gt;= nums.size() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">3</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">4</span>);</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.canJump(nums));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例5：LeetCode-45-Jump-Game-II"><a href="#例5：LeetCode-45-Jump-Game-II" class="headerlink" title="例5：LeetCode 45. Jump Game II"></a>例5：LeetCode 45. Jump Game II</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>示例:<br>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置.</p><blockquote><p>思路：在无法到达更远位置时，在这之前应该跳到一个可以到达更远位置的位置<br>current_max表示当前可达最远位置<br>pre_max表示在遍历过程中，各个位置可到达的最远位置<br>jump_min最少跳跃次数<br>过程：i遍历nums[],i超过current_max时，更新current_max=pre_max<br>遍历过程中，跟新pre_max = max(pre_max,nums[i]+i)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur_max = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> pre_max = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> jump_min = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i&gt;cur_max) &#123;</span><br><span class="line">cur_max = pre_max;</span><br><span class="line">jump_min++;</span><br><span class="line">&#125;</span><br><span class="line">pre_max = <span class="built_in">std</span>::max(pre_max, nums[i] + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jump_min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">3</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">4</span>);</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.jump(nums));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例6：LeetCode-452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#例6：LeetCode-452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="例6：LeetCode 452. Minimum Number of Arrows to Burst Balloons"></a>例6：LeetCode 452. Minimum Number of Arrows to Burst Balloons</h3><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。<br>由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。<br>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，<br>若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。<br>弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>Example:<br>输入:<br>[[10,16], [2,8], [1,6], [7,12]]<br>输出:<br>2<br>解释:<br>对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</p><blockquote><p>思考：首先将样例画图，找出规律理解题意，其次举例子，1个气球最少用1个箭，2个重叠气球最少用一个箭，3个重叠气球最少用一个箭<br>因此，尽量使气球重叠部分最多一些，那么如何算法化呢？当然是排序，然后遍历维护射击区间。<br>1，排序，按照左端点。<br>2，遍历气球数组，维护一个设计区间，初始化就是第一个气球的区间，同时贪心尽可能多的击穿更多气球，然后更新设计区间。<br>3，直到没有新的气球可以被击穿，那么增加箭，同时维护一个新的射击区间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];<span class="comment">//用于无需考虑左端点相同时候的排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (points.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//传入数据为空直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::sort(points.begin(), points.end(), cmp);<span class="comment">//按照左端点排序</span></span><br><span class="line"><span class="keyword">int</span> shoot_num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> shoot_begin = points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> shoot_end = points[<span class="number">0</span>][<span class="number">1</span>];<span class="comment">//初始化弓箭数目，第一个维护射击区间，就是第一个气球的左右端点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++) &#123;<span class="comment">//此处就是遍历更新射击空间</span></span><br><span class="line"><span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= shoot_end) &#123;</span><br><span class="line">shoot_begin = points[i][<span class="number">0</span>]; <span class="comment">//新气球左端点小于设计区间右端点，那么说明可以击穿，更新射击区间左端点</span></span><br><span class="line"><span class="keyword">if</span> (points[i][<span class="number">1</span>] &lt; shoot_end) &#123;</span><br><span class="line">shoot_end = points[i][<span class="number">1</span>];<span class="comment">//新球右端点小于设计区间左端点，那么说明可以击穿，更新设计区间右端点</span></span><br><span class="line"> <span class="comment">//设计区间维护其实就是在不断缩小射击区间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//不满足情况时，多用一个弓箭</span></span><br><span class="line">shoot_num++;</span><br><span class="line">shoot_begin = points[i][<span class="number">0</span>];</span><br><span class="line">shoot_end = points[i][<span class="number">1</span>];<span class="comment">//初始化新的弓箭设计区域</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shoot_num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; points;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p1;</span><br><span class="line">p1.push_back(<span class="number">10</span>);</span><br><span class="line">p1.push_back(<span class="number">16</span>);</span><br><span class="line">points.push_back(p1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p2;</span><br><span class="line">p2.push_back(<span class="number">2</span>);</span><br><span class="line">p2.push_back(<span class="number">8</span>);</span><br><span class="line">points.push_back(p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p3;</span><br><span class="line">p3.push_back(<span class="number">1</span>);</span><br><span class="line">p3.push_back(<span class="number">6</span>);</span><br><span class="line">points.push_back(p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p4;</span><br><span class="line">p4.push_back(<span class="number">7</span>);</span><br><span class="line">p4.push_back(<span class="number">12</span>);</span><br><span class="line">points.push_back(p4);</span><br><span class="line"></span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.findMinArrowShots(points));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;视频：&lt;a href=&quot;https://www.bilibili.com/video/av36288901&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av36288901&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第三节：贪心算法&quot;&gt;&lt;a href=&quot;#第三节：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;第三节：贪心算法&quot;&gt;&lt;/a&gt;第三节：贪心算法&lt;/h1&gt;&lt;h2 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1. 基础&quot;&gt;&lt;/a&gt;1. 基础&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;贪心法: 遵循某种规律，不断贪心的选取当前最优策略的算法设计方法。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="Stack" scheme="http://looby.coding.me/betterming/tags/Stack/"/>
    
      <category term="Greedy" scheme="http://looby.coding.me/betterming/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Chap2_StackQueue</title>
    <link href="http://looby.coding.me/betterming/post/ea08c047.html"/>
    <id>http://looby.coding.me/betterming/post/ea08c047.html</id>
    <published>2019-05-26T02:53:28.550Z</published>
    <updated>2019-06-06T15:07:16.541Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>视频：<a href="https://www.bilibili.com/video/av36288901" target="_blank" rel="noopener">https://www.bilibili.com/video/av36288901</a></p></blockquote><h1 id="第二节：栈，队列，堆"><a href="#第二节：栈，队列，堆" class="headerlink" title="第二节：栈，队列，堆"></a>第二节：栈，队列，堆</h1><h2 id="1-基础："><a href="#1-基础：" class="headerlink" title="1. 基础："></a>1. 基础：</h2><blockquote><p>栈，先进后出的线性表</p><ul><li>s.push(item);        //将item压入栈顶</li><li>s.pop();            //删除栈顶的元素，但不会返回</li><li>s.top();            //返回栈顶的元素，但不会删除</li><li>s.size();            //返回栈中元素的个数</li><li>s.empty();            //检查栈是否为空，如果为空返回true，否则返回false </li></ul></blockquote><blockquote><p>队列，先进先出的线性表。</p><ul><li>q.push(item)           //将item压入队列尾部</li><li>q.pop()                //删除队首元素，但不返回</li><li>q.front()              //返回队首元素，但不删除</li><li>q.back()               //返回队尾元素，但不删除</li><li>q.size()               //返回队列中元素的个数</li><li>q.empty()              //检查队列是否为空，如果为空返回true，否则返回false<a id="more"></a></li></ul></blockquote><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><h3 id="例1-LeetCode-225-Implement-Stack-using-Queues"><a href="#例1-LeetCode-225-Implement-Stack-using-Queues" class="headerlink" title="例1: LeetCode 225. Implement Stack using Queues"></a>例1: LeetCode 225. Implement Stack using Queues</h3><blockquote><p>使用队列实现栈的下列操作：<br>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空</p></blockquote><blockquote><p>注意:<br>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p></blockquote><blockquote><p>思路: 利用两个队列来实现一个栈,主要看push</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">MyStack() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x onto stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">temp.push(x);</span><br><span class="line"><span class="keyword">while</span> (!_data.empty()) &#123;</span><br><span class="line">temp.push(_data.front());</span><br><span class="line">_data.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">_data.push(temp.front());</span><br><span class="line">temp.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = _data.front();</span><br><span class="line">_data.pop();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the top element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _data.front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _data.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment">* obj-&gt;push(x);</span></span><br><span class="line"><span class="comment">* int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment">* int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment">* bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyStack S;</span><br><span class="line">S.push(<span class="number">1</span>);</span><br><span class="line">S.push(<span class="number">2</span>);</span><br><span class="line">S.push(<span class="number">3</span>);</span><br><span class="line">S.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S.top());</span><br><span class="line">S.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S.top());</span><br><span class="line">S.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S.top());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例2-LeetCode-232-Implement-Queue-using-Stacks"><a href="#例2-LeetCode-232-Implement-Queue-using-Stacks" class="headerlink" title="例2:LeetCode 232. Implement Queue using Stacks"></a>例2:LeetCode 232. Implement Queue using Stacks</h3><blockquote><p>使用栈实现队列的下列操作：<br>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p></blockquote><blockquote><p>示例:<br>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false<br>说明:<br>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">while</span> (!_data.empty()) &#123;</span><br><span class="line">temp.push(_data.top());</span><br><span class="line">_data.pop();</span><br><span class="line">&#125;</span><br><span class="line">temp.push(x);</span><br><span class="line"><span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">_data.push(temp.top());</span><br><span class="line">temp.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = _data.top();</span><br><span class="line">_data.pop();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _data.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment">* obj-&gt;push(x);</span></span><br><span class="line"><span class="comment">* int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment">* int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment">* bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyQueue Q;</span><br><span class="line">Q.push(<span class="number">1</span>);</span><br><span class="line">Q.push(<span class="number">2</span>);</span><br><span class="line">Q.push(<span class="number">3</span>);</span><br><span class="line">Q.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Q.peek());</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Q.peek());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例3-LeetCode-155-Min-Stack"><a href="#例3-LeetCode-155-Min-Stack" class="headerlink" title="例3:LeetCode 155. Min Stack"></a>例3:LeetCode 155. Min Stack</h3><blockquote><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。</p></blockquote><blockquote><p>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p></blockquote><blockquote><p>思路：维护一个_min栈，使得每个元素时_data栈从底到该位置最小的值，</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">MinStack() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">_data.push(x);</span><br><span class="line"><span class="keyword">if</span> (_min.empty()) &#123;</span><br><span class="line">_min.push(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; _min.top()) &#123;</span><br><span class="line">x = _min.top();</span><br><span class="line">&#125;</span><br><span class="line">_min.push(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_data.pop();</span><br><span class="line">_min.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _min.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MinStack minStack;</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"top = [%d]\n"</span>, minStack.top());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"min = [%d]\n\n"</span>, minStack.getMin());</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"top = [%d]\n"</span>, minStack.top());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"min = [%d]\n\n"</span>, minStack.getMin());</span><br><span class="line">minStack.push(<span class="number">-5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"top = [%d]\n"</span>, minStack.top());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"min = [%d]\n\n"</span>, minStack.getMin());</span><br><span class="line">minStack.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"top = [%d]\n"</span>, minStack.top());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"min = [%d]\n\n"</span>, minStack.getMin());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例4-poj-1363-Rails"><a href="#例4-poj-1363-Rails" class="headerlink" title="例4: poj 1363 Rails"></a>例4: poj 1363 Rails</h3><blockquote><p>已知从1至n的数字序列，按顺序入栈，每个数字入栈后即可出栈，也可在栈中停留，等待后面的数字入栈出栈后，该数字再出栈，求该数字序列的出栈序列是否合法？</p></blockquote><blockquote><p>思路：使用栈与队列模拟入栈、出栈过程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool check_is_valid_order(queue&lt;int&gt; &amp;order) &#123;</span></span><br><span class="line"><span class="comment">stack&lt;int&gt; S;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= order.size(); i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">S.push(i);</span></span><br><span class="line"><span class="comment">while (S.top() == order.front() &amp;&amp; !S.empty()) &#123;</span></span><br><span class="line"><span class="comment">order.pop();</span></span><br><span class="line"><span class="comment">S.pop();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if (!S.empty()) &#123;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_is_valid_order</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; &amp;order)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= order.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">S.push(i);</span><br><span class="line"><span class="keyword">while</span> (S.top() == order.front() &amp;&amp; !S.empty()) &#123;</span><br><span class="line">order.pop();</span><br><span class="line">S.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!S.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> train;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;train);</span><br><span class="line"><span class="keyword">while</span> (train) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">order.push(train);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;train);</span><br><span class="line">order.push(train);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check_is_valid_order(order)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;train);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例5：LeetCode-224-Basic-Calculator"><a href="#例5：LeetCode-224-Basic-Calculator" class="headerlink" title="例5：LeetCode 224. Basic Calculator"></a>例5：LeetCode 224. Basic Calculator</h3><blockquote><p>模拟计算器，实现基本的加减乘除<br>思路：状态机</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;number_stack, <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; &amp;operation_stack)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(number_stack.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = number_stack.top();</span><br><span class="line">number_stack.pop();</span><br><span class="line"><span class="keyword">int</span> num1 = number_stack.top();</span><br><span class="line">number_stack.pop();</span><br><span class="line"><span class="keyword">if</span>(operation_stack.top() == <span class="string">'+'</span>) number_stack.push(num1 + num2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(operation_stack.top() == <span class="string">'-'</span>) number_stack.push(num1 - num2);</span><br><span class="line">operation_stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;  <span class="comment">// "1+121 - (14+(5-6))"</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> STATE_BEGIN = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NUMBER_STATE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> OPERATION_STATE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; number_stack;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; operation_stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> STATE = STATE_BEGIN;</span><br><span class="line"><span class="keyword">int</span> compute_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(STATE)&#123;</span><br><span class="line"><span class="keyword">case</span> STATE_BEGIN:</span><br><span class="line"><span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) STATE = NUMBER_STATE;</span><br><span class="line"><span class="keyword">else</span> STATE = OPERATION_STATE;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NUMBER_STATE:</span><br><span class="line"><span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;=<span class="string">'9'</span>) number = number * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">number_stack.push(number);</span><br><span class="line"><span class="keyword">if</span>(compute_flag == <span class="number">1</span>) compute(number_stack, operation_stack);</span><br><span class="line">number = <span class="number">0</span>;</span><br><span class="line">i--;</span><br><span class="line">STATE = OPERATION_STATE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> OPERATION_STATE:</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">operation_stack.push(s[i]);</span><br><span class="line">compute_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">STATE = NUMBER_STATE;</span><br><span class="line">compute_flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">STATE = NUMBER_STATE;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">compute(number_stack, operation_stack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">number_stack.push(number);</span><br><span class="line">compute(number_stack, operation_stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(number == <span class="number">0</span> &amp;&amp; number_stack.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> number_stack.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">str_2_int</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">number = number*<span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"123445"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, str_2_int(s));</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"1+121 - (14-4+(5-6))"</span>;</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.calculate(str));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* STL中大小堆，优先级队列</span></span><br><span class="line"><span class="comment">priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt; small_heap;  //小根堆</span></span><br><span class="line"><span class="comment">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; big_heap2;  // 大根堆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; big_heap;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; small_heap;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; big_heap2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (big_heap.empty()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big_heap is empty!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> test[] = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">4</span>, <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">big_heap.push(test[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big_heap.top = %d\n"</span>, big_heap.top());</span><br><span class="line">big_heap.push(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big_heap.top = %d\n"</span>, big_heap.top());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">big_heap.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big_heap.top = %d\n"</span>, big_heap.top());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big_heap.size = %d\n"</span>, big_heap.size());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例6：-LeetCode-215-Kth-Largest-Element-in-an-Array"><a href="#例6：-LeetCode-215-Kth-Largest-Element-in-an-Array" class="headerlink" title="例6： LeetCode 215. Kth Largest Element in an Array"></a>例6： LeetCode 215. Kth Largest Element in an Array</h3><blockquote><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p></blockquote><blockquote><p>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p></blockquote><blockquote><p>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p></blockquote><blockquote><p>思路：维护一个K大小的最小堆，堆中元素个数小于K时，新元素之间进入堆；<br>否则，当新元素大于堆顶时，弹出堆顶，加入新元素，形成新堆。时间复杂度：O(nlogk)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.size() &lt; k) &#123;</span><br><span class="line">Q.push(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.top() &lt; nums[i]) &#123;</span><br><span class="line">Q.pop();</span><br><span class="line">Q.push(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Q.top();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.push_back(<span class="number">3</span>);</span><br><span class="line">nums.push_back(<span class="number">2</span>);</span><br><span class="line">nums.push_back(<span class="number">1</span>);</span><br><span class="line">nums.push_back(<span class="number">5</span>);</span><br><span class="line">nums.push_back(<span class="number">6</span>);</span><br><span class="line">nums.push_back(<span class="number">4</span>);</span><br><span class="line">Solution solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.findKthLargest(nums, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例7：LeetCode-295-Find-Median-from-Data-Stream"><a href="#例7：LeetCode-295-Find-Median-from-Data-Stream" class="headerlink" title="例7：LeetCode 295. Find Median from Data Stream"></a>例7：LeetCode 295. Find Median from Data Stream</h3><blockquote><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<br>例如，<br>[2,3,4] 的中位数是 3<br>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p></blockquote><blockquote><p>设计一个支持以下两种操作的数据结构：<br>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p></blockquote><blockquote><p>示例：<br>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p></blockquote><blockquote><p>进阶:<br>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？<br>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p></blockquote><blockquote><p>思路：使用两个堆来实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (big_queue.empty()) &#123;</span><br><span class="line">big_queue.push(num);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (big_queue.size() == small_queue.size()) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; big_queue.top()) big_queue.push(num);</span><br><span class="line"><span class="keyword">else</span> small_queue.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (big_queue.size() &gt; small_queue.size()) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &gt; big_queue.top()) small_queue.push(num);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> temp = big_queue.top();</span><br><span class="line">big_queue.pop();</span><br><span class="line">big_queue.push(num);</span><br><span class="line">small_queue.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; small_queue.top()) big_queue.push(num);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> temp = small_queue.top();</span><br><span class="line">small_queue.pop();</span><br><span class="line">small_queue.push(num);</span><br><span class="line">big_queue.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (big_queue.size() == small_queue.size()) <span class="keyword">return</span> (big_queue.top() + small_queue.top()) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (big_queue.size() &gt; small_queue.size()) <span class="keyword">return</span> big_queue.top();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> small_queue.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; small_queue;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; big_queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MedianFinder M;</span><br><span class="line"><span class="keyword">int</span> test[] = &#123;<span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">4</span>, <span class="number">33</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">M.addNum(test[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, M.findMedian());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;视频：&lt;a href=&quot;https://www.bilibili.com/video/av36288901&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av36288901&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第二节：栈，队列，堆&quot;&gt;&lt;a href=&quot;#第二节：栈，队列，堆&quot; class=&quot;headerlink&quot; title=&quot;第二节：栈，队列，堆&quot;&gt;&lt;/a&gt;第二节：栈，队列，堆&lt;/h1&gt;&lt;h2 id=&quot;1-基础：&quot;&gt;&lt;a href=&quot;#1-基础：&quot; class=&quot;headerlink&quot; title=&quot;1. 基础：&quot;&gt;&lt;/a&gt;1. 基础：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;栈，先进后出的线性表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s.push(item);        //将item压入栈顶&lt;/li&gt;
&lt;li&gt;s.pop();            //删除栈顶的元素，但不会返回&lt;/li&gt;
&lt;li&gt;s.top();            //返回栈顶的元素，但不会删除&lt;/li&gt;
&lt;li&gt;s.size();            //返回栈中元素的个数&lt;/li&gt;
&lt;li&gt;s.empty();            //检查栈是否为空，如果为空返回true，否则返回false &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;队列，先进先出的线性表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;q.push(item)           //将item压入队列尾部&lt;/li&gt;
&lt;li&gt;q.pop()                //删除队首元素，但不返回&lt;/li&gt;
&lt;li&gt;q.front()              //返回队首元素，但不删除&lt;/li&gt;
&lt;li&gt;q.back()               //返回队尾元素，但不删除&lt;/li&gt;
&lt;li&gt;q.size()               //返回队列中元素的个数&lt;/li&gt;
&lt;li&gt;q.empty()              //检查队列是否为空，如果为空返回true，否则返回false
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="Stack" scheme="http://looby.coding.me/betterming/tags/Stack/"/>
    
      <category term="Queue" scheme="http://looby.coding.me/betterming/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>DFS和BFS的一个应用</title>
    <link href="http://looby.coding.me/betterming/post/5bf81e17.html"/>
    <id>http://looby.coding.me/betterming/post/5bf81e17.html</id>
    <published>2019-05-21T05:29:01.528Z</published>
    <updated>2019-05-21T05:46:57.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>视频：<a href="https://www.bilibili.com/video/av36288901" target="_blank" rel="noopener">https://www.bilibili.com/video/av36288901</a></p></blockquote><h2 id="1-题目：LeetCode-207-Course-Schedule"><a href="#1-题目：LeetCode-207-Course-Schedule" class="headerlink" title="1.题目：LeetCode 207.Course Schedule"></a>1.题目：LeetCode 207.Course Schedule</h2><blockquote><p>现在你总共有 n 门课需要选，记为 0 到 n-1。<br>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]<br>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？<br><a id="more"></a></p></blockquote><blockquote><p>示例 1:<br>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。<br>示例 2:<br>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p></blockquote><p><strong>说明</strong>:<br>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br>提示:</p><p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。<br>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。<br>拓扑排序也可以通过 BFS 完成。</p><h2 id="2-思路："><a href="#2-思路：" class="headerlink" title="2.思路："></a>2.思路：</h2><blockquote><p>n个课程，m个依赖关系，可以看成有向图，是否可以全部完成，就是看是否有环，有环不能完成，无环可以完成。用深搜或者宽搜都行<br>深搜：如果正在搜索的某节点（还未退出该节点的递归深搜）又回到了该节点，即证明图有环<br>宽搜：将入度为0的节点放入队列，完成搜索取出，该节点所指向的所有节点都入读减1，入度为0添加到队列，完成搜索取出，如果最后队列为空则无环，否则有环</p></blockquote><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span>  <span class="comment">// 图的节点邻接表表示</span></span><br><span class="line"><span class="keyword">int</span> label;</span><br><span class="line"><span class="built_in">vector</span>&lt;GraphNode *&gt; neighbors;  <span class="comment">// 默认都是NULL</span></span><br><span class="line">GraphNode(<span class="keyword">int</span> x) :label(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;GraphNode *&gt; graph; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit; <span class="comment">// visit:-1表示没有访问过，0表示正在访问，1表示已经访问过了</span></span><br><span class="line"><span class="comment">// 构造链接表图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">graph.push_back(<span class="keyword">new</span> GraphNode(i));</span><br><span class="line">visit.push_back(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">GraphNode* begin = graph[prerequisites[i][<span class="number">1</span>]];</span><br><span class="line">GraphNode* end = graph[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">begin-&gt;neighbors.push_back(end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i] == <span class="number">-1</span> &amp;&amp; !DFS_graph(graph[i], visit)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">delete</span> graph[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS_graph</span><span class="params">(GraphNode *node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visit)</span> </span>&#123;</span><br><span class="line">visit[node-&gt;label] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[node-&gt;neighbors[i]-&gt;label] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (DFS_graph(node-&gt;neighbors[i], visit) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (visit[node-&gt;neighbors[i]-&gt;label] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[node-&gt;label] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;GraphNode *&gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">degree.push_back(<span class="number">0</span>);</span><br><span class="line">graph.push_back(<span class="keyword">new</span> GraphNode(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">GraphNode *begin = graph[prerequisites[i][<span class="number">1</span>]];</span><br><span class="line">GraphNode *end = graph[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">begin-&gt;neighbors.push_back(end);</span><br><span class="line">degree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;GraphNode *&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (degree[i] == <span class="number">0</span>) Q.push(graph[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">GraphNode *node = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.size(); i++) &#123;</span><br><span class="line">degree[node-&gt;neighbors[i]-&gt;label]--;</span><br><span class="line"><span class="keyword">if</span> (degree[node-&gt;neighbors[i]-&gt;label] == <span class="number">0</span>) Q.push(node-&gt;neighbors[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++) &#123;</span><br><span class="line"><span class="keyword">delete</span> graph[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; degree.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (degree[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; prerequisites;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t1;</span><br><span class="line">t1.push_back(<span class="number">1</span>);</span><br><span class="line">t1.push_back(<span class="number">0</span>);</span><br><span class="line">prerequisites.push_back(t1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t2;</span><br><span class="line">t2.push_back(<span class="number">2</span>);</span><br><span class="line">t2.push_back(<span class="number">0</span>);</span><br><span class="line">prerequisites.push_back(t2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t3;</span><br><span class="line">t3.push_back(<span class="number">3</span>);</span><br><span class="line">t3.push_back(<span class="number">1</span>);</span><br><span class="line">prerequisites.push_back(t3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t4;</span><br><span class="line">t4.push_back(<span class="number">3</span>);</span><br><span class="line">t4.push_back(<span class="number">2</span>);</span><br><span class="line">prerequisites.push_back(t4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution solve;</span></span><br><span class="line">Solution1 solve;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve.canFinish(<span class="number">4</span>, prerequisites));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;视频：&lt;a href=&quot;https://www.bilibili.com/video/av36288901&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av36288901&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-题目：LeetCode-207-Course-Schedule&quot;&gt;&lt;a href=&quot;#1-题目：LeetCode-207-Course-Schedule&quot; class=&quot;headerlink&quot; title=&quot;1.题目：LeetCode 207.Course Schedule&quot;&gt;&lt;/a&gt;1.题目：LeetCode 207.Course Schedule&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;现在你总共有 n 门课需要选，记为 0 到 n-1。&lt;br&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]&lt;br&gt;给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="BFS" scheme="http://looby.coding.me/betterming/tags/BFS/"/>
    
      <category term="DFS" scheme="http://looby.coding.me/betterming/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Chap1_LinkedList</title>
    <link href="http://looby.coding.me/betterming/post/60f57c72.html"/>
    <id>http://looby.coding.me/betterming/post/60f57c72.html</id>
    <published>2019-05-20T12:30:33.972Z</published>
    <updated>2019-06-02T12:04:54.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>视频：<a href="https://www.bilibili.com/video/av36288901" target="_blank" rel="noopener">https://www.bilibili.com/video/av36288901</a></p></blockquote><h1 id="第一节：链表"><a href="#第一节：链表" class="headerlink" title="第一节：链表"></a>第一节：链表</h1><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><h3 id="例1-LeetCode-206-Reverse-Linked-List"><a href="#例1-LeetCode-206-Reverse-Linked-List" class="headerlink" title="例1. LeetCode 206. Reverse Linked List"></a>例1. LeetCode 206. Reverse Linked List</h3><blockquote><p>反转一个单链表。(不使用额外空间)<br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><blockquote><p><strong>思路：头插法</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode *new_head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">ListNode *next = head-&gt;next;</span><br><span class="line">head-&gt;next = new_head;</span><br><span class="line">new_head = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">Solution solve;</span><br><span class="line">ListNode *head = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Before reverse:\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = solve.reverseList(&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"After reverse:\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例2：LeetCode-92-Reverse-Linked-List-II"><a href="#例2：LeetCode-92-Reverse-Linked-List-II" class="headerlink" title="例2：LeetCode 92. Reverse Linked List II"></a>例2：LeetCode 92. Reverse Linked List II</h3><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。<br>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p></blockquote><blockquote><p>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><blockquote><p><strong>思路：保存逆置段头节点前驱pre_head，逆置段尾节点modify_list_tail，然后进行连接</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> change_len = n - m + <span class="number">1</span>;</span><br><span class="line">ListNode *pre_head = <span class="literal">NULL</span>; <span class="comment">// 开始逆置节点的前驱</span></span><br><span class="line">ListNode *result = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; --m) &#123;  <span class="comment">// head 向前移动m-1个位置，pre_head指向开始逆置节点的前驱</span></span><br><span class="line">pre_head = head;</span><br><span class="line">head = head-&gt;next;  <span class="comment">// head 指向开始逆置的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode* modify_list_tail = head;  <span class="comment">// mlt指向当前的head，即逆置后链表尾</span></span><br><span class="line">ListNode* new_head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; change_len) &#123;  <span class="comment">// 该部分和上面链表逆置一样，head最后指向n的后继</span></span><br><span class="line">ListNode* next = head-&gt;next; </span><br><span class="line">head-&gt;next = new_head;</span><br><span class="line">new_head = head;</span><br><span class="line">head = next;</span><br><span class="line">change_len--;</span><br><span class="line">&#125;</span><br><span class="line">modify_list_tail-&gt;next = head;</span><br><span class="line"><span class="keyword">if</span> (pre_head) &#123;  <span class="comment">// 如果pre_head不空，说明不是从第一个节点开始逆置的，空表明m=1；</span></span><br><span class="line">pre_head-&gt;next = new_head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">result = new_head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">Solution solve;</span><br><span class="line">ListNode *head = solve.reverseBetween(&amp;a, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例3：LeetCode-160-Intersection-of-Two-LinkedLists"><a href="#例3：LeetCode-160-Intersection-of-Two-LinkedLists" class="headerlink" title="例3：LeetCode 160.Intersection of Two LinkedLists"></a>例3：LeetCode 160.Intersection of Two LinkedLists</h3><blockquote><p>编写一个程序，找到两个单链表相交的起始节点。<br>要求：不能破坏原来链表结构，链表没有环，时间复杂度O(n)，空间复杂度O(1)</p></blockquote><blockquote><p><strong>思路：用set容器/用较长的链表减去较短的链表，相同的部分同时遍历，第一个相同的点即为所求点。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  <span class="comment">// 用set容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;ListNode*&gt; st;</span><br><span class="line"><span class="keyword">while</span> (headA) &#123;</span><br><span class="line">st.insert(headA);</span><br><span class="line">headA = headA-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (headB) &#123;</span><br><span class="line"><span class="keyword">if</span> (st.find(headB) != st.end()) &#123;</span><br><span class="line"><span class="keyword">return</span> headB;</span><br><span class="line">&#125;</span><br><span class="line">headB = headB-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_list_length</span><span class="params">(ListNode *head)</span> </span>&#123;  <span class="comment">// 求链表长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">len++;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">forward_long_list</span><span class="params">(<span class="keyword">int</span> long_len, <span class="keyword">int</span> short_len, ListNode *head)</span> </span>&#123;  <span class="comment">// head指向相同长度部分</span></span><br><span class="line"><span class="keyword">int</span> delta = long_len - short_len;</span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; delta) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">delta--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span>  <span class="comment">// 用指针指向元素比较</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> list_A_len = get_list_length(headA);</span><br><span class="line"><span class="keyword">int</span> list_B_len = get_list_length(headB);</span><br><span class="line"><span class="keyword">if</span> (list_A_len &gt; list_B_len) &#123;</span><br><span class="line">headA = forward_long_list(list_A_len, list_B_len, headA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">headB = forward_long_list(list_B_len, list_A_len, headB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (headA &amp;&amp; headB) &#123;</span><br><span class="line"><span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line"><span class="keyword">return</span> headA;</span><br><span class="line">&#125;</span><br><span class="line">headA = headA-&gt;next;</span><br><span class="line">headB = headB-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b3</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c1</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c2</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c3</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">a1.next = &amp;a2;</span><br><span class="line">a2.next = &amp;c1;</span><br><span class="line">c1.next = &amp;c2;</span><br><span class="line">c2.next = &amp;c3;</span><br><span class="line">b1.next = &amp;b2;</span><br><span class="line">b2.next = &amp;b3;</span><br><span class="line">b3.next = &amp;c1;</span><br><span class="line"></span><br><span class="line">Solution1 solve;</span><br><span class="line">ListNode *result = solve.getIntersectionNode(&amp;a1, &amp;b1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result-&gt;val);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例4：LeetCode-142-Linked-List-Cycle-II"><a href="#例4：LeetCode-142-Linked-List-Cycle-II" class="headerlink" title="例4：LeetCode 142. Linked List Cycle II"></a>例4：LeetCode 142. Linked List Cycle II</h3><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。<br>如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表。</p></blockquote><blockquote><p>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><blockquote><p><strong>思路</strong>：</p><ol><li>set容器</li><li>快慢指针：fast指针是slow指针速度的两倍，相遇时节点为meet，那么一个从头节点出发，一个从meet出发，相遇时即为环开始时位置。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode *&gt; node_set;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="keyword">if</span> (node_set.find(head) != node_set.end()) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">node_set.insert(head);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* meet = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (fast) &#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!fast) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">meet = fast;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meet == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果没有相遇，表明没有环</span></span><br><span class="line"><span class="keyword">while</span> (meet &amp;&amp; head) &#123;</span><br><span class="line"><span class="keyword">if</span> (head == meet) <span class="keyword">return</span> head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">meet = meet-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">f</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">e.next = &amp;f;</span><br><span class="line">f.next = &amp;c;</span><br><span class="line">    <span class="comment">// Solution solve;</span></span><br><span class="line">Solution1 solve;</span><br><span class="line">ListNode *node = solve.detectCycle(&amp;a);</span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, node-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例5：LeetCode-86-Partition-List"><a href="#例5：LeetCode-86-Partition-List" class="headerlink" title="例5：LeetCode 86.Partition List"></a>例5：LeetCode 86.Partition List</h2><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。<br>你应当保留两个分区中每个节点的初始相对位置。</p></blockquote><blockquote><p>示例:<br>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><blockquote><p><strong>思路：用俩个零时头节点将大于/小于x的节点放入这两个链表中</strong><br>ListNode less_head(0);<br>ListNode more_head(0);<br>ListNode<em> less_ptr = &less_head;<br>ListNode</em> more_ptr = &more_head;<br>less_ptr始终指向小链表尾部，动态移动<br>more_ptr始终指向大链表尾部，动态移动</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">less_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">more_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode* less_ptr = &amp;less_head;</span><br><span class="line">ListNode* more_ptr = &amp;more_head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">less_ptr-&gt;next = head;</span><br><span class="line">less_ptr = less_ptr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">more_ptr-&gt;next = head;</span><br><span class="line">more_ptr = more_ptr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">less_ptr-&gt;next = more_head.next;</span><br><span class="line">more_ptr-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> less_head.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">e.next = &amp;f;</span><br><span class="line">Solution solve;</span><br><span class="line">ListNode *head = solve.partition(&amp;a, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例6：LeetCode-138-Copy-List-with-Random-Pointer"><a href="#例6：LeetCode-138-Copy-List-with-Random-Pointer" class="headerlink" title="例6：LeetCode 138.Copy List with Random Pointer"></a>例6：LeetCode 138.Copy List with Random Pointer</h3><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。<br>要求返回这个链表的深拷贝。</p></blockquote><blockquote><p><strong>思路：巧用数据结构</strong><br>map:将原地址与节点位置做映射 node_map<br>vector:根据节点位置将新链表节点存入其中 node_vec</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node* next;</span><br><span class="line">Node* random;</span><br><span class="line"></span><br><span class="line">Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> _val, Node* _next, Node* _random) &#123;</span><br><span class="line">val = _val;</span><br><span class="line">next = _next;</span><br><span class="line">random = _random;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;Node*, <span class="keyword">int</span>&gt; node_map;  <span class="comment">// 将原地址与节点位置做映射</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node *&gt; node_vec;   <span class="comment">// 根据节点位置将新链表节点存入其中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步：一个while循环将原节点地址与位置做映射，将新节点按照源节点位置push到node_vec中</span></span><br><span class="line">Node* ptr = head;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ptr) &#123;</span><br><span class="line">node_vec.push_back(<span class="keyword">new</span> Node(ptr-&gt;val));</span><br><span class="line">node_map[ptr] = i;</span><br><span class="line">ptr = ptr-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">node_vec.push_back(<span class="number">0</span>);  <span class="comment">// 链表最后一个节点的next为NULL；</span></span><br><span class="line">ptr = head;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ptr)</span><br><span class="line">&#123;</span><br><span class="line">node_vec[i]-&gt;next = node_vec[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ptr-&gt;random) &#123;</span><br><span class="line"><span class="keyword">int</span> id = node_map[ptr-&gt;random];</span><br><span class="line">node_vec[i]-&gt;random = node_vec[id];</span><br><span class="line">&#125;</span><br><span class="line">ptr = ptr-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node_vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">RandomListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">RandomListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">RandomListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">RandomListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">RandomListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">a.random = &amp;c;</span><br><span class="line">b.random = &amp;d;</span><br><span class="line">c.random = &amp;c;</span><br><span class="line">e.random = &amp;d;</span><br><span class="line">Solution solve;</span><br><span class="line">RandomListNode *head = solve.copyRandomList(&amp;a);</span><br><span class="line"><span class="keyword">while</span>(head)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"label = %d "</span>, head-&gt;label);</span><br><span class="line"><span class="keyword">if</span> (head-&gt;random)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"rand = %d\n"</span>, head-&gt;random-&gt;label);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"rand = NULL\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例7：LeetCode-21-Merge-Two-Sorted-Lists"><a href="#例7：LeetCode-21-Merge-Two-Sorted-Lists" class="headerlink" title="例7：LeetCode 21.Merge Two Sorted Lists"></a>例7：LeetCode 21.Merge Two Sorted Lists</h3><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。<br>新链表是通过拼接给定的两个链表的所有节点组成的。</p></blockquote><blockquote><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><blockquote><p><strong>思路：很简单，比较两个链表节点值大小，小的先放，大的后放。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">temp_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode* pre = &amp;temp_head;</span><br><span class="line"><span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line"><span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">pre-&gt;next = l1;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pre-&gt;next = l2;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l1) &#123;</span><br><span class="line">pre-&gt;next = l1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l2) &#123;</span><br><span class="line">pre-&gt;next = l2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp_head.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">f</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">e.next = &amp;f;</span><br><span class="line">Solution solve;</span><br><span class="line">ListNode *head = solve.mergeTwoLists(&amp;a, &amp;d);</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例8：LeetCode-23-Merge-k-Sorted-Lists"><a href="#例8：LeetCode-23-Merge-k-Sorted-Lists" class="headerlink" title="例8：LeetCode 23.Merge k Sorted Lists"></a>例8：LeetCode 23.Merge k Sorted Lists</h3><blockquote><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度.</p></blockquote><blockquote><p>示例:<br>输入:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><blockquote><p><strong>思路：</strong></p><ol><li>k个链表按照次序合并k-1次，O(n*k^2)</li><li>将k*n个节点放入vector中，再排序，O(knlog(kn))</li><li>对k个链表分治，两两进行合并，O(knlogk)</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">temp_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode* pre = &amp;temp_head;</span><br><span class="line"><span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line"><span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">pre-&gt;next = l1;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pre-&gt;next = l2;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l1) &#123;</span><br><span class="line">pre-&gt;next = l1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l2) &#123;</span><br><span class="line">pre-&gt;next = l2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp_head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ListNode* a, <span class="keyword">const</span> ListNode* b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; node_vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">ListNode *head = lists[i];</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">node_vec.push_back(head);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node_vec.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">sort(node_vec.begin(), node_vec.end(), cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node_vec.size(); i++) &#123;</span><br><span class="line">node_vec[i - <span class="number">1</span>]-&gt;next = node_vec[i];</span><br><span class="line">&#125;</span><br><span class="line">node_vec[node_vec.size() - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> node_vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (lists.size() == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (lists.size() == <span class="number">2</span>) <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> mid = lists.size() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; sub1_lists;</span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; sub2_lists;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">sub1_lists.push_back(lists[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; lists.size(); i++) &#123;</span><br><span class="line">sub2_lists.push_back(lists[i]);</span><br><span class="line">&#125;</span><br><span class="line">ListNode *l1 = mergeKLists(sub1_lists);</span><br><span class="line">ListNode *l2 = mergeKLists(sub2_lists);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">f</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">g</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">h</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">e.next = &amp;f;</span><br><span class="line">g.next = &amp;h;</span><br><span class="line"><span class="comment">// Solution solve;</span></span><br><span class="line">Solution1 solve;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ListNode *&gt; lists;</span><br><span class="line">lists.push_back(&amp;a);</span><br><span class="line">lists.push_back(&amp;d);</span><br><span class="line">lists.push_back(&amp;g);</span><br><span class="line">ListNode *head = solve.mergeKLists(lists);</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;val);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;视频：&lt;a href=&quot;https://www.bilibili.com/video/av36288901&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av36288901&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第一节：链表&quot;&gt;&lt;a href=&quot;#第一节：链表&quot; class=&quot;headerlink&quot; title=&quot;第一节：链表&quot;&gt;&lt;/a&gt;第一节：链表&lt;/h1&gt;&lt;h2 id=&quot;1-数据结构&quot;&gt;&lt;a href=&quot;#1-数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 数据结构&quot;&gt;&lt;/a&gt;1. 数据结构&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ListNode *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ListNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) : val(x), next(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="LinkedList" scheme="http://looby.coding.me/betterming/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>opencv实现图片二值化</title>
    <link href="http://looby.coding.me/betterming/post/b7214e7b.html"/>
    <id>http://looby.coding.me/betterming/post/b7214e7b.html</id>
    <published>2019-02-13T14:55:00.000Z</published>
    <updated>2019-02-13T15:27:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用openCV来实现图像二值化，主要利用的函数有 cv2.threshold，cv2.adaptiveThreshold 等，具体内容如下：<br><a id="more"></a></p><h2 id="1-代码及其解析"><a href="#1-代码及其解析" class="headerlink" title="1. 代码及其解析"></a>1. 代码及其解析</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二值图像就是将灰度图转化成黑白图，没有灰，在一个值之前为黑，之后为白</span></span><br><span class="line"><span class="comment"># 有全局和局部两种</span></span><br><span class="line"><span class="comment"># 在使用全局阈值时，我们就是随便给了一个数来做阈值，那我们怎么知道我们选取的这个数的好坏呢？答案就是不停的尝试。</span></span><br><span class="line"><span class="comment"># 如果是一副双峰图像（简 单来说双峰图像是指图像直方图中存在两个峰）呢？</span></span><br><span class="line"><span class="comment"># 我们岂不是应该在两个峰之间的峰谷选一个值作为阈值？这就是 Otsu 二值化要做的。</span></span><br><span class="line"><span class="comment"># 简单来说就是对 一副双峰图像自动根据其直方图计算出一个阈值。</span></span><br><span class="line"><span class="comment"># （对于非双峰图像，这种方法 得到的结果可能会不理想）。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threshold_demo</span><span class="params">(image)</span>:</span></span><br><span class="line">    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个函数的第一个参数就是原图像，原图像应该是灰度图。</span></span><br><span class="line">    <span class="comment"># 第二个参数就是用来对像素值进行分类的阈值。</span></span><br><span class="line">    <span class="comment"># 第三个参数就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值</span></span><br><span class="line">    <span class="comment"># 第四个参数来决定阈值方法，见threshold_simple()</span></span><br><span class="line">    <span class="comment"># ret, binary = cv.threshold(gray, 127, 255, cv.THRESH_BINARY)</span></span><br><span class="line">    ret, binary = cv.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv.THRESH_BINARY | cv.THRESH_OTSU)</span><br><span class="line">    print(<span class="string">"threshold value: %s"</span>%ret)</span><br><span class="line">    cv.imshow(<span class="string">"threshold_demo"</span>, binary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threshold_simple</span><span class="params">(image)</span>:</span></span><br><span class="line">    img = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br><span class="line">    ret, thresh1 = cv.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">    ret, thresh2 = cv.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv.THRESH_BINARY_INV)</span><br><span class="line">    ret, thresh3 = cv.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv.THRESH_TRUNC)</span><br><span class="line">    ret, thresh4 = cv.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv.THRESH_TOZERO)</span><br><span class="line">    ret, thresh5 = cv.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv.THRESH_TOZERO_INV)</span><br><span class="line">    titles = [<span class="string">'Original Image'</span>, <span class="string">'BINARY'</span>, <span class="string">'BINARY_INV'</span>, <span class="string">'TRUNC'</span>, <span class="string">'TOZERO'</span>, <span class="string">'TOZERO_INV'</span>]</span><br><span class="line">    images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">'gray'</span>)  <span class="comment"># 将图像按2x3铺开</span></span><br><span class="line">        plt.title(titles[i])</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在前面的部分我们使用是全局阈值，整幅图像采用同一个数作为阈值。</span></span><br><span class="line"><span class="comment"># 当时这种方法并不适应与所有情况，尤其是当同一幅图像上的不同部分的具有不同亮度时。</span></span><br><span class="line"><span class="comment"># 这种情况下我们需要采用自适应阈值。此时的阈值是根据图像上的 每一个小区域计算与其对应的阈值。</span></span><br><span class="line"><span class="comment"># 因此在同一幅图像上的不同区域采用的是不同的阈值，从而使我们能在亮度不同的情况下得到更好的结果。</span></span><br><span class="line"><span class="comment"># 这种方法需要我们指定三个参数，返回值只有一个</span></span><br><span class="line"><span class="comment"># _MEAN_C：阈值取自相邻区域的平均值,_GAUSSIAN_C：阈值取值相邻区域 的加权和，权重为一个高斯窗口。</span></span><br><span class="line"><span class="comment"># Block Size - 邻域大小（用来计算阈值的区域大小）。</span></span><br><span class="line"><span class="comment"># C - 这就是是一个常数，阈值就等于的平均值或者加权平均值减去这个常数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threshold_adaptive</span><span class="params">(image)</span>:</span></span><br><span class="line">    img = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 中值滤波</span></span><br><span class="line">    img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    ret, th1 = cv.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">    <span class="comment"># 11 为 Block size, 2 为 C 值</span></span><br><span class="line">    th2 = cv.adaptiveThreshold(img, <span class="number">255</span>, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line">    th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    titles = [<span class="string">'Original Image'</span>, <span class="string">'Global Threshold (v = 127)'</span>, <span class="string">'Adaptive Mean Threshold'</span>, <span class="string">'Adaptive Gaussian Threshold'</span>]</span><br><span class="line">    images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">'gray'</span>)</span><br><span class="line">        plt.title(titles[i])</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threshold_custom</span><span class="params">(image)</span>:</span></span><br><span class="line">    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br><span class="line">    h, w = gray.shape[:<span class="number">2</span>]</span><br><span class="line">    m = np.reshape(gray, [<span class="number">1</span>, w*h])</span><br><span class="line">    mean = m.sum() / (w*h)  <span class="comment"># 求出整个灰度图像的平均值</span></span><br><span class="line">    print(<span class="string">"mean:"</span>, mean)</span><br><span class="line">    ret, binary = cv.threshold(gray, mean, <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">    cv.imshow(<span class="string">"threshold_custom"</span>, binary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    img = cv.imread(<span class="string">"02.jpg"</span>)</span><br><span class="line">    <span class="comment"># threshold_demo(img)</span></span><br><span class="line">    <span class="comment"># threshold_simple(img)</span></span><br><span class="line">    <span class="comment"># threshold_adaptive(img)</span></span><br><span class="line">    threshold_custom(img)</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)  <span class="comment"># 等有键输入或者1000ms后自动将窗口消除，0表示只用键输入结束窗口</span></span><br><span class="line">    cv.destroyAllWindows()  <span class="comment"># 关闭所有窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="2-结果如下："><a href="#2-结果如下：" class="headerlink" title="2. 结果如下："></a>2. 结果如下：</h2><ol><li><p>threshold_demo<br><a href="https://miao.su/image/HIRkk" target="_blank" rel="noopener"><img src="https://miao.su/images/2019/02/13/threshold_demo8ae7c.png" alt="threshold_demo8ae7c.png"></a></p></li><li><p>threshold_simple<br><a href="https://miao.su/image/HIF0n" target="_blank" rel="noopener"><img src="https://miao.su/images/2019/02/13/figure_1fe3c1.png" alt="figure_1fe3c1.png"></a></p></li><li><p>threshold_adaptive<br><a href="https://miao.su/image/HIBqL" target="_blank" rel="noopener"><img src="https://miao.su/images/2019/02/13/figure_293f46.png" alt="figure_293f46.png"></a></p></li><li><p>threshold_custom<br><a href="https://miao.su/image/HIGLf" target="_blank" rel="noopener"><img src="https://miao.su/images/2019/02/13/thr7be90.png" alt="thr7be90.png"></a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用openCV来实现图像二值化，主要利用的函数有 cv2.threshold，cv2.adaptiveThreshold 等，具体内容如下：&lt;br&gt;
    
    </summary>
    
      <category term="CV" scheme="http://looby.coding.me/betterming/categories/CV/"/>
    
    
      <category term="openCV" scheme="http://looby.coding.me/betterming/tags/openCV/"/>
    
      <category term="图像二值化" scheme="http://looby.coding.me/betterming/tags/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>hexo中文标题打不开博客</title>
    <link href="http://looby.coding.me/betterming/post/960616a.html"/>
    <id>http://looby.coding.me/betterming/post/960616a.html</id>
    <published>2019-02-06T13:37:00.000Z</published>
    <updated>2019-02-13T14:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>hexo 中文博客打不开问题</strong><br><a id="more"></a><br>&emsp;&emsp;Hexo默认的链接是<a href="http://betterming.github.io/2019/02/06/HelloWorld" target="_blank" rel="noopener">http://betterming.github.io/2019/02/06/HelloWorld</a> 类型的，在站点目录下的配置_config.yml里的配置:permalink: :year/:month/:day/:title/。这种配置的缺点就是一般文件名是中文，导致url链接里有中文出现，这会造成中文博客可能打不开，也不利于seo。这里提供一种解决方案。</p><p>step1:安装hexo-abbrlink这个插件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-abbrlink <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><p>step2:修改站点配置文件_config.yml<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">permalink:</span> post/:abbrlink.html</span><br><span class="line"><span class="meta"># abbrlink config</span></span><br><span class="line"><span class="symbol">abbrlink:</span></span><br><span class="line"><span class="symbol">  alg:</span> crc32  <span class="meta"># 算法：crc16(default) and crc32</span></span><br><span class="line"><span class="symbol">  rep:</span> hex    <span class="meta"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure></p><p><strong>参考链接</strong></p><ol><li><a href="https://blog.csdn.net/yanzi1225627/article/details/77761488" target="_blank" rel="noopener">https://blog.csdn.net/yanzi1225627/article/details/77761488</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;hexo 中文博客打不开问题&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://looby.coding.me/betterming/categories/Technique/"/>
    
    
      <category term="Hexo" scheme="http://looby.coding.me/betterming/tags/Hexo/"/>
    
      <category term="permalink" scheme="http://looby.coding.me/betterming/tags/permalink/"/>
    
  </entry>
  
  <entry>
    <title>海量数据处理</title>
    <link href="http://looby.coding.me/betterming/post/73dedef0.html"/>
    <id>http://looby.coding.me/betterming/post/73dedef0.html</id>
    <published>2019-02-06T10:42:00.000Z</published>
    <updated>2019-02-06T13:18:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-海量数据处理的案例类型"><a href="#1-海量数据处理的案例类型" class="headerlink" title="1. 海量数据处理的案例类型"></a>1. 海量数据处理的案例类型</h1><p><strong>查询</strong>：</p><ul><li>关于重复项的处理：（海量）数据的判重、取重、去重；</li><li>统计： （海量）数据的出现频度；<br><strong>排序</strong>：</li><li>（海量）数据的排序；</li><li>（海量）数据的前K个最大（小）数；<a id="more"></a><strong>解题策略中的关键问题</strong>:<blockquote><p>1、存储什么？如何存储一组数据；（选择数据结构）<br>2、如何解决问题？（选择算法）</p></blockquote></li></ul><h1 id="2-可以采用的数据结构"><a href="#2-可以采用的数据结构" class="headerlink" title="2. 可以采用的数据结构"></a>2. 可以采用的数据结构</h1><blockquote><p>线性结构：</p><ul><li>顺序表：一般的顺序表,字符串,BitMap</li><li>链表：</li></ul><p>树状结构：</p><ul><li>二叉树：BST、红黑树</li><li>B树</li><li>Trie树</li></ul><p>扩展的结构：hash表,B+树</p></blockquote><h1 id="3-可以采用的算法"><a href="#3-可以采用的算法" class="headerlink" title="3. 可以采用的算法"></a>3. 可以采用的算法</h1><h2 id="3-1-查找"><a href="#3-1-查找" class="headerlink" title="3.1 查找"></a>3.1 查找</h2><ul><li>应用场景：在某数据集合中查找指定的目标项.(隐含：待查找的目标项必须是已知的！)</li><li>基于Hash表的查找：</li><li>蛮力查找（顺序查找）：线性表</li><li>基于有序表的二分查找：有序的顺序表</li><li>字符串的查找：朴素查找、KMP算法、BM算</li><li>基于树的查找：遍历<ul><li>二叉查找树BST：中序遍历</li><li>Trie树：层次遍历</li><li>基于红黑树：STL SET,STL Map</li></ul></li></ul><h2 id="3-2-排序"><a href="#3-2-排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h2><ul><li>基于比较操作的排序算法：平均时间复杂度≥O(Nlog2N)<ul><li>交换排序：两两比较待排序记录的关键字，如果逆序就进行交换，直到所有记录都排好序为止。</li><li>冒泡排序</li><li>快速排序（分区交换排序）</li></ul></li><li>选择排序（Selection Sort）的基本思想是：不断从待排记录序列中选出关键字最小的记录放到已排序记录序列的后面，直到n个记录全部插入已排序记录序列中。<ul><li>简单选择排序</li><li>堆排序（树型选择排序）</li></ul></li><li>插入排序：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子表中的适当位置，直到全部记录插入完成为止。<ul><li>直接插入排序</li><li>折半插入排序</li><li>希尔排序</li></ul></li><li>应用场景：对于某顺序表，按照指定的KEY进行整体排序(隐含：待排序的集合已全部存储在内存中；且各条记录的KEY必须是已知的！)</li></ul><h1 id="4-案例"><a href="#4-案例" class="headerlink" title="4. 案例"></a>4. 案例</h1><h2 id="4-1-案例–统计"><a href="#4-1-案例–统计" class="headerlink" title="4.1 案例–统计"></a>4.1 案例–统计</h2><p><strong>案例</strong>：有一个1G大小的文件，该文件中每一行是一个单词，每个单词的大小不超过16个字节，内存限制大小是1M。统计各个单词的出现频率。<br><strong>分析</strong>：</p><blockquote><p>将1G文件划分为多个1M的文件；<br>每次只统计1M的文件中单词频度。</p></blockquote><p>(1) Q：如何统计1M的文件中单词频度？</p><ul><li>设计思路1：依次读入文件的每个单词，并查询在内存中是否存在与该单词匹配的项。若查询到匹配项，则意味着该单词重复出现了，因而只需更改该单词对应的计数值；否则，将该单词插入到内存对应的数据结构中。（基本操作为：查询和插入操作）</li><li>设计思路2：直接将文件中每个单词读入内存，然后对内存中的单词进行排序，最后进行词频统计。（基本操作为：排序、比较操作）</li></ul><p>(2) 假设单词文件大小F，假定每个单词的平均长度为le，那么单词数量为N=F/le。<br>现对单词频度进行统计，那么</p><ul><li>采用Trie树，结合设计思路1，平均性能为$O(N*le)$ ；</li><li>采用红黑树，结合设计思路1，平均性能为：$O(N*log2N)$；<ul><li>采用红黑树时，可直接利用STL中的map技术:STL map&lt;string,int&gt;</li></ul></li><li>采用hash表，结合设计思路1，平均性能为：O(N*每个槽上的线性表的平均长度)；<ul><li>采用hash表时，可直接利用STL中的hash_map技术:STL hash_map&lt;string,int&gt;</li></ul></li><li>采用线性结构，结合设计思路2。先排序，再相邻单词的相互比较来统计单词频度，平均性能为：$O(N*log_2N)+O(N)=O(N*log_2N)$。</li></ul><p>(3) 算法设计思路</p><blockquote><p><strong>思路1:双层桶划分+ trie树/hash表/红黑树</strong></p><ul><li>Step1：将1G的大文件划分为若干个小文件，每个小文件不超过1M；<br>利用Hash技术：读取文件F，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为F0,F1,…F4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的每个小文件Fi的大小都不超过1M。</li><li>Step2:对每个小文件Fi中的词的出现频率进行统计。<br>采用trie树/hash表。</li><li>Step3：合并各个小文件的统计结果。</li></ul></blockquote><blockquote><p><strong>思路2:采用云计算的架构，MapReduce )(分布式处理：比如 hadoop)</strong></p><ul><li>MAP ：将1G的大文件划分为若干个小文件，每个小文件不超过1M；<ul><li>利用Hash技术：读取文件，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为F0,F1,…F4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</li></ul></li><li>Reduce:对每个小文件Fi中的词的出现频率进行统计，最后合并各个小文件的统计结果。<ul><li>采用trie树/hash表/红黑树，对每个小文件中的词的出现频率进行统计。</li></ul></li></ul></blockquote><blockquote><p><strong>思路3:线性结构+直接排序法</strong></p><ul><li>内存不能超过1M，而单词文件的大小为1G。因此采用顺序表存储单词文件，并利用外排序的方法来进行排序。采用归并排序，时间复杂度O(Nlog2N)。</li><li>排完序之后，再对已经有序的多个文件进行遍历，统计每个单词出现的次数，再次写入文件中。</li><li><strong>总结</strong>：<br>理论上的时间复杂度分析：归并排序的时间复杂度是O(Nlog2N)，而遍历线性表进行单词频度统计的时间复杂度是O(N)，因此该算法的总体时间复杂度就是O(Nlog2N)。<br>但是，实际上，采用归并排序进行外排序，每个单词需要I/O不止一次，而I/O操作属于耗时操作，因此该算法的实际时间开销的数量级远不止O(Nlog2N)</li></ul></blockquote><h2 id="4-2-案例–排序"><a href="#4-2-案例–排序" class="headerlink" title="4.2 案例–排序"></a>4.2 案例–排序</h2><p><strong>案例1</strong>：100w个数中找最大的前100个数。（假设内存开销无限制）</p><p>(1) <strong>算法设计思路1：采用局部淘汰法</strong></p><ul><li>选取前100个元素，并按降序进行排序，记为序列L。<br>依此扫描剩余的元素，并与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。</li><li>时间复杂度$T(n)=O(100*log_2100) +O((100w-100)*100)$。</li></ul><p>(2) <strong>算法设计思路2：利用堆排序</strong></p><ul><li>利用100w个数的前100个数构造一个小根堆；<br>遍历其他的数，分别与堆的根元素进行对比：若大于根，则用该元素替换旧根，作为堆的新根，重新维护保持堆的性质；否则，不处理。</li><li>时间复杂度:<br>$T(n)= O(100*log_2100) + O((100w-100)*log_2100)= O(100w*log_2100)$。</li></ul><p><strong>案例2</strong>：寻找热门查询：<br>&emsp;&emsp;搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请你统计最热门的10个查询串，<strong>要求使用的内存不能超过1GB</strong>。 </p><blockquote><ol><li>请描述你解决这个问题的思路；</li><li>请给出主要的处理流程，算法，以及算法的复杂度。</li></ol></blockquote><p>(1) 问题分析：要统计最热门查询，首先就是要统计每个Query出现的次数，然后根据统计结果，找出Top 10。</p><ul><li>第一步：Query统计<br>设计思路1：顺序表+直接排序法<br>设计思路2：采用Hash表</li><li>第二步：找出Top 10</li></ul><p>(2) 设计思路</p><blockquote><p><strong>设计思路1：顺序表+直接排序法</strong></p></blockquote><ul><li>内存不能超过1G，而一千万条记录，每条记录是225Byte，很显然要占据2.55G内存。因此采用外排序的方法来进行排序（采用归并排序，时间复杂度O(Nlog2N)。</li><li>排完序之后我们再对已经有序的Query文件进行遍历，统计每个Query出现的次数，再次写入文件中。</li><li>总结：排序的时间复杂度是O(Nlog2N)，而遍历的时间复杂度是O(N)，因此该算法的总体时间复杂度就是O(Nlog2N)。</li></ul><blockquote><p><strong>设计思路2: 利用Hash Table</strong></p><ul><li>采用Hash Table。<ul><li>虽然有一千万个Query，但是由于重复度比较高，事实上只有300万的Query，而每个Query255Byte，因此我们可以考虑把他们都放进1GB内存中去。（3*106*255B&lt;1GB)</li><li>采用Hash Table绝对是我们优先的选择，因为Hash Table的查询速度非常的快，几乎是O(1)的时间复杂度。</li></ul></li><li>维护一个Key为Query字串，Value为该Query出现次数的Hash表，每次读取一个Query，如果该字串不在Hash表中，那么加入该字串，并且将Value值设为1；如果该字串在Hash表中，那么将该字串的计数加1即可。</li><li>T(n)=O(N*每个槽上的线性表的平均长度) 。</li><li>相比于设计思路1：在时间复杂度上提高了一个数量级，但不仅仅是时间复杂度上的优化，该方法只需要I/O数据文件一次，而设计思路1的I/O次数较多的，因此该算法比设计思路1在工程上有更好的可操作性。</li></ul></blockquote><ul><li>第二步：找出Top 10（按照Query的出现频度）<br><strong>设计思路1：内部排序</strong><br>时间复杂度$T(n)=nlog_2n$(三百万条记录可以放在1G内存中）<br><strong>设计思路2：采用局部淘汰法</strong><br>时间复杂度$T(n)=O(10*log_210) +O((n-10)*10)$。<br><strong>设计思路3：利用堆</strong><br>时间复杂度$T(n)= O(10*log_210) + O((n-10)*log_210)$。  </li></ul><h2 id="4-3-案例——关于重复项的处理"><a href="#4-3-案例——关于重复项的处理" class="headerlink" title="4.3. 案例——关于重复项的处理"></a>4.3. 案例——关于重复项的处理</h2><p><strong>案例1</strong>： A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4GB，要求找出A,B文件中共同的URL。<br>(1) 方案1：分而治之+基于hash表的查找</p><ul><li>可以估计每个文件的大小为5G×64=320GB，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。<ul><li>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</li><li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0 vs..b0,a1 vs. b1,…,a999 vs. b999）中，不对应的小文件不可能有相同的url。</li></ul></li><li>分别计算出1000对小文件中相同的url，再进行汇总。<ul><li>采用Hash表，可以直接利用STL Hash_set。</li><li>对于每1对小文件(ai,bi)，把小文件ai的url存储到hash表中，然后遍历另一个小文件bi中的每个url，查询其是否在刚才构建的hash表中，如果是，那么就是共同的url。</li></ul></li></ul><p>(2) 方案2：若允许有一定的错误率，可采用Bloom filter,Bloom filter是BitMap的扩展。</p><ul><li><p>若直接采用BitMap。那么：可用内存4GB=4*1024*1024*1024*8b≈340亿bit。由于每条URL占用64字节，即每个URL对应的整数可以用log2(25664)bit=864bit&gt;340亿bit来描述。因而不能用BitMap。</p><blockquote><p>Bloom filter：通过极少的错误换取了存储空间的极大节省。将每条url使用Bloom filter映射为这340亿bit中的k个bit，并将这k个bit置为1。</p></blockquote></li><li><p>将文件a中的每条url使用Bloom filter映射为这340亿bit；然后依次读取文件b中的每条url，检查其Bloom filter映射的k比特是否都为1，如果是，那么该url应该是两个文件共同的url（注意：会有一定的错误率）。</p></li></ul><p><strong>案例2</strong>：2.5亿个整数中找出不重复的整数，内存空间不足以容纳这2.5亿个整数。 </p><p>(1) 方案1：假设2.5亿个整数的取值范围为[0,250000000)。那么，采用Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需0.5G bits，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。扫描结束后，查看bitmap，把对应位是01的整数输出即可。</p><p>(2) 方案2：也可采用与第1题类似的方法，先将大文件划分为小文件。然后在小文件中找出不重复的整数，并排序。最后进行归并，注意去除重复的元素。</p><p><strong>本文内容来自余老师上课PPT</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-海量数据处理的案例类型&quot;&gt;&lt;a href=&quot;#1-海量数据处理的案例类型&quot; class=&quot;headerlink&quot; title=&quot;1. 海量数据处理的案例类型&quot;&gt;&lt;/a&gt;1. 海量数据处理的案例类型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;查询&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于重复项的处理：（海量）数据的判重、取重、去重；&lt;/li&gt;
&lt;li&gt;统计： （海量）数据的出现频度；&lt;br&gt;&lt;strong&gt;排序&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;（海量）数据的排序；&lt;/li&gt;
&lt;li&gt;（海量）数据的前K个最大（小）数；
    
    </summary>
    
      <category term="Algorithm" scheme="http://looby.coding.me/betterming/categories/Algorithm/"/>
    
    
      <category term="Hash" scheme="http://looby.coding.me/betterming/tags/Hash/"/>
    
      <category term="BitMap" scheme="http://looby.coding.me/betterming/tags/BitMap/"/>
    
      <category term="Trie树" scheme="http://looby.coding.me/betterming/tags/Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://looby.coding.me/betterming/post/c2a5fdc5.html"/>
    <id>http://looby.coding.me/betterming/post/c2a5fdc5.html</id>
    <published>2019-01-10T03:08:00.000Z</published>
    <updated>2019-05-19T13:13:52.856Z</updated>
    
    <content type="html"><![CDATA[<p><strong>堆排序过程及代码实现</strong><br><a id="more"></a></p><h2 id="1-堆排序概念"><a href="#1-堆排序概念" class="headerlink" title="1. 堆排序概念"></a>1. 堆排序概念</h2><p>堆是具有如下性质的二叉树：</p><blockquote><p>1）任何节点的值都≤（≥）其子节点的值，即 堆的根节点中存放最小（大）元素；<br>2）最多在两层上具有叶子节点，其中最底层的叶子节点尽可能的靠左分布。隐含：含有n 个节点的堆，所有节点到根节点的距离都不超 过log2n。（类似 完全二叉树）</p><ul><li>堆可以用数组来按序号存储，即从上到下，从左到右存储，按照层序遍历存储</li></ul></blockquote><p>堆排序概念：</p><blockquote><ul><li>树型选择排序</li><li>特点：T(n)=O(nlog2n)，实际运行时间比快速排序慢些; 是一种良好的通用排序算法，不存在最坏情况。（希尔排序也是一种良好的通用排序算法，T(n)=O(n1.25) ）</li><li>数据结构：堆——实质上是一棵二叉树；<br><strong>基本操作</strong>：siftup：当在堆的尾部插入新元素后，需重新获取堆性质。siftdown：用新元素替换堆中的旧根后，需重新获取堆性质。</li></ul></blockquote><h1 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h1><p>也是余老师布置的作业。请采用堆排序将关键字序列{3,2,1,4,5,6,7,10,9,8}排序，并写出各步的具体操作，并记录总的比较次数和总的交换次数。要求利用siftup函数创建初始大根堆，利用siftdown1函数依次提取根结点生成有序序列。<br>答：(1) 具体操作如下：</p><p><a href="https://miao.su/image/H1UXo" target="_blank" rel="noopener"><img src="https://miao.su/images/2019/02/04/markdown-img-paste-201901101131369957011a.png" alt="markdown-img-paste-201901101131369957011a.png"></a></p><p>(2)代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">11</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> up1=<span class="number">0</span>, up2=<span class="number">0</span>, down1=<span class="number">0</span>, down2=<span class="number">0</span>;<span class="comment">// 记录siftup比较、交换次数和siftdown比较交换次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftup</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, p;</span><br><span class="line">i = u;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">p = i/<span class="number">2</span>;</span><br><span class="line">up1++;</span><br><span class="line"><span class="keyword">if</span>(x[p] &gt;= x[i]) <span class="keyword">break</span>;</span><br><span class="line">swap(x[p], x[i]);</span><br><span class="line">up2++;</span><br><span class="line">i = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftdown1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, c;</span><br><span class="line">i = l;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">c = <span class="number">2</span>*i;</span><br><span class="line"><span class="keyword">if</span>(c &gt; u) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c + <span class="number">1</span> &lt;= u)&#123;</span><br><span class="line">down1++;</span><br><span class="line"><span class="keyword">if</span>(x[c+<span class="number">1</span>] &gt; x[c]) c++;</span><br><span class="line">&#125;</span><br><span class="line">down1++;</span><br><span class="line"><span class="keyword">if</span>(x[i] &gt; x[c]) <span class="keyword">break</span>;</span><br><span class="line">swap(x[i], x[c]);</span><br><span class="line">down2++;</span><br><span class="line">i = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">10</span>; j++) siftup(j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"siftup后序列为：\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, x[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"siftup比较次数：%d\nsiftup交换次数：%d\n"</span>, up1, up2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">swap(x[<span class="number">1</span>], x[i]);</span><br><span class="line">siftdown1(<span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"堆排序后序列：\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, x[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"siftdown比较次数：%d\nsiftdown交换次数：%d\n"</span>, down1, down2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3) 结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">siftup后序列为：</span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line">siftup比较次数：<span class="number">18</span></span><br><span class="line">siftup交换次数：<span class="number">14</span></span><br><span class="line">堆排序后序列：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">siftdown比较次数：<span class="number">24</span></span><br><span class="line">siftdown交换次数：<span class="number">11</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;堆排序过程及代码实现&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://looby.coding.me/betterming/categories/Algorithm/"/>
    
    
      <category term="堆排序" scheme="http://looby.coding.me/betterming/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>AVL</title>
    <link href="http://looby.coding.me/betterming/post/1d92c98c.html"/>
    <id>http://looby.coding.me/betterming/post/1d92c98c.html</id>
    <published>2019-01-04T13:47:00.000Z</published>
    <updated>2019-02-06T14:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>AVL树c++实现<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> // <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, height; <span class="comment">// 当前节点子树的高度，本身为1</span></span><br><span class="line">node *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个新节点，节点值为v</span></span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">node* Node = <span class="keyword">new</span> node;</span><br><span class="line">Node-&gt;height = <span class="number">1</span>;</span><br><span class="line">Node-&gt;v = v;</span><br><span class="line">Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得树的高度，即根节点所在子树高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点root的高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AVL的基本操作：查找，插入，删除</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Search Failed!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root-&gt;v == x) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;v &gt; x) search(root-&gt;lchild, x);</span><br><span class="line"><span class="keyword">else</span> search(root-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="comment">//R型，要左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftRotation</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">node* temp = root-&gt;rchild;</span><br><span class="line">root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">temp-&gt;lchild = root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(temp);</span><br><span class="line">root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//L型，要右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightRotation</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">node* temp = root-&gt;lchild;</span><br><span class="line">root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">temp-&gt;rchild = root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(temp);</span><br><span class="line">root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">四种树形的调整：</span></span><br><span class="line"><span class="comment">1. LL型 BF(root)=2, BF(root-&gt;lchild)=1 对root右旋</span></span><br><span class="line"><span class="comment">2. RR型 BF(root)=-2, BF(root-&gt;rchild)=-1 对root左旋</span></span><br><span class="line"><span class="comment">3. LR型 BF(root)=2, BF(root-&gt;rchild)=-1 先对root-&gt;lchild左旋，再root右旋</span></span><br><span class="line"><span class="comment">4. RL型 BF(root)=-2, BF(root-&gt;rchild)=1 先对root-&gt;rchild右旋，再root左旋</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AVL树插入权值为v节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = newNode(v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v &lt; root-&gt;v)&#123;</span><br><span class="line">insert(root-&gt;lchild, v);</span><br><span class="line">updateHeight(root);</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">1</span>) RightRotation(root);<span class="comment">//LL型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">-1</span>) &#123; <span class="comment">// LR型</span></span><br><span class="line">LeftRotation(root-&gt;lchild);</span><br><span class="line">RightRotation(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">insert(root-&gt;rchild, v);</span><br><span class="line">updateHeight(root);</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">-2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">-1</span>) LeftRotation(root); <span class="comment">//RR型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">1</span>) &#123;<span class="comment">//RL型</span></span><br><span class="line">RightRotation(root-&gt;rchild);</span><br><span class="line">LeftRotation(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建AVL树</span></span><br><span class="line"><span class="function">node* <span class="title">Creat</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">node* root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">insert(root, data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeTraver</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">treeTraver(root-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"height:%d, data:%d\n"</span>, root-&gt;height, root-&gt;v);</span><br><span class="line">treeTraver(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">33</span>&#125;;</span><br><span class="line">node* root = Creat(data, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">treeTraver(root);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL树c++实现&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://looby.coding.me/betterming/categories/Algorithm/"/>
    
    
      <category term="Traversal" scheme="http://looby.coding.me/betterming/tags/Traversal/"/>
    
      <category term="Order" scheme="http://looby.coding.me/betterming/tags/Order/"/>
    
      <category term="AVL" scheme="http://looby.coding.me/betterming/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>实验3_图像特征匹配、跟踪与相机运动估计实验</title>
    <link href="http://looby.coding.me/betterming/post/a008a0d9.html"/>
    <id>http://looby.coding.me/betterming/post/a008a0d9.html</id>
    <published>2018-12-28T06:40:00.000Z</published>
    <updated>2019-02-06T14:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、预备知识："><a href="#一、预备知识：" class="headerlink" title="一、预备知识："></a>一、预备知识：</h2><blockquote><p>深度图像程序模型及坐标转换<br>linux，C++编程基础，Cmake 编译器<br>OpenCV 图像处理库<br><a id="more"></a></p></blockquote><h2 id="二、实验步骤："><a href="#二、实验步骤：" class="headerlink" title="二、实验步骤："></a>二、实验步骤：</h2><h3 id="1-环境准备-图优化算法库g2o的安装"><a href="#1-环境准备-图优化算法库g2o的安装" class="headerlink" title="1. 环境准备,图优化算法库g2o的安装"></a>1. 环境准备,图优化算法库g2o的安装</h3><p>g2o 安装依赖如下：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install libeigen3-<span class="built_in">dev</span> libsuitesparse-<span class="built_in">dev</span> libqt4-<span class="built_in">dev</span> qt4-qmake libqglviewer-qt4-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install cmake libeigen3-<span class="built_in">dev</span> libsuitesparse-<span class="built_in">dev</span> libqt4-<span class="built_in">dev</span> qt4-qmake libqglviewer-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p><p>下载 g2o 源码：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/RainerKuemmerle/g2o.git</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="keyword">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line"><span class="keyword">make</span></span><br><span class="line">sudo <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure></p><p>在实验前需要安装好Eigen3,OpenCV等依赖库<br>Eigen3安装步骤如下：<br>官网下载 tar 包： <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" target="_blank" rel="noopener">http://eigen.tuxfamily.org/index.php?title=Main_Page</a><br>执行如下命令：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvjf <span class="meta-keyword">/home/</span>ljhong<span class="meta-keyword">/share/</span> eigen-eigen<span class="number">-26667</span>be4f70b.tar.bz2  -C <span class="meta-keyword">/usr/</span>local/include</span><br><span class="line">sudo mv <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/include/</span>eigen-eigen<span class="number">-26667</span>be4f70b <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/include/</span>eigen3</span><br></pre></td></tr></table></figure></p><p>安装好之后，在/usr/local/include 目录下有个 eigen3的文件</p><h3 id="2-实验代码下载有重新编译"><a href="#2-实验代码下载有重新编译" class="headerlink" title="2. 实验代码下载有重新编译"></a>2. 实验代码下载有重新编译</h3><p>(1)下载实验附件代码<br><a href="https://github.com/gaoxiang12/slambook/tree/master/ch7" target="_blank" rel="noopener">https://github.com/gaoxiang12/slambook/tree/master/ch7</a><br>(2)编译（如果eigen3是按照上面源码方式安装的，ch7文件夹里编译规则文件<br>CMakeList.txt中的”usr/include/eigen3/”应改成每个同学自己的实际存放路径，比如”<br>usr/local/include/eigen3/”）：<br>进入文件cmake和make</p><h3 id="3-双目图像的位姿变换体验"><a href="#3-双目图像的位姿变换体验" class="headerlink" title="3.  双目图像的位姿变换体验"></a>3.  双目图像的位姿变换体验</h3><p>用自备手机，选取非单一背景颜色的环境进行拍照，具体方法为 双手持稳相机，拍第 一张照片，然后小幅度旋转相机，拍摄第二张照片， 重复上述 1-2 步，实现两张图片的特 征点检测与匹配。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: feature_extraction img1 img2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = imread ( argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line">    Mat img_2 = imread ( argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::create();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::create();</span><br><span class="line">    <span class="comment">// Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create(detector_name);</span></span><br><span class="line">    <span class="comment">// Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create(descriptor_name);</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher  = DescriptorMatcher::create ( <span class="string">"BruteForce-Hamming"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;detect ( img_1,keypoints_1 );</span><br><span class="line">    detector-&gt;detect ( img_2,keypoints_2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;compute ( img_1, keypoints_1, descriptors_1 );</span><br><span class="line">    descriptor-&gt;compute ( img_2, keypoints_2, descriptors_2 );</span><br><span class="line"></span><br><span class="line">    Mat outimg1;</span><br><span class="line">    drawKeypoints( img_1, keypoints_1, outimg1, Scalar::all(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT );</span><br><span class="line">    imshow(<span class="string">"ORB特征点"</span>,outimg1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">    <span class="comment">//BFMatcher matcher ( NORM_HAMMING );</span></span><br><span class="line">    matcher-&gt;match ( descriptors_1, descriptors_2, matches );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist=<span class="number">10000</span>, max_dist=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = matches[i].distance;</span><br><span class="line">        <span class="keyword">if</span> ( dist &lt; min_dist ) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> ( dist &gt; max_dist ) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅供娱乐的写法</span></span><br><span class="line">    min_dist = min_element( matches.begin(), matches.end(), [](<span class="keyword">const</span> DMatch&amp; m1, <span class="keyword">const</span> DMatch&amp; m2) &#123;<span class="keyword">return</span> m1.distance&lt;m2.distance;&#125; )-&gt;distance;</span><br><span class="line">    max_dist = max_element( matches.begin(), matches.end(), [](<span class="keyword">const</span> DMatch&amp; m1, <span class="keyword">const</span> DMatch&amp; m2) &#123;<span class="keyword">return</span> m1.distance&lt;m2.distance;&#125; )-&gt;distance;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"-- Max dist : %f \n"</span>, max_dist );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"-- Min dist : %f \n"</span>, min_dist );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt; good_matches;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( matches[i].distance &lt;= max ( <span class="number">2</span>*min_dist, <span class="number">30.0</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            good_matches.push_back ( matches[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第五步:绘制匹配结果</span></span><br><span class="line">    Mat img_match;</span><br><span class="line">    Mat img_goodmatch;</span><br><span class="line">    drawMatches ( img_1, keypoints_1, img_2, keypoints_2, matches, img_match );</span><br><span class="line">    drawMatches ( img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch );</span><br><span class="line">    imshow ( <span class="string">"所有匹配点对"</span>, img_match );</span><br><span class="line">    imshow ( <span class="string">"优化后匹配点对"</span>, img_goodmatch );</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-ICP-法相机姿态估计"><a href="#4-ICP-法相机姿态估计" class="headerlink" title="4. ICP 法相机姿态估计"></a>4. ICP 法相机姿态估计</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d/calib3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/SVD&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/eigen/linear_solver_eigen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/sba/types_six_dof_expmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; img_1, <span class="keyword">const</span> Mat&amp; img_2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像素坐标转相机归一化坐标</span></span><br><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_3d3d</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; pts1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; pts2,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; R, Mat&amp; t</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; points_3d,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; points_2d,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; R, Mat&amp; t</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g2o edge</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeProjectXYZRGBDPoseOnly</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">3</span>, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    EdgeProjectXYZRGBDPoseOnly( <span class="keyword">const</span> Eigen::Vector3d&amp; point ) : _point(point) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> g2o::VertexSE3Expmap* pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap*&gt; ( _vertices[<span class="number">0</span>] );</span><br><span class="line">        <span class="comment">// measurement is p, point is p'</span></span><br><span class="line">        _error = _measurement - pose-&gt;estimate().<span class="built_in">map</span>( _point );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g2o::VertexSE3Expmap* pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        g2o::<span class="function">SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;</span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point);</span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span> <span class="params">( istream&amp; in )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span> <span class="params">( ostream&amp; out )</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">5</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: pose_estimation_3d3d img1 img2 depth1 depth2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = imread ( argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line">    Mat img_2 = imread ( argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">    find_feature_matches ( img_1, img_2, keypoints_1, keypoints_2, matches );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"一共找到了"</span>&lt;&lt;matches.size() &lt;&lt;<span class="string">"组匹配点"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立3D点</span></span><br><span class="line">    Mat depth1 = imread ( argv[<span class="number">3</span>], CV_LOAD_IMAGE_UNCHANGED );       <span class="comment">// 深度图为16位无符号数，单通道图像</span></span><br><span class="line">    Mat depth2 = imread ( argv[<span class="number">4</span>], CV_LOAD_IMAGE_UNCHANGED );       <span class="comment">// 深度图为16位无符号数，单通道图像</span></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point3f&gt; pts1, pts2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( DMatch m:matches )</span><br><span class="line">    &#123;</span><br><span class="line">        ushort d1 = depth1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; ( <span class="keyword">int</span> ( keypoints_1[m.queryIdx].pt.y ) ) [ <span class="keyword">int</span> ( keypoints_1[m.queryIdx].pt.x ) ];</span><br><span class="line">        ushort d2 = depth2.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; ( <span class="keyword">int</span> ( keypoints_2[m.trainIdx].pt.y ) ) [ <span class="keyword">int</span> ( keypoints_2[m.trainIdx].pt.x ) ];</span><br><span class="line">        <span class="keyword">if</span> ( d1==<span class="number">0</span> || d2==<span class="number">0</span> )   <span class="comment">// bad depth</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Point2d p1 = pixel2cam ( keypoints_1[m.queryIdx].pt, K );</span><br><span class="line">        Point2d p2 = pixel2cam ( keypoints_2[m.trainIdx].pt, K );</span><br><span class="line">        <span class="keyword">float</span> dd1 = <span class="keyword">float</span> ( d1 ) /<span class="number">5000.0</span>;</span><br><span class="line">        <span class="keyword">float</span> dd2 = <span class="keyword">float</span> ( d2 ) /<span class="number">5000.0</span>;</span><br><span class="line">        pts1.push_back ( Point3f ( p1.x*dd1, p1.y*dd1, dd1 ) );</span><br><span class="line">        pts2.push_back ( Point3f ( p2.x*dd2, p2.y*dd2, dd2 ) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"3d-3d pairs: "</span>&lt;&lt;pts1.size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Mat R, t;</span><br><span class="line">    pose_estimation_3d3d ( pts1, pts2, R, t );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"ICP via SVD results: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"R = "</span>&lt;&lt;R&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"t = "</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"R_inv = "</span>&lt;&lt;R.t() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"t_inv = "</span>&lt;&lt;-R.t() *t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"calling bundle adjustment"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    bundleAdjustment( pts1, pts2, R, t );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify p1 = R*p2 + t</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1 = "</span>&lt;&lt;pts1[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"p2 = "</span>&lt;&lt;pts2[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"(R*p2+t) = "</span>&lt;&lt;</span><br><span class="line">            R * (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">1</span>)&lt;&lt;pts2[i].x, pts2[i].y, pts2[i].z) + t</span><br><span class="line">            &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span> <span class="params">( <span class="keyword">const</span> Mat&amp; img_1, <span class="keyword">const</span> Mat&amp; img_2,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_1,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_2,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    <span class="comment">// used in OpenCV3</span></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::create();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::create();</span><br><span class="line">    <span class="comment">// use this if you are in OpenCV2</span></span><br><span class="line">    <span class="comment">// Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create ( "ORB" );</span></span><br><span class="line">    <span class="comment">// Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create ( "ORB" );</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher  = DescriptorMatcher::create(<span class="string">"BruteForce-Hamming"</span>);</span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;detect ( img_1,keypoints_1 );</span><br><span class="line">    detector-&gt;detect ( img_2,keypoints_2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;compute ( img_1, keypoints_1, descriptors_1 );</span><br><span class="line">    descriptor-&gt;compute ( img_2, keypoints_2, descriptors_2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;DMatch&gt; match;</span><br><span class="line">   <span class="comment">// BFMatcher matcher ( NORM_HAMMING );</span></span><br><span class="line">    matcher-&gt;match ( descriptors_1, descriptors_2, match );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist=<span class="number">10000</span>, max_dist=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> ( dist &lt; min_dist ) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> ( dist &gt; max_dist ) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"-- Max dist : %f \n"</span>, max_dist );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"-- Min dist : %f \n"</span>, min_dist );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( match[i].distance &lt;= max ( <span class="number">2</span>*min_dist, <span class="number">30.0</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            matches.push_back ( match[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Point2d</span><br><span class="line">           (</span><br><span class="line">               ( p.x - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),</span><br><span class="line">               ( p.y - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> )</span><br><span class="line">           );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_3d3d</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; pts1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; pts2,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; R, Mat&amp; t</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3f p1, p2;     <span class="comment">// center of mass</span></span><br><span class="line">    <span class="keyword">int</span> N = pts1.size();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p1 += pts1[i];</span><br><span class="line">        p2 += pts2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    p1 = Point3f( Vec3f(p1) /  N);</span><br><span class="line">    p2 = Point3f( Vec3f(p2) / N);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point3f&gt;     q1 ( N ), q2 ( N ); <span class="comment">// remove the center</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q1[i] = pts1[i] - p1;</span><br><span class="line">        q2[i] = pts2[i] - p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute q1*q2^T</span></span><br><span class="line">    Eigen::Matrix3d W = Eigen::Matrix3d::Zero();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        W += Eigen::Vector3d ( q1[i].x, q1[i].y, q1[i].z ) * Eigen::Vector3d ( q2[i].x, q2[i].y, q2[i].z ).transpose();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"W="</span>&lt;&lt;W&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SVD on W</span></span><br><span class="line">    Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; svd ( W, Eigen::ComputeFullU|Eigen::ComputeFullV );</span><br><span class="line">    Eigen::Matrix3d U = svd.matrixU();</span><br><span class="line">    Eigen::Matrix3d V = svd.matrixV();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (U.determinant() * V.determinant() &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            U(x, <span class="number">2</span>) *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"U="</span>&lt;&lt;U&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"V="</span>&lt;&lt;V&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3d R_ = U* ( V.transpose() );</span><br><span class="line">    Eigen::Vector3d t_ = Eigen::Vector3d ( p1.x, p1.y, p1.z ) - R_ * Eigen::Vector3d ( p2.x, p2.y, p2.z );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert to cv::Mat</span></span><br><span class="line">    R = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt;</span><br><span class="line">          R_ ( <span class="number">0</span>,<span class="number">0</span> ), R_ ( <span class="number">0</span>,<span class="number">1</span> ), R_ ( <span class="number">0</span>,<span class="number">2</span> ),</span><br><span class="line">          R_ ( <span class="number">1</span>,<span class="number">0</span> ), R_ ( <span class="number">1</span>,<span class="number">1</span> ), R_ ( <span class="number">1</span>,<span class="number">2</span> ),</span><br><span class="line">          R_ ( <span class="number">2</span>,<span class="number">0</span> ), R_ ( <span class="number">2</span>,<span class="number">1</span> ), R_ ( <span class="number">2</span>,<span class="number">2</span> )</span><br><span class="line">        );</span><br><span class="line">    t = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">1</span> ) &lt;&lt; t_ ( <span class="number">0</span>,<span class="number">0</span> ), t_ ( <span class="number">1</span>,<span class="number">0</span> ), t_ ( <span class="number">2</span>,<span class="number">0</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Point3f &gt;&amp; pts1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Point3f &gt;&amp; pts2,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; R, Mat&amp; t )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt; g2o::BlockSolverTraits&lt;<span class="number">6</span>,<span class="number">3</span>&gt; &gt; Block;  <span class="comment">// pose维度为 6, landmark 维度为 3</span></span><br><span class="line">    Block::LinearSolverType* linearSolver = <span class="keyword">new</span> g2o::LinearSolverEigen&lt;Block::PoseMatrixType&gt;(); <span class="comment">// 线性方程求解器</span></span><br><span class="line">    Block* solver_ptr = <span class="keyword">new</span> Block( linearSolver );      <span class="comment">// 矩阵块求解器</span></span><br><span class="line">    g2o::OptimizationAlgorithmGaussNewton* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmGaussNewton( solver_ptr );</span><br><span class="line">    g2o::SparseOptimizer optimizer;</span><br><span class="line">    optimizer.setAlgorithm( solver );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vertex</span></span><br><span class="line">    g2o::VertexSE3Expmap* pose = <span class="keyword">new</span> g2o::VertexSE3Expmap(); <span class="comment">// camera pose</span></span><br><span class="line">    pose-&gt;setId(<span class="number">0</span>);</span><br><span class="line">    pose-&gt;setEstimate( g2o::SE3Quat(</span><br><span class="line">        Eigen::Matrix3d::Identity(),</span><br><span class="line">        Eigen::Vector3d( <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )</span><br><span class="line">    ) );</span><br><span class="line">    optimizer.addVertex( pose );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// edges</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;EdgeProjectXYZRGBDPoseOnly*&gt; edges;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pts1.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeProjectXYZRGBDPoseOnly* edge = <span class="keyword">new</span> EdgeProjectXYZRGBDPoseOnly(</span><br><span class="line">            Eigen::Vector3d(pts2[i].x, pts2[i].y, pts2[i].z) );</span><br><span class="line">        edge-&gt;setId( index );</span><br><span class="line">        edge-&gt;setVertex( <span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSE3Expmap*&gt; (pose) );</span><br><span class="line">        edge-&gt;setMeasurement( Eigen::Vector3d(</span><br><span class="line">            pts1[i].x, pts1[i].y, pts1[i].z) );</span><br><span class="line">        edge-&gt;setInformation( Eigen::Matrix3d::Identity()*<span class="number">1e4</span> );</span><br><span class="line">        optimizer.addEdge(edge);</span><br><span class="line">        index++;</span><br><span class="line">        edges.push_back(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">    optimizer.setVerbose( <span class="literal">true</span> );</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize(<span class="number">10</span>);</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2-t1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"optimization costs time: "</span>&lt;&lt;time_used.count()&lt;&lt;<span class="string">" seconds."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"after optimization:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"T="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;Eigen::Isometry3d( pose-&gt;estimate() ).matrix()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5．光流特征跟踪"><a href="#5．光流特征跟踪" class="headerlink" title="5．光流特征跟踪"></a>5．光流特征跟踪</h3><p>CMakeList文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">( VERSION <span class="number">2.8</span> )</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">( useLK )</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">( CMAKE_BUILD_TYPE Release )</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">( CMAKE_CXX_FLAGS <span class="string">"-std=c++11 -O3"</span> )</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">( OpenCV )</span></span></span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">( $&#123;OpenCV_INCLUDE_DIRS&#125; )</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">( useLK useLK.cpp )</span></span></span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">( useLK $&#123;OpenCV_LIBS&#125; )</span></span></span><br></pre></td></tr></table></figure></p><p>useLK.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/video/tracking.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: useLK path_to_dataset"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> path_to_dataset = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">string</span> associate_file = path_to_dataset + <span class="string">"/associate.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">( associate_file )</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( !fin )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"I cann't find associate.txt!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    <span class="built_in">list</span>&lt; cv::Point2f &gt; keypoints;      <span class="comment">// 因为要删除跟踪失败的点，使用list</span></span><br><span class="line">    cv::Mat color, depth, last_color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> index=<span class="number">0</span>; index&lt;<span class="number">100</span>; index++ )</span><br><span class="line">    &#123;</span><br><span class="line">        fin&gt;&gt;time_rgb&gt;&gt;rgb_file&gt;&gt;time_depth&gt;&gt;depth_file;</span><br><span class="line">        color = cv::imread( path_to_dataset+<span class="string">"/"</span>+rgb_file );</span><br><span class="line">        depth = cv::imread( path_to_dataset+<span class="string">"/"</span>+depth_file, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> (index ==<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对第一帧提取FAST特征点</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;cv::KeyPoint&gt; kps;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::create();</span><br><span class="line">            detector-&gt;detect( color, kps );</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">auto</span> kp:kps )</span><br><span class="line">                keypoints.push_back( kp.pt );</span><br><span class="line">            last_color = color;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( color.data==<span class="literal">nullptr</span> || depth.data==<span class="literal">nullptr</span> )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 对其他帧用LK跟踪特征点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; next_keypoints;</span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; prev_keypoints;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> kp:keypoints )</span><br><span class="line">            prev_keypoints.push_back(kp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; status;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; error;</span><br><span class="line">        chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">        cv::calcOpticalFlowPyrLK( last_color, color, prev_keypoints, next_keypoints, status, error );</span><br><span class="line">        chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">        chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;( t2-t1 );</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"LK Flow use time："</span>&lt;&lt;time_used.count()&lt;&lt;<span class="string">" seconds."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 把跟丢的点删掉</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter=keypoints.begin(); iter!=keypoints.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( status[i] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                iter = keypoints.erase(iter);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *iter = next_keypoints[i];</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"tracked keypoints: "</span>&lt;&lt;keypoints.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (keypoints.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"all keypoints are lost."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 画出 keypoints</span></span><br><span class="line">        cv::Mat img_show = color.clone();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> kp:keypoints )</span><br><span class="line">            cv::circle(img_show, kp, <span class="number">10</span>, cv::Scalar(<span class="number">0</span>, <span class="number">240</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        cv::imshow(<span class="string">"corners"</span>, img_show);</span><br><span class="line">        cv::waitKey(<span class="number">0</span>);</span><br><span class="line">        last_color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：</p><ol><li>刚哥的实验讲义</li><li>SLAM十四讲</li><li><a href="https://github.com/gaoxiang12/slambook" target="_blank" rel="noopener">https://github.com/gaoxiang12/slambook</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、预备知识：&quot;&gt;&lt;a href=&quot;#一、预备知识：&quot; class=&quot;headerlink&quot; title=&quot;一、预备知识：&quot;&gt;&lt;/a&gt;一、预备知识：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;深度图像程序模型及坐标转换&lt;br&gt;linux，C++编程基础，Cmake 编译器&lt;br&gt;OpenCV 图像处理库&lt;br&gt;
    
    </summary>
    
      <category term="CV" scheme="http://looby.coding.me/betterming/categories/CV/"/>
    
    
      <category term="CV" scheme="http://looby.coding.me/betterming/tags/CV/"/>
    
      <category term="OpenCV" scheme="http://looby.coding.me/betterming/tags/OpenCV/"/>
    
      <category term="Linux" scheme="http://looby.coding.me/betterming/tags/Linux/"/>
    
      <category term="SLAM" scheme="http://looby.coding.me/betterming/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra 和 Ben-Ford算法</title>
    <link href="http://looby.coding.me/betterming/post/bd15b34d.html"/>
    <id>http://looby.coding.me/betterming/post/bd15b34d.html</id>
    <published>2018-12-14T15:36:00.000Z</published>
    <updated>2019-02-06T14:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Dijkstra算法"><a href="#1-Dijkstra算法" class="headerlink" title="1. Dijkstra算法"></a>1. Dijkstra算法</h1><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>; <span class="comment">//最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">10000000</span>; <span class="comment">//inf 表示最大的数即为不可达</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, G[maxv][maxv]; <span class="comment">// n为顶点数，m为边数，G表示两顶点之间的权值</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 记录起点到各个顶点之间的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//数组标记，true表示已访问，初始为false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">fill(d, d + maxv, inf); <span class="comment">// 将整个d数据初始化为inf</span></span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">-1</span>, min = inf; <span class="comment">// min存放d[u]的最小值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123; <span class="comment">// 找到未访问的顶点中d最小</span></span><br><span class="line"><span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; min)&#123;</span><br><span class="line">u = j;</span><br><span class="line">min = d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">// 找不到小于inf的d[u]，说明剩下的顶点和起点不相通</span></span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;  <span class="comment">//若v未访问，u能到达v,u为中间点d[v]更优，则跟新d</span></span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf &amp;&amp; d[u] + G[u][v] &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line">fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxv * maxv, inf);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">G[u][v] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Dijkstra:\n"</span>);</span><br><span class="line">Dijkstra(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, d[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Ben-Ford算法"><a href="#2-Ben-Ford算法" class="headerlink" title="2. Ben-Ford算法"></a>2. Ben-Ford算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>; <span class="comment">//最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">10000000</span>; <span class="comment">//inf 表示最大的数即为不可达</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, dis;  <span class="comment">//v 为邻接边的目标顶点，dis为其权值</span></span><br><span class="line">Node(<span class="keyword">int</span> _v, <span class="keyword">int</span> _dis): v(_v), dis(_dis) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> n, m, s, d[maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="comment">//s为起点</span></span><br><span class="line">fill(d, d + maxv, inf);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123; <span class="comment">// 求解数d，执行n-1轮操作，每轮操作遍历整个边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++u)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Adj[u].size(); ++j)&#123;</span><br><span class="line"><span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v]) d[v] = d[u] + dis; <span class="comment">// 以u为中介使d[v]更小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++u)&#123; <span class="comment">// 判断是否有负环，对每条边都判断，返回false说明有负环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Adj[u].size(); ++j)&#123;</span><br><span class="line"><span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line"><span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">Adj[u].push_back(Node(v, w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Bellman_Ford:\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(Bellman_Ford(s) == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, d[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"有负环\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Dijkstra算法&quot;&gt;&lt;a href=&quot;#1-Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;1. Dijkstra算法&quot;&gt;&lt;/a&gt;1. Dijkstra算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://looby.coding.me/betterming/categories/Algorithm/"/>
    
    
      <category term="Dijkstra算法" scheme="http://looby.coding.me/betterming/tags/Dijkstra%E7%AE%97%E6%B3%95/"/>
    
      <category term="Ben-Ford算法" scheme="http://looby.coding.me/betterming/tags/Ben-Ford%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>视觉3D点云图构建与深度测量 </title>
    <link href="http://looby.coding.me/betterming/post/8957bd28.html"/>
    <id>http://looby.coding.me/betterming/post/8957bd28.html</id>
    <published>2018-12-12T13:03:00.000Z</published>
    <updated>2019-02-06T14:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验-2-视觉-3D-点云图构建与深度测量"><a href="#实验-2-视觉-3D-点云图构建与深度测量" class="headerlink" title="实验 2 视觉 3D 点云图构建与深度测量"></a>实验 2 视觉 3D 点云图构建与深度测量</h1><a id="more"></a><h2 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h2><ol><li>矩阵运算库 Eigen 的使用</li><li>彩色图、深度图的读取与参数提取</li><li>相机参数加载与使用</li><li>点云地图拼接</li><li>双目视觉系统标定与深度测量(限实验设计)</li></ol><h2 id="实验设备："><a href="#实验设备：" class="headerlink" title="实验设备："></a>实验设备：</h2><blockquote><p>自带笔记本 PC 机摄像头/USB 摄像头，安装 Ubuntu14.04 或以上系统，OpenCV 开发库</p></blockquote><h2 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h2><blockquote><ol><li>深度相机原理</li><li>深度图像采集过程及坐标转换关系</li><li>linux，C++编程基础，Cmake 编译器使用</li><li>Eigen 矩阵运算库，OpenCV 图像处理库</li></ol></blockquote><p>所需文件：<br><img src="http://pj7pvy6lw.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20181212211304.png" alt></p><p>color文件夹有5张彩色图<br>depth有五张深度图<br>joinMap.cpp如下<br>pose.txt为相机参数</p><h2 id="中心思想"><a href="#中心思想" class="headerlink" title="中心思想"></a>中心思想</h2><blockquote><p>三个坐标系：世界坐标系，相机坐标系，像素坐标系<br>两个参数：K(内参)，(T)外参</p><p>K和T都是一个4*4欧式变换矩阵，k实现像素坐标系和像素坐标系之间转换，T实现世界坐标系和相机坐标系之间的转换<br>如下公式，K由fx,fy,cx,cy四个参数决定，T由pose.txt中数据确定<br>最终根据最下面的公式，由各个像素坐标中的像素点得到世界坐标系点，然后用pcl转化成点云图。<br>注意：点云图中的点是三维点，所以还需要一个量–d深度，由depth文件夹中五张深度图获得，而深度图怎么获得呢？有三种相机可获得。。。后面再讲<br>还有，opencv3安装，依赖；Eigen安装，pcl安装等问题如下图，实在不懂自己百度。。。。</p></blockquote><p><img src="http://pj7pvy6lw.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt><br><img src="http://pj7pvy6lw.bkt.clouddn.com/%E5%9B%BE%E7%89%872.png" alt><br><img src="http://pj7pvy6lw.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20181212213917.png" alt></p><h2 id="代码及详细分析"><a href="#代码及详细分析" class="headerlink" title="代码及详细分析"></a>代码及详细分析</h2><p>（我不相信你还有比我还详细的了，哼。。。）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/format.hpp&gt;  // for formating strings</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过点云拼接，我们就可以还原这个房间的三维场景。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">已知：5张RGB-D图像，每个图像的内参K和外参T</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">目标：计算所有像素在世界坐标系的位置，把点云加起来，组成地图。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：根据pose.txt中相机外参（平移向量+旋转四元数）转换成变换矩阵T（4*4）；对相机坐标（根据像素和实物关系得到）通T转换成世界坐标；之后根据5张图循环构造点云。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Mat&gt; colorImgs, depthImgs;    <span class="comment">// 彩色图和深度图</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相机位姿, 5*7，表示五张图片，每张图片对应7个数前三个数是平移向量，后四个是旋转四元数</span></span><br><span class="line">    <span class="comment">// poses 是长度为5的数组，每个元素是个矩阵（4*4）</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Eigen::Isometry3d, Eigen::aligned_allocator&lt;Eigen::Isometry3d&gt;&gt; poses;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"./pose.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"请在有pose.txt的目录下运行此程序"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 照片读取，boost::format 格式化字符串  拼接出图片文件名</span></span><br><span class="line">        boost::<span class="function">format <span class="title">fmt</span><span class="params">( <span class="string">"./%s/%d.%s"</span> )</span></span>; <span class="comment">//图像文件格式</span></span><br><span class="line">        colorImgs.push_back( cv::imread( (fmt%<span class="string">"color"</span>%(i+<span class="number">1</span>)%<span class="string">"png"</span>).str() ));</span><br><span class="line">        depthImgs.push_back( cv::imread( (fmt%<span class="string">"depth"</span>%(i+<span class="number">1</span>)%<span class="string">"pgm"</span>).str(), <span class="number">-1</span> )); <span class="comment">// 使用-1读取原始图像</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相机位姿读取到组data[]</span></span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; d:data ) <span class="comment">//auto自动类型转换</span></span><br><span class="line">            fin&gt;&gt;d; <span class="comment">//文件流类型的变量fin将pose.txt中的数据给了d数组</span></span><br><span class="line">        Eigen::<span class="function">Quaterniond <span class="title">q</span><span class="params">( data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>] )</span></span>; <span class="comment">//四元数 data[6]是实数 但是coeffis输出的是先虚数后实数</span></span><br><span class="line">        Eigen::<span class="function">Isometry3d <span class="title">T</span><span class="params">(q)</span></span>; <span class="comment">//变换矩阵T初始化旋转部分</span></span><br><span class="line">        T.pretranslate( Eigen::Vector3d( data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>] )); <span class="comment">//T初始化平移向量部分</span></span><br><span class="line">        poses.push_back( T ); <span class="comment">//存储T到位姿数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算点云并拼接</span></span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">double</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">double</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">double</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">double</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">double</span> depthScale = <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"正在将图像转换为点云..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义点云使用的格式：这里用的是XYZRGB</span></span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointXYZRGB PointT;</span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointCloud&lt;PointT&gt; PointCloud;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个点云</span></span><br><span class="line">    PointCloud::<span class="function">Ptr <span class="title">pointCloud</span><span class="params">( <span class="keyword">new</span> PointCloud )</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"转换图像中: "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        cv::Mat color = colorImgs[i];</span><br><span class="line">        cv::Mat depth = depthImgs[i];</span><br><span class="line">        Eigen::Isometry3d T = poses[i];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> v=<span class="number">0</span>; v&lt;color.rows; v++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> u=<span class="number">0</span>; u&lt;color.cols; u++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> d = depth.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; ( v )[u]; <span class="comment">// 深度值v,u像素对应的深度值</span></span><br><span class="line">                <span class="keyword">if</span> ( d==<span class="number">0</span> ) <span class="keyword">continue</span>; <span class="comment">// 为0表示没有测量到</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将像素坐标(u,v,d)计算到相机坐标系下坐标 point</span></span><br><span class="line">                Eigen::Vector3d point;</span><br><span class="line">                point[<span class="number">2</span>] = <span class="keyword">double</span>(d)/depthScale;</span><br><span class="line">                point[<span class="number">0</span>] = (u-cx)*point[<span class="number">2</span>]/fx;</span><br><span class="line">                point[<span class="number">1</span>] = (v-cy)*point[<span class="number">2</span>]/fy;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过外参T将相机坐标系中的point转化成世界坐标系中的pointWorld</span></span><br><span class="line">                Eigen::Vector3d pointWorld = T*point;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将世界坐标系中的坐标放入点云图中的点中</span></span><br><span class="line">                PointT p ;</span><br><span class="line">                p.x = pointWorld[<span class="number">0</span>];</span><br><span class="line">                p.y = pointWorld[<span class="number">1</span>];</span><br><span class="line">                p.z = pointWorld[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取彩色图中各个像素点的bgr值</span></span><br><span class="line">                p.b = color.data[ v*color.step+u*color.channels() ];</span><br><span class="line">                p.g = color.data[ v*color.step+u*color.channels()+<span class="number">1</span> ];</span><br><span class="line">                p.r = color.data[ v*color.step+u*color.channels()+<span class="number">2</span> ];</span><br><span class="line">                pointCloud-&gt;points.push_back( p );</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pointCloud-&gt;is_dense = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"点云共有"</span>&lt;&lt;pointCloud-&gt;size()&lt;&lt;<span class="string">"个点."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    pcl::io::savePCDFileBinary(<span class="string">"map.pcd"</span>, *pointCloud );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实验-2-视觉-3D-点云图构建与深度测量&quot;&gt;&lt;a href=&quot;#实验-2-视觉-3D-点云图构建与深度测量&quot; class=&quot;headerlink&quot; title=&quot;实验 2 视觉 3D 点云图构建与深度测量&quot;&gt;&lt;/a&gt;实验 2 视觉 3D 点云图构建与深度测量&lt;/h1&gt;
    
    </summary>
    
      <category term="CV" scheme="http://looby.coding.me/betterming/categories/CV/"/>
    
    
      <category term="CV" scheme="http://looby.coding.me/betterming/tags/CV/"/>
    
      <category term="OpenCV" scheme="http://looby.coding.me/betterming/tags/OpenCV/"/>
    
      <category term="Linux" scheme="http://looby.coding.me/betterming/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>基于OpenCV的颜色特征识别</title>
    <link href="http://looby.coding.me/betterming/post/d7e278a1.html"/>
    <id>http://looby.coding.me/betterming/post/d7e278a1.html</id>
    <published>2018-12-09T03:00:10.000Z</published>
    <updated>2019-05-19T12:33:31.527Z</updated>
    
    <content type="html"><![CDATA[<p>这篇post是智能机器人技术实验</p><h1 id="实验-1-基于OpenCV的颜色特征识别"><a href="#实验-1-基于OpenCV的颜色特征识别" class="headerlink" title="实验 1 基于OpenCV的颜色特征识别"></a>实验 1 基于OpenCV的颜色特征识别</h1><a id="more"></a><h2 id="实验设备："><a href="#实验设备：" class="headerlink" title="实验设备："></a>实验设备：</h2><p>平台二选一：</p><ul><li>平台一：树莓派, Linux OS, OpenCV 开发库</li><li>平台二： 个人计算机，Linux OS,USB 摄像头，OpenCV 开发库</li></ul><h2 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h2><ul><li>数字图像处理基础</li><li>C++、python 编程基础</li><li>Linux 系统基本操作基础</li></ul><h2 id="关于颜色特征识别的一些知识："><a href="#关于颜色特征识别的一些知识：" class="headerlink" title="关于颜色特征识别的一些知识："></a>关于颜色特征识别的一些知识：</h2><h3 id="1-CamShift算法："><a href="#1-CamShift算法：" class="headerlink" title="1. CamShift算法："></a>1. CamShift算法：</h3><p>全称是 Continuously AdaptiveMeanShift，顾名思义，它是对Mean Shift 算法的改进，能够自动调节搜索窗口大小来适应目标的大小，可以跟踪视频中尺寸变化的目标。它也是一种半自动跟踪算法，需要手动标定跟踪目标。基本思想是以视频图像中运动物体的颜色信息作为特征，对输入图像的每一帧分别作 Mean-Shift 运算，并将上一帧的目标中心和搜索窗口大小(核函数带宽)作为下一帧 Mean shift 算法的中心和搜索窗口大小的初始值，如此迭代下去，就可以实现对目标的跟踪。因为在每次搜索前将搜索窗口的位置和大小设置为运动目标当前中心的位置和大小，而运动目标通常在这区域附近，缩短了搜索时间；另外，在目标运动过程中，颜色变化不大，故该算法具有良好的鲁棒性。已被广泛应用到运动人体跟踪，人脸跟踪等领域。</p><h3 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h3><p><img src="https://miao.su/images/2019/05/19/0a201932f9f6f62b11d35.png" alt="0a201932f9f6f62b11d35.png"></p><h3 id="3-代码及分析"><a href="#3-代码及分析" class="headerlink" title="3. 代码及分析"></a>3. 代码及分析</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"></span><br><span class="line"><span class="comment"># from picamera.array import PiRGBArray</span></span><br><span class="line"><span class="comment"># from picamera import PiCamera</span></span><br><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># import copy</span></span><br><span class="line"><span class="keyword">import</span> video <span class="comment"># 调取摄像头</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color)</span>:</span> <span class="comment"># 获取图片</span></span><br><span class="line">        self.cam = video.create_capture(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#         self.cam = PiCamera()</span></span><br><span class="line"><span class="comment">#         self.cam.resolution = (320,240)</span></span><br><span class="line"><span class="comment">#         self.cam.framerate = 32</span></span><br><span class="line"><span class="comment">#         self.rCa = PiRGBArray(self.cam, size=(320,240))</span></span><br><span class="line"><span class="comment">#         time.sleep(0.1)</span></span><br><span class="line"><span class="comment">#        self.cam.capture(self.rCa, format='bgr')</span></span><br><span class="line"><span class="comment">#        self.frame = self.rCa.array</span></span><br><span class="line"><span class="comment">#        ret, self.frame = self.cam.read()</span></span><br><span class="line">        cv2.namedWindow(<span class="string">'camshift'</span>) <span class="comment"># 通过命名的方式，创建了一个窗口</span></span><br><span class="line">        <span class="keyword">if</span> color == <span class="number">0</span>:</span><br><span class="line">            self.roi = cv2.imread( <span class="string">'lan.jpg'</span> )</span><br><span class="line">            self.flag = <span class="string">"lan"</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            self.flag = <span class="string">"hong"</span></span><br><span class="line">            self.roi = cv2.imread(<span class="string">'hong.png'</span>)</span><br><span class="line">            self.selection = <span class="literal">None</span></span><br><span class="line">            self.tracking_state = <span class="number">0</span></span><br><span class="line">            self.show_backproj = <span class="literal">False</span></span><br><span class="line"><span class="comment">#         self.ser = serial.Serial('/dev/ttyAMA0',115200,timeout=0.5)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span> <span class="comment"># start方法用来设置一些状态，初始化信息</span></span><br><span class="line">        <span class="comment"># tracking_state 判断是否进行追踪</span></span><br><span class="line">        self.tracking_state = <span class="number">0</span></span><br><span class="line">        <span class="comment">#x, y = np.int16([220, 110]) # BUG</span></span><br><span class="line">        <span class="keyword">if</span> self.flag == <span class="string">'Hong'</span>:</span><br><span class="line">                self.selection = (<span class="number">4</span>, <span class="number">6</span>, <span class="number">407</span>, <span class="number">304</span>) <span class="comment"># 设置初始追踪窗口</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.selection = (<span class="number">40</span>, <span class="number">54</span>, <span class="number">296</span>, <span class="number">230</span>)</span><br><span class="line">            self.tracking_state = <span class="number">1</span></span><br><span class="line">    <span class="comment">#        print "start"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_hist</span><span class="params">(self)</span>:</span> <span class="comment"># 直方图显示</span></span><br><span class="line">        bin_count = self.hist.shape[<span class="number">0</span>] <span class="comment"># hist在行数，在这里是16，即有16个条纹</span></span><br><span class="line">        print(<span class="string">"hist,bin"</span>,self.hist.shape, bin_count, self.hist)</span><br><span class="line"></span><br><span class="line">        bin_w = <span class="number">24</span> <span class="comment"># 每条条纹宽度</span></span><br><span class="line">        img = np.zeros((<span class="number">256</span>, bin_count*bin_w, <span class="number">3</span>), np.uint8) <span class="comment"># 初始化img图像，用于显示直方图，大小为256*(24*16)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(bin_count): <span class="comment"># 对每一条纹绘制</span></span><br><span class="line">            h = int(self.hist[i])</span><br><span class="line">            cv2.rectangle(img, (i*bin_w+<span class="number">2</span>, <span class="number">255</span>), ((i+<span class="number">1</span>)*bin_w<span class="number">-2</span>, <span class="number">255</span>-h), (int(<span class="number">180.0</span>*i/bin_count), <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line">        img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) <span class="comment"># 将图像格式HSV转化成BGR</span></span><br><span class="line">        cv2.imshow(<span class="string">'hist'</span>, img)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span> <span class="comment">#主要功能函数</span></span><br><span class="line">        roi = self.roi <span class="comment"># roi存放目标图像</span></span><br><span class="line">        self.start()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 死循环，通过Ctrl + C 退出</span></span><br><span class="line"><span class="comment">#         for frame in self.cam.capture_continuous(self.rCa, format='bgr', use_video_port=True):</span></span><br><span class="line">            ret, self.frame = self.cam.read() <span class="comment"># 通过摄像头获取图像</span></span><br><span class="line"><span class="comment">#             self.frame = frame.array        # frame为摄像头获取的图像</span></span><br><span class="line">            vis = self.frame.copy()           <span class="comment"># vis复制frame</span></span><br><span class="line"><span class="comment">#             vis = copy.deepcopy(self.frame)</span></span><br><span class="line">            hsv = cv2.cvtColor(self.frame, cv2.COLOR_BGR2HSV)</span><br><span class="line">            mask = cv2.inRange(hsv, np.array((<span class="number">0.</span>, <span class="number">60.</span>, <span class="number">32.</span>)), np.array((<span class="number">180.</span>, <span class="number">255.</span>, <span class="number">255.</span>)))     <span class="comment"># 掩模图像。要统计整幅图像的直方图就把它设为 None。但是如 果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并 使用它。</span></span><br><span class="line"><span class="comment">#             self.selection = 1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.selection:</span><br><span class="line"><span class="comment">#                 x0, y0, x1, y1 = 220, 110, 358, 245</span></span><br><span class="line">                x0, y0, x1, y1 = self.selection</span><br><span class="line">                self.track_window = (x0, y0, x1-x0, y1-y0) <span class="comment"># 窗口缩小</span></span><br><span class="line"><span class="comment">#                 hsv_roi = hsv[y0:y1, x0:x1]</span></span><br><span class="line"><span class="comment">#                 mask_roi = mask[y0:y1, x0:x1]</span></span><br><span class="line">                hsv_roi = cv2. cvtColor(roi,cv2. COLOR_BGR2HSV)</span><br><span class="line">                mask_roi = cv2.inRange(hsv_roi, np.array((<span class="number">0.</span>, <span class="number">60.</span>, <span class="number">32.</span>)), np.array((<span class="number">180.</span>, <span class="number">255.</span>, <span class="number">255.</span>)))</span><br><span class="line">                <span class="comment">#一维直方图</span></span><br><span class="line">                hist = cv2.calcHist( [hsv_roi], [<span class="number">0</span>], mask_roi, [<span class="number">16</span>], [<span class="number">0</span>, <span class="number">180</span>] )</span><br><span class="line">                <span class="comment">#二维直方图</span></span><br><span class="line"><span class="comment">#                 hist = cv2.calcHist( [hsv_roi], [0,2],None, [180,256], [0, 180,0 , 255] )</span></span><br><span class="line"></span><br><span class="line">                cv2.normalize(hist, hist, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX);</span><br><span class="line">                self.hist = hist.reshape(<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">#二维直方图显示</span></span><br><span class="line"><span class="comment">#                 plt.imshow(hist,interpolation = 'nearest')</span></span><br><span class="line"><span class="comment">#                 plt.show()</span></span><br><span class="line">                self.show_hist()</span><br><span class="line"></span><br><span class="line">                vis_roi = vis[y0:y1, x0:x1]</span><br><span class="line">                cv2.bitwise_not(vis_roi, vis_roi) <span class="comment"># 颜色反转</span></span><br><span class="line">                vis[mask == <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.tracking_state == <span class="number">1</span>:</span><br><span class="line">                self.selection = <span class="literal">None</span></span><br><span class="line">                prob = cv2.calcBackProject([hsv], [<span class="number">0</span>], self.hist, [<span class="number">0</span>, <span class="number">180</span>], <span class="number">1</span>) <span class="comment"># 计算反向投影参数为：捕获的图片（转化成hsv格式），灰度值方式，目标图像直方图，直方图范围</span></span><br><span class="line">                prob &amp;= mask</span><br><span class="line">                term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, <span class="number">10</span>, <span class="number">1</span> ) <span class="comment"># 跳出条件，迭代10次或至少移动一次</span></span><br><span class="line">                track_box, self.track_window = cv2.CamShift(prob, self.track_window, term_crit) <span class="comment"># 利用cameshift算法在追踪窗口中搜寻与直方图分布最相似的窗口，结果返回窗口和track_box</span></span><br><span class="line"><span class="comment">#                 if track_box[0][1] &lt;= 240:</span></span><br><span class="line"><span class="comment">#             self.ser.write(str(int(track_box[0][0])-320) + " " + str(int(track_box[0][1])-240))</span></span><br><span class="line"><span class="comment">#             print str(int(track_box[0][0])-320) + " " + str(int(track_box[0][1])-240)</span></span><br><span class="line">                <span class="keyword">if</span> track_box[<span class="number">1</span>][<span class="number">1</span>] &lt;= <span class="number">1</span>:</span><br><span class="line">                    self.tracking_state = <span class="number">0</span></span><br><span class="line">                    self.start()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.show_backproj:</span><br><span class="line">                        vis[:] = prob[...,np.newaxis]</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        cv2.ellipse(vis, track_box, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)<span class="comment">#利用返回的track_box画出椭圆</span></span><br><span class="line"><span class="comment">#                         print track_box</span></span><br><span class="line">                        a = str(track_box[<span class="number">0</span>][<span class="number">0</span>])+<span class="string">" "</span>+str(track_box[<span class="number">0</span>][<span class="number">1</span>])+<span class="string">" "</span>+str(round(track_box[<span class="number">1</span>][<span class="number">0</span>],<span class="number">2</span>))\</span><br><span class="line">                                       +<span class="string">" "</span>+str(round(track_box[<span class="number">1</span>][<span class="number">1</span>],<span class="number">2</span>))+<span class="string">" "</span>+str(round(track_box[<span class="number">2</span>],<span class="number">2</span>))+<span class="string">"\r\n"</span></span><br><span class="line">                        <span class="keyword">print</span> a</span><br><span class="line"><span class="comment">#                         self.ser.write(a)</span></span><br><span class="line">                    <span class="keyword">except</span>: <span class="keyword">print</span> track_box</span><br><span class="line"></span><br><span class="line">            cv2.imshow(<span class="string">'camshift'</span>, vis)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 通过键盘输入来实现一些功能</span></span><br><span class="line">            ch = <span class="number">0xFF</span> &amp; cv2.waitKey(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="number">27</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> ch == ord(<span class="string">'b'</span>):</span><br><span class="line">                self.show_backproj = <span class="keyword">not</span> self.show_backproj</span><br><span class="line">            <span class="keyword">if</span> ch == ord(<span class="string">'r'</span>):</span><br><span class="line">                self.tracking_state = <span class="number">0</span></span><br><span class="line">                self.start()</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">try</span>: color = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>: color = <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> __doc__</span><br><span class="line">    a = App(color)</span><br><span class="line">    a.run()</span><br></pre></td></tr></table></figure><p><img src="https://miao.su/images/2019/02/04/cv8e8da.gif" alt="cv8e8da.gif"></p><p>video.py</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Video capture sample.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sample shows how VideoCapture class can be used to acquire video</span></span><br><span class="line"><span class="string">frames from a camera of a movie file. Also the sample provides</span></span><br><span class="line"><span class="string">an example of procedural video generation by an object, mimicking</span></span><br><span class="line"><span class="string">the VideoCapture interface (see Chess class).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'create_capture' is a convinience function for capture creation,</span></span><br><span class="line"><span class="string">falling back to procedural video in case of error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">    video.py [--shotdir &lt;shot path&gt;] [source0] [source1] ...'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    sourceN is an</span></span><br><span class="line"><span class="string">     - integer number for camera capture</span></span><br><span class="line"><span class="string">     - name of video file</span></span><br><span class="line"><span class="string">     - synth:&lt;params&gt; for procedural video</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Synth examples:</span></span><br><span class="line"><span class="string">    synth:bg=../cpp/lena.jpg:noise=0.1</span></span><br><span class="line"><span class="string">    synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Keys:</span></span><br><span class="line"><span class="string">    ESC    - exit</span></span><br><span class="line"><span class="string">    SPACE  - save current frame to &lt;shot path&gt; director</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> clock</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> pi, sin, cos</span><br><span class="line"><span class="keyword">import</span> common</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSynthBase</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size=None, noise=<span class="number">0.0</span>, bg = None, **params)</span>:</span></span><br><span class="line">        self.bg = <span class="literal">None</span></span><br><span class="line">        self.frame_size = (<span class="number">1000</span>, <span class="number">480</span>)</span><br><span class="line"><span class="comment">#         self.frame_size = (640, 480)</span></span><br><span class="line">        <span class="keyword">if</span> bg <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.bg = cv2.imread(bg, <span class="number">1</span>)</span><br><span class="line">            h, w = self.bg.shape[:<span class="number">2</span>]</span><br><span class="line">            self.frame_size = (w, h)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            w, h = map(int, size.split(<span class="string">'x'</span>))</span><br><span class="line">            self.frame_size = (w, h)</span><br><span class="line">            self.bg = cv2.resize(self.bg, self.frame_size)</span><br><span class="line"></span><br><span class="line">        self.noise = float(noise)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, dst)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, dst=None)</span>:</span></span><br><span class="line">        w, h = self.frame_size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.bg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            buf = np.zeros((h, w, <span class="number">3</span>), np.uint8)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buf = self.bg.copy()</span><br><span class="line"></span><br><span class="line">        self.render(buf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.noise &gt; <span class="number">0.0</span>:</span><br><span class="line">            noise = np.zeros((h, w, <span class="number">3</span>), np.int8)</span><br><span class="line">            cv2.randn(noise, np.zeros(<span class="number">3</span>), np.ones(<span class="number">3</span>)*<span class="number">255</span>*self.noise)</span><br><span class="line">            buf = cv2.add(buf, noise, dtype=cv2.CV_8UC3)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, buf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isOpened</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span><span class="params">(VideoSynthBase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        super(Chess, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">        w, h = self.frame_size</span><br><span class="line"></span><br><span class="line">        self.grid_size = sx, sy = <span class="number">10</span>, <span class="number">7</span></span><br><span class="line">        white_quads = []</span><br><span class="line">        black_quads = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> np.ndindex(sy, sx):</span><br><span class="line">            q = [[j, i, <span class="number">0</span>], [j+<span class="number">1</span>, i, <span class="number">0</span>], [j+<span class="number">1</span>, i+<span class="number">1</span>, <span class="number">0</span>], [j, i+<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">            [white_quads, black_quads][(i + j) % <span class="number">2</span>].append(q)</span><br><span class="line">        self.white_quads = np.float32(white_quads)</span><br><span class="line">        self.black_quads = np.float32(black_quads)</span><br><span class="line"></span><br><span class="line">        fx = <span class="number">0.9</span></span><br><span class="line">        self.K = np.float64([[fx*w, <span class="number">0</span>, <span class="number">0.5</span>*(w<span class="number">-1</span>)],</span><br><span class="line">                        [<span class="number">0</span>, fx*w, <span class="number">0.5</span>*(h<span class="number">-1</span>)],</span><br><span class="line">                        [<span class="number">0.0</span>,<span class="number">0.0</span>,      <span class="number">1.0</span>]])</span><br><span class="line"></span><br><span class="line">        self.dist_coef = np.float64([<span class="number">-0.2</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">        self.t = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_quads</span><span class="params">(self, img, quads, color = <span class="params">(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span>)</span>:</span></span><br><span class="line">        img_quads = cv2.projectPoints(quads.reshape(<span class="number">-1</span>, <span class="number">3</span>), self.rvec, self.tvec, self.K, self.dist_coef) [<span class="number">0</span>]</span><br><span class="line">        img_quads.shape = quads.shape[:<span class="number">2</span>] + (<span class="number">2</span>,)</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> img_quads:</span><br><span class="line">            cv2.fillConvexPoly(img, np.int32(q*<span class="number">4</span>), color, cv2.CV_AA, shift=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, dst)</span>:</span></span><br><span class="line">        t = self.t</span><br><span class="line">        self.t += <span class="number">1.0</span>/<span class="number">30.0</span></span><br><span class="line"></span><br><span class="line">        sx, sy = self.grid_size</span><br><span class="line">        center = np.array([<span class="number">0.5</span>*sx, <span class="number">0.5</span>*sy, <span class="number">0.0</span>])</span><br><span class="line">        phi = pi/<span class="number">3</span> + sin(t*<span class="number">3</span>)*pi/<span class="number">8</span></span><br><span class="line">        c, s = cos(phi), sin(phi)</span><br><span class="line">        ofs = np.array([sin(<span class="number">1.2</span>*t), cos(<span class="number">1.8</span>*t), <span class="number">0</span>]) * sx * <span class="number">0.2</span></span><br><span class="line">        eye_pos = center + np.array([cos(t)*c, sin(t)*c, s]) * <span class="number">15.0</span> + ofs</span><br><span class="line">        target_pos = center + ofs</span><br><span class="line"></span><br><span class="line">        R, self.tvec = common.lookat(eye_pos, target_pos)</span><br><span class="line">        self.rvec = common.mtx2rvec(R)</span><br><span class="line"></span><br><span class="line">        self.draw_quads(dst, self.white_quads, (<span class="number">245</span>, <span class="number">245</span>, <span class="number">245</span>))</span><br><span class="line">        self.draw_quads(dst, self.black_quads, (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classes = dict(chess=Chess)</span><br><span class="line"></span><br><span class="line">presets = dict(</span><br><span class="line">    empty = <span class="string">'synth:'</span>,</span><br><span class="line">    lena = <span class="string">'synth:bg=../cpp/lena.jpg:noise=0.1'</span>,</span><br><span class="line">    chess = <span class="string">'synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_capture</span><span class="params">(source = <span class="number">0</span>, fallback = presets[<span class="string">'chess'</span>])</span>:</span></span><br><span class="line">    <span class="string">'''source: &lt;int&gt; or '&lt;int&gt;|&lt;filename&gt;|synth [:&lt;param_name&gt;=&lt;value&gt; [:...]]'</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    source = str(source).strip()</span><br><span class="line">    chunks = source.split(<span class="string">':'</span>)</span><br><span class="line">    <span class="comment"># hanlde drive letter ('c:', ...)</span></span><br><span class="line">    <span class="keyword">if</span> len(chunks) &gt; <span class="number">1</span> <span class="keyword">and</span> len(chunks[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> chunks[<span class="number">0</span>].isalpha():</span><br><span class="line">        chunks[<span class="number">1</span>] = chunks[<span class="number">0</span>] + <span class="string">':'</span> + chunks[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> chunks[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    source = chunks[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">try</span>: source = int(source)</span><br><span class="line">    <span class="keyword">except</span> ValueError: <span class="keyword">pass</span></span><br><span class="line">    params = dict( s.split(<span class="string">'='</span>) <span class="keyword">for</span> s <span class="keyword">in</span> chunks[<span class="number">1</span>:] )</span><br><span class="line"></span><br><span class="line">    cap = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> source == <span class="string">'synth'</span>:</span><br><span class="line">        Class = classes.get(params.get(<span class="string">'class'</span>, <span class="literal">None</span>), VideoSynthBase)</span><br><span class="line">        <span class="keyword">try</span>: cap = Class(**params)</span><br><span class="line">        <span class="keyword">except</span>: <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cap = cv2.VideoCapture(source)</span><br><span class="line">        params[<span class="string">"size"</span>] = <span class="string">"320x240"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'size'</span> <span class="keyword">in</span> params:</span><br><span class="line">            w, h = map(int, params[<span class="string">'size'</span>].split(<span class="string">'x'</span>))</span><br><span class="line">            cap.set(cv2.CAP_PROP_FRAME_WIDTH, w)</span><br><span class="line">            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, h)</span><br><span class="line">    <span class="keyword">if</span> cap <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        print(<span class="string">'Warning: unable to open video source: '</span>, source)</span><br><span class="line">        <span class="keyword">if</span> fallback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> create_capture(fallback, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> cap</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">import</span> getopt</span><br><span class="line"></span><br><span class="line">    print(__doc__)</span><br><span class="line"></span><br><span class="line">    args, sources = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">''</span>, <span class="string">'shotdir='</span>)</span><br><span class="line">    args = dict(args)</span><br><span class="line">    shotdir = args.get(<span class="string">'--shotdir'</span>, <span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(sources) == <span class="number">0</span>:</span><br><span class="line">        sources = [ <span class="number">0</span> ]</span><br><span class="line"></span><br><span class="line">    caps = map(create_capture, sources)</span><br><span class="line">    shot_idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        imgs = []</span><br><span class="line">        <span class="keyword">for</span> i, cap <span class="keyword">in</span> enumerate(caps):</span><br><span class="line">            ret, img = cap.read()</span><br><span class="line">            imgs.append(img)</span><br><span class="line">            cv2.imshow(<span class="string">'capture %d'</span> % i, img)</span><br><span class="line">        ch = <span class="number">0xFF</span> &amp; cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> ch == ord(<span class="string">' '</span>):</span><br><span class="line">            <span class="keyword">for</span> i, img <span class="keyword">in</span> enumerate(imgs):</span><br><span class="line">                fn = <span class="string">'%s/shot_%d_%03d.bmp'</span> % (shotdir, i, shot_idx)</span><br><span class="line">                cv2.imwrite(fn, img)</span><br><span class="line">                print(fn, <span class="string">'saved'</span>)</span><br><span class="line">            shot_idx += <span class="number">1</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><strong>参考：</strong></p><ol><li><a href="https://blog.csdn.net/tiemaxiaosu/article/details/51649401" target="_blank" rel="noopener">https://blog.csdn.net/tiemaxiaosu/article/details/51649401</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/video/doc/motion_analysis_and_object_tracking.html?highlight=camshift#cv2.CamShift" target="_blank" rel="noopener">http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/video/doc/motion_analysis_and_object_tracking.html?highlight=camshift#cv2.CamShift</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇post是智能机器人技术实验&lt;/p&gt;
&lt;h1 id=&quot;实验-1-基于OpenCV的颜色特征识别&quot;&gt;&lt;a href=&quot;#实验-1-基于OpenCV的颜色特征识别&quot; class=&quot;headerlink&quot; title=&quot;实验 1 基于OpenCV的颜色特征识别&quot;&gt;&lt;/a&gt;实验 1 基于OpenCV的颜色特征识别&lt;/h1&gt;
    
    </summary>
    
      <category term="CV" scheme="http://looby.coding.me/betterming/categories/CV/"/>
    
    
      <category term="CV" scheme="http://looby.coding.me/betterming/tags/CV/"/>
    
      <category term="OpenCV" scheme="http://looby.coding.me/betterming/tags/OpenCV/"/>
    
      <category term="Linux" scheme="http://looby.coding.me/betterming/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>pycharm安装和破解</title>
    <link href="http://looby.coding.me/betterming/post/b2bb211a.html"/>
    <id>http://looby.coding.me/betterming/post/b2bb211a.html</id>
    <published>2018-12-04T09:05:31.000Z</published>
    <updated>2019-05-19T12:22:55.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pycharm2017专业破解版"><a href="#pycharm2017专业破解版" class="headerlink" title="pycharm2017专业破解版"></a>pycharm2017专业破解版</h1><h2 id="1-安装pycharm安装包"><a href="#1-安装pycharm安装包" class="headerlink" title="1. 安装pycharm安装包"></a>1. 安装pycharm安装包</h2><a id="more"></a><p>链接: <a href="https://pan.baidu.com/s/1uxmCo8VJiHVbBCQw5RIMEw" target="_blank" rel="noopener">https://pan.baidu.com/s/1uxmCo8VJiHVbBCQw5RIMEw</a> 提取码: 6666</p><p>正常安装即可</p><h2 id="2-下载jar包"><a href="#2-下载jar包" class="headerlink" title="2. 下载jar包"></a>2. 下载jar包</h2><p>链接: <a href="https://pan.baidu.com/s/1p9DFN0X7rq0N0Y2iapKMDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1p9DFN0X7rq0N0Y2iapKMDA</a> 提取码: 6666</p><h2 id="3-文件修改"><a href="#3-文件修改" class="headerlink" title="3. 文件修改"></a>3. 文件修改</h2><p><img src="https://miao.su/images/2019/02/06/pycharmba38d.png" alt="pycharmba38d.png"></p><p>将下载的jar包放入pycharm安装目录的/bin下, 并修改两个以 vmoptions为结尾的启动文件。将改启动文件以记事本形式打开然后分别在最后加上以下内容：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-javaagent</span><span class="selector-pseudo">:jar</span>包所在目录\<span class="selector-tag">JetbrainsCrack-2</span><span class="selector-class">.6</span><span class="selector-class">.10-release-enc</span><span class="selector-class">.jar</span></span><br></pre></td></tr></table></figure></p><h2 id="4-破解"><a href="#4-破解" class="headerlink" title="4. 破解"></a>4. 破解</h2><p>重启pycharm 后在下图中点击 Activation code 然后复制以下代码后点击Activate</p><p>​    <img src="https://miao.su/images/2019/02/06/pp16612.png" alt="pp16612.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK<span class="regexp">/3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL/</span>oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw<span class="regexp">/sCltpoPWlJtDOcw/i</span>EWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO<span class="regexp">/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/</span><span class="number">78</span>TmVqFl8nOeD5+<span class="number">07</span>B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB<span class="regexp">/xVy/</span>VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE<span class="regexp">/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/</span>GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9</span><br></pre></td></tr></table></figure><h1 id="5-查看"><a href="#5-查看" class="headerlink" title="5. 查看"></a>5. 查看</h1><p>打开pycharm点击help-&gt;about查看</p><p><img src="https://miao.su/images/2019/02/06/license7e09a.png" alt="license7e09a.png"></p><p>发现一直到2099年12月31日才过期。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;pycharm2017专业破解版&quot;&gt;&lt;a href=&quot;#pycharm2017专业破解版&quot; class=&quot;headerlink&quot; title=&quot;pycharm2017专业破解版&quot;&gt;&lt;/a&gt;pycharm2017专业破解版&lt;/h1&gt;&lt;h2 id=&quot;1-安装pycharm安装包&quot;&gt;&lt;a href=&quot;#1-安装pycharm安装包&quot; class=&quot;headerlink&quot; title=&quot;1. 安装pycharm安装包&quot;&gt;&lt;/a&gt;1. 安装pycharm安装包&lt;/h2&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://looby.coding.me/betterming/categories/Technique/"/>
    
    
      <category term="pycharm" scheme="http://looby.coding.me/betterming/tags/pycharm/"/>
    
      <category term="破解" scheme="http://looby.coding.me/betterming/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>线性表二</title>
    <link href="http://looby.coding.me/betterming/post/765aa586.html"/>
    <id>http://looby.coding.me/betterming/post/765aa586.html</id>
    <published>2018-11-30T04:41:00.000Z</published>
    <updated>2019-02-06T14:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-Remove-Duplicates-from-Sorted-List"><a href="#3-Remove-Duplicates-from-Sorted-List" class="headerlink" title="3. Remove Duplicates from Sorted List"></a>3. Remove Duplicates from Sorted List</h1><a id="more"></a><p><strong>Description:</strong><br>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><p>Example 1:</p><blockquote><p>Input: 1-&gt;1-&gt;2<br>Output: 1-&gt;2</p></blockquote><p>Example 2:</p><blockquote><p>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>Output: 1-&gt;2-&gt;3</p></blockquote><p><strong>Analysis:</strong></p><p>迭代法</p><p><strong>Solution:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">ListNode *pre = head, *p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(pre-&gt;val == p-&gt;val) &#123;</span><br><span class="line">pre-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pre = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-Remove-Duplicates-from-Sorted-List&quot;&gt;&lt;a href=&quot;#3-Remove-Duplicates-from-Sorted-List&quot; class=&quot;headerlink&quot; title=&quot;3. Remove Duplicates from Sorted List&quot;&gt;&lt;/a&gt;3. Remove Duplicates from Sorted List&lt;/h1&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://looby.coding.me/betterming/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://looby.coding.me/betterming/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="线性表" scheme="http://looby.coding.me/betterming/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
</feed>
