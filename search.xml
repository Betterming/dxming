<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Chap2_StackQueue]]></title>
    <url>%2Fpost%2Fea08c047.html</url>
    <content type="text"><![CDATA[第二节：栈，队列，堆1. 基础： 栈，先进后出的线性表 s.push(item); //将item压入栈顶 s.pop(); //删除栈顶的元素，但不会返回 s.top(); //返回栈顶的元素，但不会删除 s.size(); //返回栈中元素的个数 s.empty(); //检查栈是否为空，如果为空返回true，否则返回false 队列，先进先出的线性表。 q.push(item) //将item压入队列尾部 q.pop() //删除队首元素，但不返回 q.front() //返回队首元素，但不删除 q.back() //返回队尾元素，但不删除 q.size() //返回队列中元素的个数 q.empty() //检查队列是否为空，如果为空返回true，否则返回false 2. 例题例1: LeetCode 225. Implement Stack using Queues 使用队列实现栈的下列操作：push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空 注意:你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 思路: 利用两个队列来实现一个栈,主要看push 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; queue&lt;int&gt; temp; temp.push(x); while (!_data.empty()) &#123; temp.push(_data.front()); _data.pop(); &#125; while (!temp.empty()) &#123; _data.push(temp.front()); temp.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int x = _data.front(); _data.pop(); return x; &#125; /** Get the top element. */ int top() &#123; return _data.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return _data.empty(); &#125;private: queue&lt;int&gt; _data;&#125;;/*** Your MyStack object will be instantiated and called as such:* MyStack* obj = new MyStack();* obj-&gt;push(x);* int param_2 = obj-&gt;pop();* int param_3 = obj-&gt;top();* bool param_4 = obj-&gt;empty();*/int main() &#123; MyStack S; S.push(1); S.push(2); S.push(3); S.push(4); printf("%d\n", S.top()); S.pop(); printf("%d\n", S.top()); S.push(5); printf("%d\n", S.top()); return 0;&#125; 例2:LeetCode 232. Implement Queue using Stacks 使用栈实现队列的下列操作：push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 示例:MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false说明:你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stack&lt;int&gt; temp; while (!_data.empty()) &#123; temp.push(_data.top()); _data.pop(); &#125; temp.push(x); while (!temp.empty()) &#123; _data.push(temp.top()); temp.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int x = _data.top(); _data.pop(); return x; &#125; /** Get the front element. */ int peek() &#123; return _data.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _data.empty(); &#125;private: stack&lt;int&gt; _data;&#125;;/*** Your MyQueue object will be instantiated and called as such:* MyQueue* obj = new MyQueue();* obj-&gt;push(x);* int param_2 = obj-&gt;pop();* int param_3 = obj-&gt;peek();* bool param_4 = obj-&gt;empty();*/int main() &#123; MyQueue Q; Q.push(1); Q.push(2); Q.push(3); Q.push(4); printf("%d\n", Q.peek()); Q.pop(); printf("%d\n", Q.peek()); return 0;&#125; 例3:LeetCode 155. Min Stack 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。 示例:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2. 思路：维护一个_min栈，使得每个元素时_data栈从底到该位置最小的值， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; _data.push(x); if (_min.empty()) &#123; _min.push(x); &#125; else &#123; if (x &gt; _min.top()) &#123; x = _min.top(); &#125; _min.push(x); &#125; &#125; void pop() &#123; _data.pop(); _min.pop(); &#125; int top() &#123; return _data.top(); &#125; int getMin() &#123; return _min.top(); &#125;private: stack&lt;int&gt; _data; stack&lt;int&gt; _min;&#125;;int main() &#123; MinStack minStack; minStack.push(-2); printf("top = [%d]\n", minStack.top()); printf("min = [%d]\n\n", minStack.getMin()); minStack.push(0); printf("top = [%d]\n", minStack.top()); printf("min = [%d]\n\n", minStack.getMin()); minStack.push(-5); printf("top = [%d]\n", minStack.top()); printf("min = [%d]\n\n", minStack.getMin()); minStack.pop(); printf("top = [%d]\n", minStack.top()); printf("min = [%d]\n\n", minStack.getMin()); return 0;&#125; 例4: poj 1363 Rails 已知从1至n的数字序列，按顺序入栈，每个数字入栈后即可出栈，也可在栈中停留，等待后面的数字入栈出栈后，该数字再出栈，求该数字序列的出栈序列是否合法？ 思路：使用栈与队列模拟入栈、出栈过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*bool check_is_valid_order(queue&lt;int&gt; &amp;order) &#123;stack&lt;int&gt; S;for (int i = 1; i &lt;= order.size(); i++)&#123;S.push(i);while (S.top() == order.front() &amp;&amp; !S.empty()) &#123;order.pop();S.pop();&#125;&#125;if (!S.empty()) &#123;return false;&#125;return true;&#125;*/bool check_is_valid_order(queue&lt;int&gt; &amp;order) &#123; stack&lt;int&gt; S; for (int i = 1; i &lt;= order.size(); i++) &#123; S.push(i); while (S.top() == order.front() &amp;&amp; !S.empty()) &#123; order.pop(); S.pop(); &#125; &#125; if (!S.empty()) &#123; return false; &#125; return true;&#125;int main() &#123; int n; int train; scanf("%d", &amp;n); while (n) &#123; scanf("%d", &amp;train); while (train) &#123; std::queue&lt;int&gt; order; order.push(train); for (int i = 1; i &lt; n; i++) &#123; scanf("%d", &amp;train); order.push(train); &#125; if (check_is_valid_order(order)) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; scanf("%d", &amp;train); &#125; printf("\n"); scanf("%d", &amp;n); &#125; return 0;&#125; 例5：LeetCode 224. Basic Calculator 模拟计算器，实现基本的加减乘除思路：状态机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;stack&gt;void compute(std::stack&lt;int&gt; &amp;number_stack, std::stack&lt;char&gt; &amp;operation_stack)&#123; if(number_stack.size() &lt; 2) return; int num2 = number_stack.top(); number_stack.pop(); int num1 = number_stack.top(); number_stack.pop(); if(operation_stack.top() == '+') number_stack.push(num1 + num2); else if(operation_stack.top() == '-') number_stack.push(num1 - num2); operation_stack.pop();&#125;class Solution&#123;public: int calculate(std::string s) &#123; // "1+121 - (14+(5-6))" static const int STATE_BEGIN = 0; static const int NUMBER_STATE = 1; static const int OPERATION_STATE = 2; std::stack&lt;int&gt; number_stack; std::stack&lt;char&gt; operation_stack; int number = 0; int STATE = STATE_BEGIN; int compute_flag = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if(s[i] == ' ') continue; switch(STATE)&#123; case STATE_BEGIN: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') STATE = NUMBER_STATE; else STATE = OPERATION_STATE; i--; break; case NUMBER_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;='9') number = number * 10 + s[i] - '0'; else &#123; number_stack.push(number); if(compute_flag == 1) compute(number_stack, operation_stack); number = 0; i--; STATE = OPERATION_STATE; &#125; break; case OPERATION_STATE: if(s[i] == '+' || s[i] == '-')&#123; operation_stack.push(s[i]); compute_flag = 1; &#125; else if(s[i] == '(') &#123; STATE = NUMBER_STATE; compute_flag = 0; &#125; else if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;='9')&#123; STATE = NUMBER_STATE; i--; &#125; else if(s[i] == ')') &#123; compute(number_stack, operation_stack); &#125; break; &#125; &#125; if(number != 0)&#123; number_stack.push(number); compute(number_stack, operation_stack); &#125; if(number == 0 &amp;&amp; number_stack.empty()) return 0; return number_stack.top();&#125; &#125;;int str_2_int(std::string s)&#123; int number = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; number = number*10 + s[i] - '0'; &#125; return number;&#125;int main()&#123; std::string s = "123445"; printf("%d\n", str_2_int(s)); std::string str = "1+121 - (14-4+(5-6))"; Solution solve; printf("%d\n", solve.calculate(str)); return 0;&#125; 1234567891011121314151617181920212223242526/* STL中大小堆，优先级队列priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt; small_heap; //小根堆priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; big_heap2; // 大根堆*/int main() &#123; priority_queue&lt;int&gt; big_heap; priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt; small_heap; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; big_heap2; if (big_heap.empty()) &#123; printf("big_heap is empty!\n"); &#125; int test[] = &#123; 6, 10, 1, 7, 99, 4, 33 &#125;; for (int i = 0; i &lt; 7; i++) &#123; big_heap.push(test[i]); &#125; printf("big_heap.top = %d\n", big_heap.top()); big_heap.push(1000); printf("big_heap.top = %d\n", big_heap.top()); for (int i = 0; i &lt; 3; i++) &#123; big_heap.pop(); &#125; printf("big_heap.top = %d\n", big_heap.top()); printf("big_heap.size = %d\n", big_heap.size()); return 0;&#125; 例6： LeetCode 215. Kth Largest Element in an Array 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1:输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2:输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 思路：维护一个K大小的最小堆，堆中元素个数小于K时，新元素之间进入堆；否则，当新元素大于堆顶时，弹出堆顶，加入新元素，形成新堆。时间复杂度：O(nlogk) 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q; for (int i = 0; i &lt; nums.size(); i++) &#123; if (Q.size() &lt; k) &#123; Q.push(nums[i]); &#125; else &#123; if (Q.top() &lt; nums[i]) &#123; Q.pop(); Q.push(nums[i]); &#125; &#125; &#125; return Q.top(); &#125;&#125;;int main() &#123; std::vector&lt;int&gt; nums; nums.push_back(3); nums.push_back(2); nums.push_back(1); nums.push_back(5); nums.push_back(6); nums.push_back(4); Solution solve; printf("%d\n", solve.findKthLargest(nums, 2)); return 0;&#125; 例7：LeetCode 295. Find Median from Data Stream 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。例如，[2,3,4] 的中位数是 3[2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构：void addNum(int num) - 从数据流中添加一个整数到数据结构中。double findMedian() - 返回目前所有元素的中位数。 示例：addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3)findMedian() -&gt; 2 进阶:如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？ 思路：使用两个堆来实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MedianFinder &#123;public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; if (big_queue.empty()) &#123; big_queue.push(num); return; &#125; if (big_queue.size() == small_queue.size()) &#123; if (num &lt; big_queue.top()) big_queue.push(num); else small_queue.push(num); &#125; else if (big_queue.size() &gt; small_queue.size()) &#123; if (num &gt; big_queue.top()) small_queue.push(num); else &#123; int temp = big_queue.top(); big_queue.pop(); big_queue.push(num); small_queue.push(temp); &#125; &#125; else &#123; if (num &lt; small_queue.top()) big_queue.push(num); else &#123; int temp = small_queue.top(); small_queue.pop(); small_queue.push(num); big_queue.push(temp); &#125; &#125; &#125; double findMedian() &#123; if (big_queue.size() == small_queue.size()) return (big_queue.top() + small_queue.top()) / 2.0; else if (big_queue.size() &gt; small_queue.size()) return big_queue.top(); else return small_queue.top(); &#125;private: priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small_queue; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; big_queue;&#125;;int main() &#123; MedianFinder M; int test[] = &#123;6, 10, 1, 7, 99, 4, 33&#125;; for (int i = 0; i &lt; 7; i++) &#123; M.addNum(test[i]); printf("%.3lf\n", M.findMedian()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS和BFS的一个应用]]></title>
    <url>%2Fpost%2F5bf81e17.html</url>
    <content type="text"><![CDATA[视频：https://www.bilibili.com/video/av36288901 1.题目：LeetCode 207.Course Schedule 现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1:输入: 2, [[1,0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。示例 2:输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 说明:输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。 2.思路： n个课程，m个依赖关系，可以看成有向图，是否可以全部完成，就是看是否有环，有环不能完成，无环可以完成。用深搜或者宽搜都行深搜：如果正在搜索的某节点（还未退出该节点的递归深搜）又回到了该节点，即证明图有环宽搜：将入度为0的节点放入队列，完成搜索取出，该节点所指向的所有节点都入读减1，入度为0添加到队列，完成搜索取出，如果最后队列为空则无环，否则有环 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115struct GraphNode &#123; // 图的节点邻接表表示 int label; vector&lt;GraphNode *&gt; neighbors; // 默认都是NULL GraphNode(int x) :label(x) &#123;&#125;&#125;;class Solution &#123;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;GraphNode *&gt; graph; vector&lt;int&gt; visit; // visit:-1表示没有访问过，0表示正在访问，1表示已经访问过了 // 构造链接表图 for (int i = 0; i &lt; numCourses; i++) &#123; graph.push_back(new GraphNode(i)); visit.push_back(-1); &#125; for (int i = 0; i &lt; prerequisites.size(); i++) &#123; GraphNode* begin = graph[prerequisites[i][1]]; GraphNode* end = graph[prerequisites[i][0]]; begin-&gt;neighbors.push_back(end); &#125; for (int i = 0; i &lt; graph.size(); i++) &#123; if (visit[i] == -1 &amp;&amp; !DFS_graph(graph[i], visit)) &#123; return false; &#125; &#125; for (int i = 0; i &lt; numCourses; i++) &#123; delete graph[i]; &#125; return true; &#125;private: bool DFS_graph(GraphNode *node, vector&lt;int&gt; &amp;visit) &#123; visit[node-&gt;label] = 0; for (int i = 0; i &lt; node-&gt;neighbors.size(); i++) &#123; if (visit[node-&gt;neighbors[i]-&gt;label] == -1) &#123; if (DFS_graph(node-&gt;neighbors[i], visit) == 0) &#123; return false; &#125; &#125; else if (visit[node-&gt;neighbors[i]-&gt;label] == 0) &#123; return false; &#125; &#125; visit[node-&gt;label] = 1; return true; &#125;&#125;;class Solution1 &#123;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;GraphNode *&gt; graph; vector&lt;int&gt; degree; for (int i = 0; i &lt; numCourses; i++) &#123; degree.push_back(0); graph.push_back(new GraphNode(i)); &#125; for (int i = 0; i &lt; prerequisites.size(); i++) &#123; GraphNode *begin = graph[prerequisites[i][1]]; GraphNode *end = graph[prerequisites[i][0]]; begin-&gt;neighbors.push_back(end); degree[prerequisites[i][0]]++; &#125; queue&lt;GraphNode *&gt; Q; for (int i = 0; i &lt; numCourses; i++) &#123; if (degree[i] == 0) Q.push(graph[i]); &#125; while (!Q.empty()) &#123; GraphNode *node = Q.front(); Q.pop(); for (int i = 0; i &lt; node-&gt;neighbors.size(); i++) &#123; degree[node-&gt;neighbors[i]-&gt;label]--; if (degree[node-&gt;neighbors[i]-&gt;label] == 0) Q.push(node-&gt;neighbors[i]); &#125; &#125; for (int i = 0; i &lt; graph.size(); i++) &#123; delete graph[i]; &#125; for (int i = 0; i &lt; degree.size(); i++) &#123; if (degree[i]) return false; &#125; return true; &#125;&#125;;int main() &#123; vector&lt;vector&lt;int&gt; &gt; prerequisites; vector&lt;int&gt; t1; t1.push_back(1); t1.push_back(0); prerequisites.push_back(t1); vector&lt;int&gt; t2; t2.push_back(2); t2.push_back(0); prerequisites.push_back(t2); vector&lt;int&gt; t3; t3.push_back(3); t3.push_back(1); prerequisites.push_back(t3); vector&lt;int&gt; t4; t4.push_back(3); t4.push_back(2); prerequisites.push_back(t4); //Solution solve; Solution1 solve; printf("%d\n", solve.canFinish(4, prerequisites)); return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chap1_LinkedList]]></title>
    <url>%2Fpost%2F60f57c72.html</url>
    <content type="text"><![CDATA[视频：https://www.bilibili.com/video/av36288901 第一节：链表1. 数据结构12345struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; 2. 例题例1. LeetCode 206. Reverse Linked List 反转一个单链表。(不使用额外空间)示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路：头插法 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *new_head = NULL; while (head) &#123; ListNode *next = head-&gt;next; head-&gt;next = new_head; new_head = head; head = next; &#125; return new_head; &#125;&#125;;int main() &#123; ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; Solution solve; ListNode *head = &amp;a; printf("Before reverse:\n"); while (head) &#123; printf("%d\n", head-&gt;val); head = head-&gt;next; &#125; head = solve.reverseList(&amp;a); printf("After reverse:\n"); while (head) &#123; printf("%d\n", head-&gt;val); head = head-&gt;next; &#125; return 0;&#125; 例2：LeetCode 92. Reverse Linked List II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度。 示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 思路：保存逆置段头节点前驱pre_head，逆置段尾节点modify_list_tail，然后进行连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; int change_len = n - m + 1; ListNode *pre_head = NULL; // 开始逆置节点的前驱 ListNode *result = head; while (head &amp;&amp; --m) &#123; // head 向前移动m-1个位置，pre_head指向开始逆置节点的前驱 pre_head = head; head = head-&gt;next; // head 指向开始逆置的节点 &#125; ListNode* modify_list_tail = head; // mlt指向当前的head，即逆置后链表尾 ListNode* new_head = NULL; while (head &amp;&amp; change_len) &#123; // 该部分和上面链表逆置一样，head最后指向n的后继 ListNode* next = head-&gt;next; head-&gt;next = new_head; new_head = head; head = next; change_len--; &#125; modify_list_tail-&gt;next = head; if (pre_head) &#123; // 如果pre_head不空，说明不是从第一个节点开始逆置的，空表明m=1； pre_head-&gt;next = new_head; &#125; else &#123; result = new_head; &#125; return result; &#125;&#125;;int main() &#123; ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; Solution solve; ListNode *head = solve.reverseBetween(&amp;a, 2, 4); while (head) &#123; printf("%d\n", head-&gt;val); head = head-&gt;next; &#125; return 0;&#125; 例3：LeetCode 160.Intersection of Two LinkedLists 编写一个程序，找到两个单链表相交的起始节点。要求：不能破坏原来链表结构，链表没有环，时间复杂度O(n)，空间复杂度O(1) 思路：用set容器/用较长的链表减去较短的链表，相同的部分同时遍历，第一个相同的点即为所求点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; // 用set容器public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; set&lt;ListNode*&gt; st; while (headA) &#123; st.insert(headA); headA = headA-&gt;next; &#125; while (headB) &#123; if (st.find(headB) != st.end()) &#123; return headB; &#125; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;;int get_list_length(ListNode *head) &#123; // 求链表长度 int len = 0; while (head) &#123; len++; head = head-&gt;next; &#125; return len;&#125;ListNode *forward_long_list(int long_len, int short_len, ListNode *head) &#123; // head指向相同长度部分 int delta = long_len - short_len; while (head &amp;&amp; delta) &#123; head = head-&gt;next; delta--; &#125; return head;&#125;class Solution1 &#123; // 用指针指向元素比较public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int list_A_len = get_list_length(headA); int list_B_len = get_list_length(headB); if (list_A_len &gt; list_B_len) &#123; headA = forward_long_list(list_A_len, list_B_len, headA); &#125; else &#123; headB = forward_long_list(list_B_len, list_A_len, headB); &#125; while (headA &amp;&amp; headB) &#123; if (headA == headB) &#123; return headA; &#125; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;;int main() &#123; ListNode a1(1); ListNode a2(2); ListNode b1(3); ListNode b2(4); ListNode b3(5); ListNode c1(6); ListNode c2(7); ListNode c3(8); a1.next = &amp;a2; a2.next = &amp;c1; c1.next = &amp;c2; c2.next = &amp;c3; b1.next = &amp;b2; b2.next = &amp;b3; b3.next = &amp;c1; Solution1 solve; ListNode *result = solve.getIntersectionNode(&amp;a1, &amp;b1); printf("%d\n", result-&gt;val); return 0;&#125; 例4：LeetCode 142. Linked List Cycle II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。 示例 1：输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 思路： set容器 快慢指针：fast指针是slow指针速度的两倍，相遇时节点为meet，那么一个从头节点出发，一个从meet出发，相遇时即为环开始时位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode *&gt; node_set; while (head) &#123; if (node_set.find(head) != node_set.end()) &#123; return head; &#125; node_set.insert(head); head = head-&gt;next; &#125; return NULL; &#125;&#125;;class Solution1 &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode* slow = head; ListNode* fast = head; ListNode* meet = NULL; while (fast) &#123; fast = fast-&gt;next; slow = slow-&gt;next; if (!fast) return NULL; fast = fast-&gt;next; if (fast == slow) &#123; meet = fast; break; &#125; &#125; if (meet == NULL) return NULL; // 如果没有相遇，表明没有环 while (meet &amp;&amp; head) &#123; if (head == meet) return head; head = head-&gt;next; meet = meet-&gt;next; &#125; return NULL; &#125;&#125;;int main() &#123; ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); ListNode f(6); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; e.next = &amp;f; f.next = &amp;c; // Solution solve; Solution1 solve; ListNode *node = solve.detectCycle(&amp;a); if (node) &#123; printf("%d\n", node-&gt;val); &#125; else &#123; printf("NULL\n"); &#125; return 0;&#125; 例5：LeetCode 86.Partition List 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。 示例:输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 思路：用俩个零时头节点将大于/小于x的节点放入这两个链表中ListNode less_head(0);ListNode more_head(0);ListNode less_ptr = &less_head;ListNode more_ptr = &more_head;less_ptr始终指向小链表尾部，动态移动more_ptr始终指向大链表尾部，动态移动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode less_head(0); ListNode more_head(0); ListNode* less_ptr = &amp;less_head; ListNode* more_ptr = &amp;more_head; while (head) &#123; if (head-&gt;val &lt; x) &#123; less_ptr-&gt;next = head; less_ptr = less_ptr-&gt;next; &#125; else &#123; more_ptr-&gt;next = head; more_ptr = more_ptr-&gt;next; &#125; head = head-&gt;next; &#125; less_ptr-&gt;next = more_head.next; more_ptr-&gt;next = NULL; return less_head.next; &#125;&#125;;int main() &#123; ListNode a(1); ListNode b(4); ListNode c(3); ListNode d(2); ListNode e(5); ListNode f(2); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; e.next = &amp;f; Solution solve; ListNode *head = solve.partition(&amp;a, 3); while (head) &#123; printf("%d\n", head-&gt;val); head = head-&gt;next; &#125; return 0;&#125; 例6：LeetCode 138.Copy List with Random Pointer 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深拷贝。 思路：巧用数据结构map:将原地址与节点位置做映射 node_mapvector:根据节点位置将新链表节点存入其中 node_vec 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node() &#123;&#125; Node(int _val, Node* _next, Node* _random) &#123; val = _val; next = _next; random = _random; &#125;&#125;;class Solution &#123;public: Node* copyRandomList(Node* head) &#123; map&lt;Node*, int&gt; node_map; // 将原地址与节点位置做映射 vector&lt;Node *&gt; node_vec; // 根据节点位置将新链表节点存入其中 // 第一步：一个while循环将原节点地址与位置做映射，将新节点按照源节点位置push到node_vec中 Node* ptr = head; int i = 0; while (ptr) &#123; node_vec.push_back(new Node(ptr-&gt;val)); node_map[ptr] = i; ptr = ptr-&gt;next; i++; &#125; node_vec.push_back(0); // 链表最后一个节点的next为NULL； ptr = head; i = 0; while (ptr) &#123; node_vec[i]-&gt;next = node_vec[i + 1]; if (ptr-&gt;random) &#123; int id = node_map[ptr-&gt;random]; node_vec[i]-&gt;random = node_vec[id]; &#125; ptr = ptr-&gt;next; i++; &#125; return node_vec[0]; &#125;&#125;;int main()&#123; RandomListNode a(1); RandomListNode b(2); RandomListNode c(3); RandomListNode d(4); RandomListNode e(5); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; a.random = &amp;c; b.random = &amp;d; c.random = &amp;c; e.random = &amp;d; Solution solve; RandomListNode *head = solve.copyRandomList(&amp;a); while(head)&#123; printf("label = %d ", head-&gt;label); if (head-&gt;random)&#123; printf("rand = %d\n", head-&gt;random-&gt;label); &#125; else&#123; printf("rand = NULL\n"); &#125; head = head-&gt;next; &#125; return 0;&#125; 例7：LeetCode 21.Merge Two Sorted Lists 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路：很简单，比较两个链表节点值大小，小的先放，大的后放。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode temp_head(0); ListNode* pre = &amp;temp_head; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; pre = pre-&gt;next; &#125; if (l1) &#123; pre-&gt;next = l1; &#125; if (l2) &#123; pre-&gt;next = l2; &#125; return temp_head.next; &#125;&#125;;int main() &#123; ListNode a(1); ListNode b(4); ListNode c(6); ListNode d(0); ListNode e(5); ListNode f(7); a.next = &amp;b; b.next = &amp;c; d.next = &amp;e; e.next = &amp;f; Solution solve; ListNode *head = solve.mergeTwoLists(&amp;a, &amp;d); while (head) &#123; printf("%d\n", head-&gt;val); head = head-&gt;next; &#125; system("pause"); return 0;&#125; 例8：LeetCode 23.Merge k Sorted Lists 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度. 示例:输入:12345[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6] 输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路： k个链表按照次序合并k-1次，O(n*k^2) 将k*n个节点放入vector中，再排序，O(knlog(kn)) 对k个链表分治，两两进行合并，O(knlogk) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode temp_head(0); ListNode* pre = &amp;temp_head; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; pre = pre-&gt;next; &#125; if (l1) &#123; pre-&gt;next = l1; &#125; if (l2) &#123; pre-&gt;next = l2; &#125; return temp_head.next;&#125;bool cmp(const ListNode* a, const ListNode* b) &#123; return a-&gt;val &lt; b-&gt;val;&#125;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; vector&lt;ListNode*&gt; node_vec; for (int i = 0; i &lt; lists.size(); i++) &#123; ListNode *head = lists[i]; while (head) &#123; node_vec.push_back(head); head = head-&gt;next; &#125; &#125; if (node_vec.size() == 0) return NULL; sort(node_vec.begin(), node_vec.end(), cmp); for (int i = 1; i &lt; node_vec.size(); i++) &#123; node_vec[i - 1]-&gt;next = node_vec[i]; &#125; node_vec[node_vec.size() - 1] = NULL; return node_vec[0]; &#125;&#125;;class Solution1 &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.size() == 0) return NULL; if (lists.size() == 1) return lists[0]; if (lists.size() == 2) return mergeTwoLists(lists[0], lists[1]); int mid = lists.size() / 2; vector&lt;ListNode*&gt; sub1_lists; vector&lt;ListNode*&gt; sub2_lists; for (int i = 0; i &lt; mid; i++) &#123; sub1_lists.push_back(lists[i]); &#125; for (int i = mid; i &lt; lists.size(); i++) &#123; sub2_lists.push_back(lists[i]); &#125; ListNode *l1 = mergeKLists(sub1_lists); ListNode *l2 = mergeKLists(sub2_lists); return mergeTwoLists(l1, l2); &#125;&#125;;int main() &#123; ListNode a(1); ListNode b(4); ListNode c(6); ListNode d(0); ListNode e(5); ListNode f(7); ListNode g(2); ListNode h(3); a.next = &amp;b; b.next = &amp;c; d.next = &amp;e; e.next = &amp;f; g.next = &amp;h; // Solution solve; Solution1 solve; std::vector&lt;ListNode *&gt; lists; lists.push_back(&amp;a); lists.push_back(&amp;d); lists.push_back(&amp;g); ListNode *head = solve.mergeKLists(lists); while (head) &#123; printf("%d\n", head-&gt;val); head = head-&gt;next; &#125; return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv实现图片二值化]]></title>
    <url>%2Fpost%2Fb7214e7b.html</url>
    <content type="text"><![CDATA[利用openCV来实现图像二值化，主要利用的函数有 cv2.threshold，cv2.adaptiveThreshold 等，具体内容如下： 1. 代码及其解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import cv2 as cvimport numpy as npimport matplotlib.pyplot as plt# 二值图像就是将灰度图转化成黑白图，没有灰，在一个值之前为黑，之后为白# 有全局和局部两种# 在使用全局阈值时，我们就是随便给了一个数来做阈值，那我们怎么知道我们选取的这个数的好坏呢？答案就是不停的尝试。# 如果是一副双峰图像（简 单来说双峰图像是指图像直方图中存在两个峰）呢？# 我们岂不是应该在两个峰之间的峰谷选一个值作为阈值？这就是 Otsu 二值化要做的。# 简单来说就是对 一副双峰图像自动根据其直方图计算出一个阈值。# （对于非双峰图像，这种方法 得到的结果可能会不理想）。def threshold_demo(image): gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY) # 这个函数的第一个参数就是原图像，原图像应该是灰度图。 # 第二个参数就是用来对像素值进行分类的阈值。 # 第三个参数就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值 # 第四个参数来决定阈值方法，见threshold_simple() # ret, binary = cv.threshold(gray, 127, 255, cv.THRESH_BINARY) ret, binary = cv.threshold(gray, 127, 255, cv.THRESH_BINARY | cv.THRESH_OTSU) print("threshold value: %s"%ret) cv.imshow("threshold_demo", binary)def threshold_simple(image): img = cv.cvtColor(image, cv.COLOR_BGR2GRAY) ret, thresh1 = cv.threshold(img, 127, 255, cv.THRESH_BINARY) ret, thresh2 = cv.threshold(img, 127, 255, cv.THRESH_BINARY_INV) ret, thresh3 = cv.threshold(img, 127, 255, cv.THRESH_TRUNC) ret, thresh4 = cv.threshold(img, 127, 255, cv.THRESH_TOZERO) ret, thresh5 = cv.threshold(img, 127, 255, cv.THRESH_TOZERO_INV) titles = ['Original Image', 'BINARY', 'BINARY_INV', 'TRUNC', 'TOZERO', 'TOZERO_INV'] images = [img, thresh1, thresh2, thresh3, thresh4, thresh5] for i in range(6): plt.subplot(2, 3, i + 1), plt.imshow(images[i], 'gray') # 将图像按2x3铺开 plt.title(titles[i]) plt.xticks([]), plt.yticks([]) plt.show()# 在前面的部分我们使用是全局阈值，整幅图像采用同一个数作为阈值。# 当时这种方法并不适应与所有情况，尤其是当同一幅图像上的不同部分的具有不同亮度时。# 这种情况下我们需要采用自适应阈值。此时的阈值是根据图像上的 每一个小区域计算与其对应的阈值。# 因此在同一幅图像上的不同区域采用的是不同的阈值，从而使我们能在亮度不同的情况下得到更好的结果。# 这种方法需要我们指定三个参数，返回值只有一个# _MEAN_C：阈值取自相邻区域的平均值,_GAUSSIAN_C：阈值取值相邻区域 的加权和，权重为一个高斯窗口。# Block Size - 邻域大小（用来计算阈值的区域大小）。# C - 这就是是一个常数，阈值就等于的平均值或者加权平均值减去这个常数。def threshold_adaptive(image): img = cv.cvtColor(image, cv.COLOR_BGR2GRAY) # 中值滤波 img = cv.medianBlur(img,5) ret, th1 = cv.threshold(img, 127, 255, cv.THRESH_BINARY) # 11 为 Block size, 2 为 C 值 th2 = cv.adaptiveThreshold(img, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 11, 2) th3 = cv.adaptiveThreshold(img,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2) titles = ['Original Image', 'Global Threshold (v = 127)', 'Adaptive Mean Threshold', 'Adaptive Gaussian Threshold'] images = [img, th1, th2, th3] for i in range(4): plt.subplot(2, 2, i + 1), plt.imshow(images[i], 'gray') plt.title(titles[i]) plt.xticks([]), plt.yticks([]) plt.show()def threshold_custom(image): gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY) h, w = gray.shape[:2] m = np.reshape(gray, [1, w*h]) mean = m.sum() / (w*h) # 求出整个灰度图像的平均值 print("mean:", mean) ret, binary = cv.threshold(gray, mean, 255, cv.THRESH_BINARY) cv.imshow("threshold_custom", binary)def main(): img = cv.imread("02.jpg") # threshold_demo(img) # threshold_simple(img) # threshold_adaptive(img) threshold_custom(img) cv.waitKey(0) # 等有键输入或者1000ms后自动将窗口消除，0表示只用键输入结束窗口 cv.destroyAllWindows() # 关闭所有窗口if __name__ == '__main__': main() 2. 结果如下： threshold_demo threshold_simple threshold_adaptive threshold_custom]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>openCV</tag>
        <tag>图像二值化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中文标题打不开博客]]></title>
    <url>%2Fpost%2F960616a.html</url>
    <content type="text"><![CDATA[hexo 中文博客打不开问题&emsp;&emsp;Hexo默认的链接是http://betterming.github.io/2019/02/06/HelloWorld 类型的，在站点目录下的配置_config.yml里的配置:permalink: :year/:month/:day/:title/。这种配置的缺点就是一般文件名是中文，导致url链接里有中文出现，这会造成中文博客可能打不开，也不利于seo。这里提供一种解决方案。 step1:安装hexo-abbrlink这个插件1npm install hexo-abbrlink --save step2:修改站点配置文件_config.yml12345permalink: post/:abbrlink.html# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 参考链接 https://blog.csdn.net/yanzi1225627/article/details/77761488]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>permalink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理]]></title>
    <url>%2Fpost%2F73dedef0.html</url>
    <content type="text"><![CDATA[1. 海量数据处理的案例类型查询： 关于重复项的处理：（海量）数据的判重、取重、去重； 统计： （海量）数据的出现频度；排序： （海量）数据的排序； （海量）数据的前K个最大（小）数； 解题策略中的关键问题: 1、存储什么？如何存储一组数据；（选择数据结构）2、如何解决问题？（选择算法） 2. 可以采用的数据结构 线性结构： 顺序表：一般的顺序表,字符串,BitMap 链表： 树状结构： 二叉树：BST、红黑树 B树 Trie树 扩展的结构：hash表,B+树 3. 可以采用的算法3.1 查找 应用场景：在某数据集合中查找指定的目标项.(隐含：待查找的目标项必须是已知的！) 基于Hash表的查找： 蛮力查找（顺序查找）：线性表 基于有序表的二分查找：有序的顺序表 字符串的查找：朴素查找、KMP算法、BM算 基于树的查找：遍历 二叉查找树BST：中序遍历 Trie树：层次遍历 基于红黑树：STL SET,STL Map 3.2 排序 基于比较操作的排序算法：平均时间复杂度≥O(Nlog2N) 交换排序：两两比较待排序记录的关键字，如果逆序就进行交换，直到所有记录都排好序为止。 冒泡排序 快速排序（分区交换排序） 选择排序（Selection Sort）的基本思想是：不断从待排记录序列中选出关键字最小的记录放到已排序记录序列的后面，直到n个记录全部插入已排序记录序列中。 简单选择排序 堆排序（树型选择排序） 插入排序：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子表中的适当位置，直到全部记录插入完成为止。 直接插入排序 折半插入排序 希尔排序 应用场景：对于某顺序表，按照指定的KEY进行整体排序(隐含：待排序的集合已全部存储在内存中；且各条记录的KEY必须是已知的！) 4. 案例4.1 案例–统计案例：有一个1G大小的文件，该文件中每一行是一个单词，每个单词的大小不超过16个字节，内存限制大小是1M。统计各个单词的出现频率。分析： 将1G文件划分为多个1M的文件；每次只统计1M的文件中单词频度。 (1) Q：如何统计1M的文件中单词频度？ 设计思路1：依次读入文件的每个单词，并查询在内存中是否存在与该单词匹配的项。若查询到匹配项，则意味着该单词重复出现了，因而只需更改该单词对应的计数值；否则，将该单词插入到内存对应的数据结构中。（基本操作为：查询和插入操作） 设计思路2：直接将文件中每个单词读入内存，然后对内存中的单词进行排序，最后进行词频统计。（基本操作为：排序、比较操作） (2) 假设单词文件大小F，假定每个单词的平均长度为le，那么单词数量为N=F/le。现对单词频度进行统计，那么 采用Trie树，结合设计思路1，平均性能为$O(N*le)$ ； 采用红黑树，结合设计思路1，平均性能为：$O(N*log2N)$； 采用红黑树时，可直接利用STL中的map技术:STL map&lt;string,int&gt; 采用hash表，结合设计思路1，平均性能为：O(N*每个槽上的线性表的平均长度)； 采用hash表时，可直接利用STL中的hash_map技术:STL hash_map&lt;string,int&gt; 采用线性结构，结合设计思路2。先排序，再相邻单词的相互比较来统计单词频度，平均性能为：$O(N*log_2N)+O(N)=O(N*log_2N)$。 (3) 算法设计思路 思路1:双层桶划分+ trie树/hash表/红黑树 Step1：将1G的大文件划分为若干个小文件，每个小文件不超过1M；利用Hash技术：读取文件F，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为F0,F1,…F4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的每个小文件Fi的大小都不超过1M。 Step2:对每个小文件Fi中的词的出现频率进行统计。采用trie树/hash表。 Step3：合并各个小文件的统计结果。 思路2:采用云计算的架构，MapReduce )(分布式处理：比如 hadoop) MAP ：将1G的大文件划分为若干个小文件，每个小文件不超过1M； 利用Hash技术：读取文件，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为F0,F1,…F4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 Reduce:对每个小文件Fi中的词的出现频率进行统计，最后合并各个小文件的统计结果。 采用trie树/hash表/红黑树，对每个小文件中的词的出现频率进行统计。 思路3:线性结构+直接排序法 内存不能超过1M，而单词文件的大小为1G。因此采用顺序表存储单词文件，并利用外排序的方法来进行排序。采用归并排序，时间复杂度O(Nlog2N)。 排完序之后，再对已经有序的多个文件进行遍历，统计每个单词出现的次数，再次写入文件中。 总结：理论上的时间复杂度分析：归并排序的时间复杂度是O(Nlog2N)，而遍历线性表进行单词频度统计的时间复杂度是O(N)，因此该算法的总体时间复杂度就是O(Nlog2N)。但是，实际上，采用归并排序进行外排序，每个单词需要I/O不止一次，而I/O操作属于耗时操作，因此该算法的实际时间开销的数量级远不止O(Nlog2N) 4.2 案例–排序案例1：100w个数中找最大的前100个数。（假设内存开销无限制） (1) 算法设计思路1：采用局部淘汰法 选取前100个元素，并按降序进行排序，记为序列L。依此扫描剩余的元素，并与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。 时间复杂度$T(n)=O(100*log_2100) +O((100w-100)*100)$。 (2) 算法设计思路2：利用堆排序 利用100w个数的前100个数构造一个小根堆；遍历其他的数，分别与堆的根元素进行对比：若大于根，则用该元素替换旧根，作为堆的新根，重新维护保持堆的性质；否则，不处理。 时间复杂度:$T(n)= O(100*log_2100) + O((100w-100)*log_2100)= O(100w*log_2100)$。 案例2：寻找热门查询：&emsp;&emsp;搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1GB。 请描述你解决这个问题的思路； 请给出主要的处理流程，算法，以及算法的复杂度。 (1) 问题分析：要统计最热门查询，首先就是要统计每个Query出现的次数，然后根据统计结果，找出Top 10。 第一步：Query统计设计思路1：顺序表+直接排序法设计思路2：采用Hash表 第二步：找出Top 10 (2) 设计思路 设计思路1：顺序表+直接排序法 内存不能超过1G，而一千万条记录，每条记录是225Byte，很显然要占据2.55G内存。因此采用外排序的方法来进行排序（采用归并排序，时间复杂度O(Nlog2N)。 排完序之后我们再对已经有序的Query文件进行遍历，统计每个Query出现的次数，再次写入文件中。 总结：排序的时间复杂度是O(Nlog2N)，而遍历的时间复杂度是O(N)，因此该算法的总体时间复杂度就是O(Nlog2N)。 设计思路2: 利用Hash Table 采用Hash Table。 虽然有一千万个Query，但是由于重复度比较高，事实上只有300万的Query，而每个Query255Byte，因此我们可以考虑把他们都放进1GB内存中去。（3*106*255B&lt;1GB) 采用Hash Table绝对是我们优先的选择，因为Hash Table的查询速度非常的快，几乎是O(1)的时间复杂度。 维护一个Key为Query字串，Value为该Query出现次数的Hash表，每次读取一个Query，如果该字串不在Hash表中，那么加入该字串，并且将Value值设为1；如果该字串在Hash表中，那么将该字串的计数加1即可。 T(n)=O(N*每个槽上的线性表的平均长度) 。 相比于设计思路1：在时间复杂度上提高了一个数量级，但不仅仅是时间复杂度上的优化，该方法只需要I/O数据文件一次，而设计思路1的I/O次数较多的，因此该算法比设计思路1在工程上有更好的可操作性。 第二步：找出Top 10（按照Query的出现频度）设计思路1：内部排序时间复杂度$T(n)=nlog_2n$(三百万条记录可以放在1G内存中）设计思路2：采用局部淘汰法时间复杂度$T(n)=O(10*log_210) +O((n-10)*10)$。设计思路3：利用堆时间复杂度$T(n)= O(10*log_210) + O((n-10)*log_210)$。 4.3. 案例——关于重复项的处理案例1： A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4GB，要求找出A,B文件中共同的URL。(1) 方案1：分而治之+基于hash表的查找 可以估计每个文件的大小为5G×64=320GB，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0 vs..b0,a1 vs. b1,…,a999 vs. b999）中，不对应的小文件不可能有相同的url。 分别计算出1000对小文件中相同的url，再进行汇总。 采用Hash表，可以直接利用STL Hash_set。 对于每1对小文件(ai,bi)，把小文件ai的url存储到hash表中，然后遍历另一个小文件bi中的每个url，查询其是否在刚才构建的hash表中，如果是，那么就是共同的url。 (2) 方案2：若允许有一定的错误率，可采用Bloom filter,Bloom filter是BitMap的扩展。 若直接采用BitMap。那么：可用内存4GB=4*1024*1024*1024*8b≈340亿bit。由于每条URL占用64字节，即每个URL对应的整数可以用log2(25664)bit=864bit&gt;340亿bit来描述。因而不能用BitMap。 Bloom filter：通过极少的错误换取了存储空间的极大节省。将每条url使用Bloom filter映射为这340亿bit中的k个bit，并将这k个bit置为1。 将文件a中的每条url使用Bloom filter映射为这340亿bit；然后依次读取文件b中的每条url，检查其Bloom filter映射的k比特是否都为1，如果是，那么该url应该是两个文件共同的url（注意：会有一定的错误率）。 案例2：2.5亿个整数中找出不重复的整数，内存空间不足以容纳这2.5亿个整数。 (1) 方案1：假设2.5亿个整数的取值范围为[0,250000000)。那么，采用Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需0.5G bits，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。扫描结束后，查看bitmap，把对应位是01的整数输出即可。 (2) 方案2：也可采用与第1题类似的方法，先将大文件划分为小文件。然后在小文件中找出不重复的整数，并排序。最后进行归并，注意去除重复的元素。 本文内容来自余老师上课PPT]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>BitMap</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2Fpost%2Fc2a5fdc5.html</url>
    <content type="text"><![CDATA[堆排序过程及代码实现 1. 堆排序概念堆是具有如下性质的二叉树： 1）任何节点的值都≤（≥）其子节点的值，即 堆的根节点中存放最小（大）元素；2）最多在两层上具有叶子节点，其中最底层的叶子节点尽可能的靠左分布。隐含：含有n 个节点的堆，所有节点到根节点的距离都不超 过log2n。（类似 完全二叉树） 堆可以用数组来按序号存储，即从上到下，从左到右存储，按照层序遍历存储 堆排序概念： 树型选择排序 特点：T(n)=O(nlog2n)，实际运行时间比快速排序慢些; 是一种良好的通用排序算法，不存在最坏情况。（希尔排序也是一种良好的通用排序算法，T(n)=O(n1.25) ） 数据结构：堆——实质上是一棵二叉树；基本操作：siftup：当在堆的尾部插入新元素后，需重新获取堆性质。siftdown：用新元素替换堆中的旧根后，需重新获取堆性质。 2. 例题也是余老师布置的作业。请采用堆排序将关键字序列{3,2,1,4,5,6,7,10,9,8}排序，并写出各步的具体操作，并记录总的比较次数和总的交换次数。要求利用siftup函数创建初始大根堆，利用siftdown1函数依次提取根结点生成有序序列。答：(1) 具体操作如下： (2)代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int x[11] = &#123;0, 3, 2, 1, 4, 5, 6, 7, 10, 9, 8&#125;;int up1=0, up2=0, down1=0, down2=0;// 记录siftup比较、交换次数和siftdown比较交换次数void siftup(int u)&#123; int i, p; i = u; for(;;)&#123; if(i == 1) break; p = i/2; up1++; if(x[p] &gt;= x[i]) break; swap(x[p], x[i]); up2++; i = p; &#125;&#125;void siftdown1(int l, int u)&#123; int i, c; i = l; for(;;)&#123; c = 2*i; if(c &gt; u) break; if(c + 1 &lt;= u)&#123; down1++; if(x[c+1] &gt; x[c]) c++; &#125; down1++; if(x[i] &gt; x[c]) break; swap(x[i], x[c]); down2++; i = c; &#125;&#125;int main()&#123; for(int j = 2; j &lt;= 10; j++) siftup(j); printf("siftup后序列为：\n"); for(int i = 1; i &lt; 11; i++) printf("%d ", x[i]); printf("\n"); printf("siftup比较次数：%d\nsiftup交换次数：%d\n", up1, up2); for(int i = 10; i &gt;= 2; i--) &#123; swap(x[1], x[i]); siftdown1(1, i-1); &#125; printf("堆排序后序列：\n"); for(int i = 1; i &lt; 11; i++) printf("%d ", x[i]); printf("\n"); printf("siftdown比较次数：%d\nsiftdown交换次数：%d\n", down1, down2); return 0;&#125; (3) 结果如下：12345678siftup后序列为：10 9 6 7 8 1 5 2 4 3siftup比较次数：18siftup交换次数：14堆排序后序列：1 2 3 4 5 6 7 8 9 10siftdown比较次数：24siftdown交换次数：11]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL]]></title>
    <url>%2Fpost%2F1d92c98c.html</url>
    <content type="text"><![CDATA[AVL树c++实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct node // node&#123; int v, height; // 当前节点子树的高度，本身为1 node *lchild, *rchild;&#125;;// 生成一个新节点，节点值为vnode *newNode(int v)&#123; node* Node = new node; Node-&gt;height = 1; Node-&gt;v = v; Node-&gt;lchild = Node-&gt;rchild = NULL; return Node;&#125;// 获得树的高度，即根节点所在子树高度int getHeight(node* root)&#123; if(root == NULL) return 0; return root-&gt;height;&#125;// 获取平衡因子int getBalanceFactor(node* root)&#123; return getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild);&#125;// 更新节点root的高度void updateHeight(node* root)&#123; root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + 1;&#125;//AVL的基本操作：查找，插入，删除//查找void search(node* root, int x)&#123; if(root == NULL) &#123; printf("Search Failed!\n"); return; &#125; if(root-&gt;v == x) printf("%d\n", root-&gt;v); else if(root-&gt;v &gt; x) search(root-&gt;lchild, x); else search(root-&gt;rchild, x);&#125;//插入//R型，要左旋void LeftRotation(node* &amp;root)&#123; node* temp = root-&gt;rchild; root-&gt;rchild = temp-&gt;lchild; temp-&gt;lchild = root; updateHeight(root); updateHeight(temp); root = temp;&#125;//L型，要右旋void RightRotation(node* &amp;root)&#123; node* temp = root-&gt;lchild; root-&gt;lchild = temp-&gt;rchild; temp-&gt;rchild = root; updateHeight(root); updateHeight(temp); root = temp;&#125;/*四种树形的调整：1. LL型 BF(root)=2, BF(root-&gt;lchild)=1 对root右旋2. RR型 BF(root)=-2, BF(root-&gt;rchild)=-1 对root左旋3. LR型 BF(root)=2, BF(root-&gt;rchild)=-1 先对root-&gt;lchild左旋，再root右旋4. RL型 BF(root)=-2, BF(root-&gt;rchild)=1 先对root-&gt;rchild右旋，再root左旋 *///AVL树插入权值为v节点void insert(node* &amp;root, int v)&#123; if(root == NULL) &#123; root = newNode(v); return; &#125; if(v &lt; root-&gt;v)&#123; insert(root-&gt;lchild, v); updateHeight(root); if(getBalanceFactor(root) == 2) &#123; if(getBalanceFactor(root-&gt;lchild) == 1) RightRotation(root);//LL型 else if(getBalanceFactor(root-&gt;rchild) == -1) &#123; // LR型 LeftRotation(root-&gt;lchild); RightRotation(root); &#125; &#125; &#125; else&#123; insert(root-&gt;rchild, v); updateHeight(root); if(getBalanceFactor(root) == -2)&#123; if(getBalanceFactor(root-&gt;rchild) == -1) LeftRotation(root); //RR型 else if(getBalanceFactor(root-&gt;lchild) == 1) &#123;//RL型 RightRotation(root-&gt;rchild); LeftRotation(root); &#125; &#125; &#125;&#125;//创建AVL树node* Creat(int data[], int n)&#123; node* root = NULL; for(int i = 0; i &lt; n; i++)&#123; insert(root, data[i]); &#125; return root;&#125;void treeTraver(node* root)&#123; if(root == NULL) return; treeTraver(root-&gt;lchild); printf("height:%d, data:%d\n", root-&gt;height, root-&gt;v); treeTraver(root-&gt;rchild);&#125;int main()&#123; int data[7] = &#123;1, 8, 9, 2, 10, 4, 33&#125;; node* root = Creat(data, 7); treeTraver(root); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>AVL</tag>
        <tag>Traversal</tag>
        <tag>Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验3_图像特征匹配、跟踪与相机运动估计实验]]></title>
    <url>%2Fpost%2Fa008a0d9.html</url>
    <content type="text"><![CDATA[一、预备知识： 深度图像程序模型及坐标转换linux，C++编程基础，Cmake 编译器OpenCV 图像处理库 二、实验步骤：1. 环境准备,图优化算法库g2o的安装g2o 安装依赖如下：12sudo apt-get install libeigen3-dev libsuitesparse-dev libqt4-dev qt4-qmake libqglviewer-qt4-devsudo apt-get install cmake libeigen3-dev libsuitesparse-dev libqt4-dev qt4-qmake libqglviewer-dev 下载 g2o 源码：123456git clone https://github.com/RainerKuemmerle/g2o.gitmkdir buildcd buildcmake ../makesudo make install 在实验前需要安装好Eigen3,OpenCV等依赖库Eigen3安装步骤如下：官网下载 tar 包： http://eigen.tuxfamily.org/index.php?title=Main_Page执行如下命令：12sudo tar -xvjf /home/ljhong/share/ eigen-eigen-26667be4f70b.tar.bz2 -C /usr/local/includesudo mv /usr/local/include/eigen-eigen-26667be4f70b /usr/local/include/eigen3 安装好之后，在/usr/local/include 目录下有个 eigen3的文件 2. 实验代码下载有重新编译(1)下载实验附件代码https://github.com/gaoxiang12/slambook/tree/master/ch7(2)编译（如果eigen3是按照上面源码方式安装的，ch7文件夹里编译规则文件CMakeList.txt中的”usr/include/eigen3/”应改成每个同学自己的实际存放路径，比如”usr/local/include/eigen3/”）：进入文件cmake和make 3. 双目图像的位姿变换体验用自备手机，选取非单一背景颜色的环境进行拍照，具体方法为 双手持稳相机，拍第 一张照片，然后小幅度旋转相机，拍摄第二张照片， 重复上述 1-2 步，实现两张图片的特 征点检测与匹配。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/features2d/features2d.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace std;using namespace cv;int main ( int argc, char** argv )&#123; if ( argc != 3 ) &#123; cout&lt;&lt;"usage: feature_extraction img1 img2"&lt;&lt;endl; return 1; &#125; //-- 读取图像 Mat img_1 = imread ( argv[1], CV_LOAD_IMAGE_COLOR ); Mat img_2 = imread ( argv[2], CV_LOAD_IMAGE_COLOR ); //-- 初始化 std::vector&lt;KeyPoint&gt; keypoints_1, keypoints_2; Mat descriptors_1, descriptors_2; Ptr&lt;FeatureDetector&gt; detector = ORB::create(); Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::create(); // Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create(detector_name); // Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create(descriptor_name); Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create ( "BruteForce-Hamming" ); //-- 第一步:检测 Oriented FAST 角点位置 detector-&gt;detect ( img_1,keypoints_1 ); detector-&gt;detect ( img_2,keypoints_2 ); //-- 第二步:根据角点位置计算 BRIEF 描述子 descriptor-&gt;compute ( img_1, keypoints_1, descriptors_1 ); descriptor-&gt;compute ( img_2, keypoints_2, descriptors_2 ); Mat outimg1; drawKeypoints( img_1, keypoints_1, outimg1, Scalar::all(-1), DrawMatchesFlags::DEFAULT ); imshow("ORB特征点",outimg1); //-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离 vector&lt;DMatch&gt; matches; //BFMatcher matcher ( NORM_HAMMING ); matcher-&gt;match ( descriptors_1, descriptors_2, matches ); //-- 第四步:匹配点对筛选 double min_dist=10000, max_dist=0; //找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离 for ( int i = 0; i &lt; descriptors_1.rows; i++ ) &#123; double dist = matches[i].distance; if ( dist &lt; min_dist ) min_dist = dist; if ( dist &gt; max_dist ) max_dist = dist; &#125; // 仅供娱乐的写法 min_dist = min_element( matches.begin(), matches.end(), [](const DMatch&amp; m1, const DMatch&amp; m2) &#123;return m1.distance&lt;m2.distance;&#125; )-&gt;distance; max_dist = max_element( matches.begin(), matches.end(), [](const DMatch&amp; m1, const DMatch&amp; m2) &#123;return m1.distance&lt;m2.distance;&#125; )-&gt;distance; printf ( "-- Max dist : %f \n", max_dist ); printf ( "-- Min dist : %f \n", min_dist ); //当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限. std::vector&lt; DMatch &gt; good_matches; for ( int i = 0; i &lt; descriptors_1.rows; i++ ) &#123; if ( matches[i].distance &lt;= max ( 2*min_dist, 30.0 ) ) &#123; good_matches.push_back ( matches[i] ); &#125; &#125; //-- 第五步:绘制匹配结果 Mat img_match; Mat img_goodmatch; drawMatches ( img_1, keypoints_1, img_2, keypoints_2, matches, img_match ); drawMatches ( img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch ); imshow ( "所有匹配点对", img_match ); imshow ( "优化后匹配点对", img_goodmatch ); waitKey(0); return 0;&#125; 4. ICP 法相机姿态估计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/features2d/features2d.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/calib3d/calib3d.hpp&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;#include &lt;Eigen/SVD&gt;#include &lt;g2o/core/base_vertex.h&gt;#include &lt;g2o/core/base_unary_edge.h&gt;#include &lt;g2o/core/block_solver.h&gt;#include &lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;#include &lt;g2o/solvers/eigen/linear_solver_eigen.h&gt;#include &lt;g2o/types/sba/types_six_dof_expmap.h&gt;#include &lt;chrono&gt;using namespace std;using namespace cv;void find_feature_matches ( const Mat&amp; img_1, const Mat&amp; img_2, std::vector&lt;KeyPoint&gt;&amp; keypoints_1, std::vector&lt;KeyPoint&gt;&amp; keypoints_2, std::vector&lt; DMatch &gt;&amp; matches );// 像素坐标转相机归一化坐标Point2d pixel2cam ( const Point2d&amp; p, const Mat&amp; K );void pose_estimation_3d3d ( const vector&lt;Point3f&gt;&amp; pts1, const vector&lt;Point3f&gt;&amp; pts2, Mat&amp; R, Mat&amp; t);void bundleAdjustment( const vector&lt;Point3f&gt;&amp; points_3d, const vector&lt;Point3f&gt;&amp; points_2d, Mat&amp; R, Mat&amp; t);// g2o edgeclass EdgeProjectXYZRGBDPoseOnly : public g2o::BaseUnaryEdge&lt;3, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;&#123;public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW; EdgeProjectXYZRGBDPoseOnly( const Eigen::Vector3d&amp; point ) : _point(point) &#123;&#125; virtual void computeError() &#123; const g2o::VertexSE3Expmap* pose = static_cast&lt;const g2o::VertexSE3Expmap*&gt; ( _vertices[0] ); // measurement is p, point is p' _error = _measurement - pose-&gt;estimate().map( _point ); &#125; virtual void linearizeOplus() &#123; g2o::VertexSE3Expmap* pose = static_cast&lt;g2o::VertexSE3Expmap *&gt;(_vertices[0]); g2o::SE3Quat T(pose-&gt;estimate()); Eigen::Vector3d xyz_trans = T.map(_point); double x = xyz_trans[0]; double y = xyz_trans[1]; double z = xyz_trans[2]; _jacobianOplusXi(0,0) = 0; _jacobianOplusXi(0,1) = -z; _jacobianOplusXi(0,2) = y; _jacobianOplusXi(0,3) = -1; _jacobianOplusXi(0,4) = 0; _jacobianOplusXi(0,5) = 0; _jacobianOplusXi(1,0) = z; _jacobianOplusXi(1,1) = 0; _jacobianOplusXi(1,2) = -x; _jacobianOplusXi(1,3) = 0; _jacobianOplusXi(1,4) = -1; _jacobianOplusXi(1,5) = 0; _jacobianOplusXi(2,0) = -y; _jacobianOplusXi(2,1) = x; _jacobianOplusXi(2,2) = 0; _jacobianOplusXi(2,3) = 0; _jacobianOplusXi(2,4) = 0; _jacobianOplusXi(2,5) = -1; &#125; bool read ( istream&amp; in ) &#123;&#125; bool write ( ostream&amp; out ) const &#123;&#125;protected: Eigen::Vector3d _point;&#125;;int main ( int argc, char** argv )&#123; if ( argc != 5 ) &#123; cout&lt;&lt;"usage: pose_estimation_3d3d img1 img2 depth1 depth2"&lt;&lt;endl; return 1; &#125; //-- 读取图像 Mat img_1 = imread ( argv[1], CV_LOAD_IMAGE_COLOR ); Mat img_2 = imread ( argv[2], CV_LOAD_IMAGE_COLOR ); vector&lt;KeyPoint&gt; keypoints_1, keypoints_2; vector&lt;DMatch&gt; matches; find_feature_matches ( img_1, img_2, keypoints_1, keypoints_2, matches ); cout&lt;&lt;"一共找到了"&lt;&lt;matches.size() &lt;&lt;"组匹配点"&lt;&lt;endl; // 建立3D点 Mat depth1 = imread ( argv[3], CV_LOAD_IMAGE_UNCHANGED ); // 深度图为16位无符号数，单通道图像 Mat depth2 = imread ( argv[4], CV_LOAD_IMAGE_UNCHANGED ); // 深度图为16位无符号数，单通道图像 Mat K = ( Mat_&lt;double&gt; ( 3,3 ) &lt;&lt; 520.9, 0, 325.1, 0, 521.0, 249.7, 0, 0, 1 ); vector&lt;Point3f&gt; pts1, pts2; for ( DMatch m:matches ) &#123; ushort d1 = depth1.ptr&lt;unsigned short&gt; ( int ( keypoints_1[m.queryIdx].pt.y ) ) [ int ( keypoints_1[m.queryIdx].pt.x ) ]; ushort d2 = depth2.ptr&lt;unsigned short&gt; ( int ( keypoints_2[m.trainIdx].pt.y ) ) [ int ( keypoints_2[m.trainIdx].pt.x ) ]; if ( d1==0 || d2==0 ) // bad depth continue; Point2d p1 = pixel2cam ( keypoints_1[m.queryIdx].pt, K ); Point2d p2 = pixel2cam ( keypoints_2[m.trainIdx].pt, K ); float dd1 = float ( d1 ) /5000.0; float dd2 = float ( d2 ) /5000.0; pts1.push_back ( Point3f ( p1.x*dd1, p1.y*dd1, dd1 ) ); pts2.push_back ( Point3f ( p2.x*dd2, p2.y*dd2, dd2 ) ); &#125; cout&lt;&lt;"3d-3d pairs: "&lt;&lt;pts1.size() &lt;&lt;endl; Mat R, t; pose_estimation_3d3d ( pts1, pts2, R, t ); cout&lt;&lt;"ICP via SVD results: "&lt;&lt;endl; cout&lt;&lt;"R = "&lt;&lt;R&lt;&lt;endl; cout&lt;&lt;"t = "&lt;&lt;t&lt;&lt;endl; cout&lt;&lt;"R_inv = "&lt;&lt;R.t() &lt;&lt;endl; cout&lt;&lt;"t_inv = "&lt;&lt;-R.t() *t&lt;&lt;endl; cout&lt;&lt;"calling bundle adjustment"&lt;&lt;endl; bundleAdjustment( pts1, pts2, R, t ); // verify p1 = R*p2 + t for ( int i=0; i&lt;5; i++ ) &#123; cout&lt;&lt;"p1 = "&lt;&lt;pts1[i]&lt;&lt;endl; cout&lt;&lt;"p2 = "&lt;&lt;pts2[i]&lt;&lt;endl; cout&lt;&lt;"(R*p2+t) = "&lt;&lt; R * (Mat_&lt;double&gt;(3,1)&lt;&lt;pts2[i].x, pts2[i].y, pts2[i].z) + t &lt;&lt;endl; cout&lt;&lt;endl; &#125;&#125;void find_feature_matches ( const Mat&amp; img_1, const Mat&amp; img_2, std::vector&lt;KeyPoint&gt;&amp; keypoints_1, std::vector&lt;KeyPoint&gt;&amp; keypoints_2, std::vector&lt; DMatch &gt;&amp; matches )&#123; //-- 初始化 Mat descriptors_1, descriptors_2; // used in OpenCV3 Ptr&lt;FeatureDetector&gt; detector = ORB::create(); Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::create(); // use this if you are in OpenCV2 // Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create ( "ORB" ); // Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create ( "ORB" ); Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create("BruteForce-Hamming"); //-- 第一步:检测 Oriented FAST 角点位置 detector-&gt;detect ( img_1,keypoints_1 ); detector-&gt;detect ( img_2,keypoints_2 ); //-- 第二步:根据角点位置计算 BRIEF 描述子 descriptor-&gt;compute ( img_1, keypoints_1, descriptors_1 ); descriptor-&gt;compute ( img_2, keypoints_2, descriptors_2 ); //-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离 vector&lt;DMatch&gt; match; // BFMatcher matcher ( NORM_HAMMING ); matcher-&gt;match ( descriptors_1, descriptors_2, match ); //-- 第四步:匹配点对筛选 double min_dist=10000, max_dist=0; //找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离 for ( int i = 0; i &lt; descriptors_1.rows; i++ ) &#123; double dist = match[i].distance; if ( dist &lt; min_dist ) min_dist = dist; if ( dist &gt; max_dist ) max_dist = dist; &#125; printf ( "-- Max dist : %f \n", max_dist ); printf ( "-- Min dist : %f \n", min_dist ); //当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限. for ( int i = 0; i &lt; descriptors_1.rows; i++ ) &#123; if ( match[i].distance &lt;= max ( 2*min_dist, 30.0 ) ) &#123; matches.push_back ( match[i] ); &#125; &#125;&#125;Point2d pixel2cam ( const Point2d&amp; p, const Mat&amp; K )&#123; return Point2d ( ( p.x - K.at&lt;double&gt; ( 0,2 ) ) / K.at&lt;double&gt; ( 0,0 ), ( p.y - K.at&lt;double&gt; ( 1,2 ) ) / K.at&lt;double&gt; ( 1,1 ) );&#125;void pose_estimation_3d3d ( const vector&lt;Point3f&gt;&amp; pts1, const vector&lt;Point3f&gt;&amp; pts2, Mat&amp; R, Mat&amp; t)&#123; Point3f p1, p2; // center of mass int N = pts1.size(); for ( int i=0; i&lt;N; i++ ) &#123; p1 += pts1[i]; p2 += pts2[i]; &#125; p1 = Point3f( Vec3f(p1) / N); p2 = Point3f( Vec3f(p2) / N); vector&lt;Point3f&gt; q1 ( N ), q2 ( N ); // remove the center for ( int i=0; i&lt;N; i++ ) &#123; q1[i] = pts1[i] - p1; q2[i] = pts2[i] - p2; &#125; // compute q1*q2^T Eigen::Matrix3d W = Eigen::Matrix3d::Zero(); for ( int i=0; i&lt;N; i++ ) &#123; W += Eigen::Vector3d ( q1[i].x, q1[i].y, q1[i].z ) * Eigen::Vector3d ( q2[i].x, q2[i].y, q2[i].z ).transpose(); &#125; cout&lt;&lt;"W="&lt;&lt;W&lt;&lt;endl; // SVD on W Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; svd ( W, Eigen::ComputeFullU|Eigen::ComputeFullV ); Eigen::Matrix3d U = svd.matrixU(); Eigen::Matrix3d V = svd.matrixV(); if (U.determinant() * V.determinant() &lt; 0) &#123; for (int x = 0; x &lt; 3; ++x) &#123; U(x, 2) *= -1; &#125; &#125; cout&lt;&lt;"U="&lt;&lt;U&lt;&lt;endl; cout&lt;&lt;"V="&lt;&lt;V&lt;&lt;endl; Eigen::Matrix3d R_ = U* ( V.transpose() ); Eigen::Vector3d t_ = Eigen::Vector3d ( p1.x, p1.y, p1.z ) - R_ * Eigen::Vector3d ( p2.x, p2.y, p2.z ); // convert to cv::Mat R = ( Mat_&lt;double&gt; ( 3,3 ) &lt;&lt; R_ ( 0,0 ), R_ ( 0,1 ), R_ ( 0,2 ), R_ ( 1,0 ), R_ ( 1,1 ), R_ ( 1,2 ), R_ ( 2,0 ), R_ ( 2,1 ), R_ ( 2,2 ) ); t = ( Mat_&lt;double&gt; ( 3,1 ) &lt;&lt; t_ ( 0,0 ), t_ ( 1,0 ), t_ ( 2,0 ) );&#125;void bundleAdjustment ( const vector&lt; Point3f &gt;&amp; pts1, const vector&lt; Point3f &gt;&amp; pts2, Mat&amp; R, Mat&amp; t )&#123; // 初始化g2o typedef g2o::BlockSolver&lt; g2o::BlockSolverTraits&lt;6,3&gt; &gt; Block; // pose维度为 6, landmark 维度为 3 Block::LinearSolverType* linearSolver = new g2o::LinearSolverEigen&lt;Block::PoseMatrixType&gt;(); // 线性方程求解器 Block* solver_ptr = new Block( linearSolver ); // 矩阵块求解器 g2o::OptimizationAlgorithmGaussNewton* solver = new g2o::OptimizationAlgorithmGaussNewton( solver_ptr ); g2o::SparseOptimizer optimizer; optimizer.setAlgorithm( solver ); // vertex g2o::VertexSE3Expmap* pose = new g2o::VertexSE3Expmap(); // camera pose pose-&gt;setId(0); pose-&gt;setEstimate( g2o::SE3Quat( Eigen::Matrix3d::Identity(), Eigen::Vector3d( 0,0,0 ) ) ); optimizer.addVertex( pose ); // edges int index = 1; vector&lt;EdgeProjectXYZRGBDPoseOnly*&gt; edges; for ( size_t i=0; i&lt;pts1.size(); i++ ) &#123; EdgeProjectXYZRGBDPoseOnly* edge = new EdgeProjectXYZRGBDPoseOnly( Eigen::Vector3d(pts2[i].x, pts2[i].y, pts2[i].z) ); edge-&gt;setId( index ); edge-&gt;setVertex( 0, dynamic_cast&lt;g2o::VertexSE3Expmap*&gt; (pose) ); edge-&gt;setMeasurement( Eigen::Vector3d( pts1[i].x, pts1[i].y, pts1[i].z) ); edge-&gt;setInformation( Eigen::Matrix3d::Identity()*1e4 ); optimizer.addEdge(edge); index++; edges.push_back(edge); &#125; chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); optimizer.setVerbose( true ); optimizer.initializeOptimization(); optimizer.optimize(10); chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); chrono::duration&lt;double&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;double&gt;&gt;(t2-t1); cout&lt;&lt;"optimization costs time: "&lt;&lt;time_used.count()&lt;&lt;" seconds."&lt;&lt;endl; cout&lt;&lt;endl&lt;&lt;"after optimization:"&lt;&lt;endl; cout&lt;&lt;"T="&lt;&lt;endl&lt;&lt;Eigen::Isometry3d( pose-&gt;estimate() ).matrix()&lt;&lt;endl;&#125; 5．光流特征跟踪CMakeList文件：1234567891011cmake_minimum_required( VERSION 2.8 )project( useLK )set( CMAKE_BUILD_TYPE Release )set( CMAKE_CXX_FLAGS &quot;-std=c++11 -O3&quot; )find_package( OpenCV )include_directories( $&#123;OpenCV_INCLUDE_DIRS&#125; )add_executable( useLK useLK.cpp )target_link_libraries( useLK $&#123;OpenCV_LIBS&#125; ) useLK.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;chrono&gt;using namespace std;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/features2d/features2d.hpp&gt;#include &lt;opencv2/video/tracking.hpp&gt;int main( int argc, char** argv )&#123; if ( argc != 2 ) &#123; cout&lt;&lt;"usage: useLK path_to_dataset"&lt;&lt;endl; return 1; &#125; string path_to_dataset = argv[1]; string associate_file = path_to_dataset + "/associate.txt"; ifstream fin( associate_file ); if ( !fin ) &#123; cerr&lt;&lt;"I cann't find associate.txt!"&lt;&lt;endl; return 1; &#125; string rgb_file, depth_file, time_rgb, time_depth; list&lt; cv::Point2f &gt; keypoints; // 因为要删除跟踪失败的点，使用list cv::Mat color, depth, last_color; for ( int index=0; index&lt;100; index++ ) &#123; fin&gt;&gt;time_rgb&gt;&gt;rgb_file&gt;&gt;time_depth&gt;&gt;depth_file; color = cv::imread( path_to_dataset+"/"+rgb_file ); depth = cv::imread( path_to_dataset+"/"+depth_file, -1 ); if (index ==0 ) &#123; // 对第一帧提取FAST特征点 vector&lt;cv::KeyPoint&gt; kps; cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::create(); detector-&gt;detect( color, kps ); for ( auto kp:kps ) keypoints.push_back( kp.pt ); last_color = color; continue; &#125; if ( color.data==nullptr || depth.data==nullptr ) continue; // 对其他帧用LK跟踪特征点 vector&lt;cv::Point2f&gt; next_keypoints; vector&lt;cv::Point2f&gt; prev_keypoints; for ( auto kp:keypoints ) prev_keypoints.push_back(kp); vector&lt;unsigned char&gt; status; vector&lt;float&gt; error; chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); cv::calcOpticalFlowPyrLK( last_color, color, prev_keypoints, next_keypoints, status, error ); chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); chrono::duration&lt;double&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;double&gt;&gt;( t2-t1 ); cout&lt;&lt;"LK Flow use time："&lt;&lt;time_used.count()&lt;&lt;" seconds."&lt;&lt;endl; // 把跟丢的点删掉 int i=0; for ( auto iter=keypoints.begin(); iter!=keypoints.end(); i++) &#123; if ( status[i] == 0 ) &#123; iter = keypoints.erase(iter); continue; &#125; *iter = next_keypoints[i]; iter++; &#125; cout&lt;&lt;"tracked keypoints: "&lt;&lt;keypoints.size()&lt;&lt;endl; if (keypoints.size() == 0) &#123; cout&lt;&lt;"all keypoints are lost."&lt;&lt;endl; break; &#125; // 画出 keypoints cv::Mat img_show = color.clone(); for ( auto kp:keypoints ) cv::circle(img_show, kp, 10, cv::Scalar(0, 240, 0), 1); cv::imshow("corners", img_show); cv::waitKey(0); last_color = color; &#125; return 0;&#125; 参考： 刚哥的实验讲义 SLAM十四讲 https://github.com/gaoxiang12/slambook]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>OpenCV</tag>
        <tag>Linux</tag>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra 和 Ben-Ford算法]]></title>
    <url>%2Fpost%2Fbd15b34d.html</url>
    <content type="text"><![CDATA[1. Dijkstra算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1000; //最大顶点数const int inf = 10000000; //inf 表示最大的数即为不可达int n, m, s, G[maxv][maxv]; // n为顶点数，m为边数，G表示两顶点之间的权值int d[maxv]; // 记录起点到各个顶点之间的最短距离bool vis[maxv] = &#123;false&#125;; //数组标记，true表示已访问，初始为falsevoid Dijkstra(int s)&#123; fill(d, d + maxv, inf); // 将整个d数据初始化为inf d[s] = 0; for (int i = 0; i &lt; n; ++i)&#123; int u = -1, min = inf; // min存放d[u]的最小值 for (int j = 0; j &lt; n; ++j)&#123; // 找到未访问的顶点中d最小 if(vis[j] == false &amp;&amp; d[j] &lt; min)&#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; // 找不到小于inf的d[u]，说明剩下的顶点和起点不相通 vis[u] = true; for(int v = 0; v &lt; n; v++)&#123; //若v未访问，u能到达v,u为中间点d[v]更优，则跟新d if(vis[v] == false &amp;&amp; G[u][v] != inf &amp;&amp; d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; int u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;s); fill(G[0], G[0] + maxv * maxv, inf); for (int i = 0; i &lt; m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G[u][v] = w; &#125; printf("Dijkstra:\n"); Dijkstra(s); for (int i = 0; i &lt; n; ++i) &#123; printf("%d ", d[i]); &#125; return 0;&#125; 2. Ben-Ford算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1000; //最大顶点数const int inf = 10000000; //inf 表示最大的数即为不可达struct Node&#123; int v, dis; //v 为邻接边的目标顶点，dis为其权值 Node(int _v, int _dis): v(_v), dis(_dis) &#123;&#125;&#125;;vector&lt;Node&gt; Adj[maxv]; // 邻接表int n, m, s, d[maxv];bool Bellman_Ford(int s) &#123; //s为起点 fill(d, d + maxv, inf); d[s] = 0; for (int i = 0; i &lt; n - 1; ++i)&#123; // 求解数d，执行n-1轮操作，每轮操作遍历整个边 for(int u = 0; u &lt; n; ++u)&#123; for(int j = 0; j &lt; Adj[u].size(); ++j)&#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) d[v] = d[u] + dis; // 以u为中介使d[v]更小 &#125; &#125; &#125; for(int u = 0; u &lt; n; ++u)&#123; // 判断是否有负环，对每条边都判断，返回false说明有负环 for(int j = 0; j &lt; Adj[u].size(); ++j)&#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) return false; &#125; &#125; return true;&#125;int main(int argc, char const *argv[])&#123; int u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;s); for (int i = 0; i &lt; m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); Adj[u].push_back(Node(v, w)); &#125; printf("Bellman_Ford:\n"); if(Bellman_Ford(s) == true) &#123; for (int i = 0; i &lt; n; ++i)&#123; printf("%d ", d[i]); &#125; &#125; else printf("有负环\n"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
        <tag>Ben-Ford算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视觉3D点云图构建与深度测量]]></title>
    <url>%2Fpost%2F8957bd28.html</url>
    <content type="text"><![CDATA[实验 2 视觉 3D 点云图构建与深度测量 实验内容： 矩阵运算库 Eigen 的使用 彩色图、深度图的读取与参数提取 相机参数加载与使用 点云地图拼接 双目视觉系统标定与深度测量(限实验设计) 实验设备： 自带笔记本 PC 机摄像头/USB 摄像头，安装 Ubuntu14.04 或以上系统，OpenCV 开发库 预备知识： 深度相机原理 深度图像采集过程及坐标转换关系 linux，C++编程基础，Cmake 编译器使用 Eigen 矩阵运算库，OpenCV 图像处理库 所需文件： color文件夹有5张彩色图depth有五张深度图joinMap.cpp如下pose.txt为相机参数 中心思想 三个坐标系：世界坐标系，相机坐标系，像素坐标系两个参数：K(内参)，(T)外参 K和T都是一个4*4欧式变换矩阵，k实现像素坐标系和像素坐标系之间转换，T实现世界坐标系和相机坐标系之间的转换如下公式，K由fx,fy,cx,cy四个参数决定，T由pose.txt中数据确定最终根据最下面的公式，由各个像素坐标中的像素点得到世界坐标系点，然后用pcl转化成点云图。注意：点云图中的点是三维点，所以还需要一个量–d深度，由depth文件夹中五张深度图获得，而深度图怎么获得呢？有三种相机可获得。。。后面再讲还有，opencv3安装，依赖；Eigen安装，pcl安装等问题如下图，实在不懂自己百度。。。。 代码及详细分析（我不相信你还有比我还详细的了，哼。。。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;Eigen/Geometry&gt;#include &lt;boost/format.hpp&gt; // for formating strings#include &lt;pcl/point_types.h&gt;#include &lt;pcl/io/pcd_io.h&gt;#include &lt;pcl/visualization/pcl_visualizer.h&gt;/*通过点云拼接，我们就可以还原这个房间的三维场景。已知：5张RGB-D图像，每个图像的内参K和外参T目标：计算所有像素在世界坐标系的位置，把点云加起来，组成地图。思路：根据pose.txt中相机外参（平移向量+旋转四元数）转换成变换矩阵T（4*4）；对相机坐标（根据像素和实物关系得到）通T转换成世界坐标；之后根据5张图循环构造点云。 */int main( int argc, char** argv )&#123; vector&lt;cv::Mat&gt; colorImgs, depthImgs; // 彩色图和深度图 // 相机位姿, 5*7，表示五张图片，每张图片对应7个数前三个数是平移向量，后四个是旋转四元数 // poses 是长度为5的数组，每个元素是个矩阵（4*4） vector&lt;Eigen::Isometry3d, Eigen::aligned_allocator&lt;Eigen::Isometry3d&gt;&gt; poses; ifstream fin("./pose.txt"); if (!fin) &#123; cerr&lt;&lt;"请在有pose.txt的目录下运行此程序"&lt;&lt;endl; return 1; &#125; for ( int i=0; i&lt;5; i++ ) &#123; // 照片读取，boost::format 格式化字符串 拼接出图片文件名 boost::format fmt( "./%s/%d.%s" ); //图像文件格式 colorImgs.push_back( cv::imread( (fmt%"color"%(i+1)%"png").str() )); depthImgs.push_back( cv::imread( (fmt%"depth"%(i+1)%"pgm").str(), -1 )); // 使用-1读取原始图像 // 相机位姿读取到组data[] double data[7] = &#123;0&#125;; for ( auto&amp; d:data ) //auto自动类型转换 fin&gt;&gt;d; //文件流类型的变量fin将pose.txt中的数据给了d数组 Eigen::Quaterniond q( data[6], data[3], data[4], data[5] ); //四元数 data[6]是实数 但是coeffis输出的是先虚数后实数 Eigen::Isometry3d T(q); //变换矩阵T初始化旋转部分 T.pretranslate( Eigen::Vector3d( data[0], data[1], data[2] )); //T初始化平移向量部分 poses.push_back( T ); //存储T到位姿数组中 &#125; // 计算点云并拼接 // 相机内参 double cx = 325.5; double cy = 253.5; double fx = 518.0; double fy = 519.0; double depthScale = 1000.0; cout&lt;&lt;"正在将图像转换为点云..."&lt;&lt;endl; // 定义点云使用的格式：这里用的是XYZRGB typedef pcl::PointXYZRGB PointT; typedef pcl::PointCloud&lt;PointT&gt; PointCloud; // 新建一个点云 PointCloud::Ptr pointCloud( new PointCloud ); for ( int i=0; i&lt;5; i++ ) &#123; cout&lt;&lt;"转换图像中: "&lt;&lt;i+1&lt;&lt;endl; cv::Mat color = colorImgs[i]; cv::Mat depth = depthImgs[i]; Eigen::Isometry3d T = poses[i]; for ( int v=0; v&lt;color.rows; v++ ) for ( int u=0; u&lt;color.cols; u++ ) &#123; unsigned int d = depth.ptr&lt;unsigned short&gt; ( v )[u]; // 深度值v,u像素对应的深度值 if ( d==0 ) continue; // 为0表示没有测量到 // 将像素坐标(u,v,d)计算到相机坐标系下坐标 point Eigen::Vector3d point; point[2] = double(d)/depthScale; point[0] = (u-cx)*point[2]/fx; point[1] = (v-cy)*point[2]/fy; // 通过外参T将相机坐标系中的point转化成世界坐标系中的pointWorld Eigen::Vector3d pointWorld = T*point; // 将世界坐标系中的坐标放入点云图中的点中 PointT p ; p.x = pointWorld[0]; p.y = pointWorld[1]; p.z = pointWorld[2]; // 获取彩色图中各个像素点的bgr值 p.b = color.data[ v*color.step+u*color.channels() ]; p.g = color.data[ v*color.step+u*color.channels()+1 ]; p.r = color.data[ v*color.step+u*color.channels()+2 ]; pointCloud-&gt;points.push_back( p ); &#125; &#125; pointCloud-&gt;is_dense = false; cout&lt;&lt;"点云共有"&lt;&lt;pointCloud-&gt;size()&lt;&lt;"个点."&lt;&lt;endl; pcl::io::savePCDFileBinary("map.pcd", *pointCloud ); return 0;&#125;]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>OpenCV</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于OpenCV的颜色特征识别]]></title>
    <url>%2Fpost%2Fd7e278a1.html</url>
    <content type="text"><![CDATA[这篇post是智能机器人技术实验 实验 1 基于OpenCV的颜色特征识别 实验设备：平台二选一： 平台一：树莓派, Linux OS, OpenCV 开发库 平台二： 个人计算机，Linux OS,USB 摄像头，OpenCV 开发库 预备知识： 数字图像处理基础 C++、python 编程基础 Linux 系统基本操作基础 关于颜色特征识别的一些知识：1. CamShift算法：全称是 Continuously AdaptiveMeanShift，顾名思义，它是对Mean Shift 算法的改进，能够自动调节搜索窗口大小来适应目标的大小，可以跟踪视频中尺寸变化的目标。它也是一种半自动跟踪算法，需要手动标定跟踪目标。基本思想是以视频图像中运动物体的颜色信息作为特征，对输入图像的每一帧分别作 Mean-Shift 运算，并将上一帧的目标中心和搜索窗口大小(核函数带宽)作为下一帧 Mean shift 算法的中心和搜索窗口大小的初始值，如此迭代下去，就可以实现对目标的跟踪。因为在每次搜索前将搜索窗口的位置和大小设置为运动目标当前中心的位置和大小，而运动目标通常在这区域附近，缩短了搜索时间；另外，在目标运动过程中，颜色变化不大，故该算法具有良好的鲁棒性。已被广泛应用到运动人体跟踪，人脸跟踪等领域。 2. 算法流程 3. 代码及分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#!/usr/bin/env python# -*- coding: utf-8 -*-import numpy as npimport cv2import serial# from picamera.array import PiRGBArray# from picamera import PiCamera# import time# import copyimport video # 调取摄像头from matplotlib import pyplot as pltclass App(object): def __init__(self, color): # 获取图片 self.cam = video.create_capture(0)# self.cam = PiCamera()# self.cam.resolution = (320,240)# self.cam.framerate = 32# self.rCa = PiRGBArray(self.cam, size=(320,240))# time.sleep(0.1)# self.cam.capture(self.rCa, format='bgr')# self.frame = self.rCa.array# ret, self.frame = self.cam.read() cv2.namedWindow('camshift') # 通过命名的方式，创建了一个窗口 if color == 0: self.roi = cv2.imread( 'lan.jpg' ) self.flag = "lan" else : self.flag = "hong" self.roi = cv2.imread('hong.png') self.selection = None self.tracking_state = 0 self.show_backproj = False# self.ser = serial.Serial('/dev/ttyAMA0',115200,timeout=0.5) def start(self): # start方法用来设置一些状态，初始化信息 # tracking_state 判断是否进行追踪 self.tracking_state = 0 #x, y = np.int16([220, 110]) # BUG if self.flag == 'Hong': self.selection = (4, 6, 407, 304) # 设置初始追踪窗口 else: self.selection = (40, 54, 296, 230) self.tracking_state = 1 # print "start" def show_hist(self): # 直方图显示 bin_count = self.hist.shape[0] # hist在行数，在这里是16，即有16个条纹 print("hist,bin",self.hist.shape, bin_count, self.hist) bin_w = 24 # 每条条纹宽度 img = np.zeros((256, bin_count*bin_w, 3), np.uint8) # 初始化img图像，用于显示直方图，大小为256*(24*16) for i in xrange(bin_count): # 对每一条纹绘制 h = int(self.hist[i]) cv2.rectangle(img, (i*bin_w+2, 255), ((i+1)*bin_w-2, 255-h), (int(180.0*i/bin_count), 255, 255), -1) img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) # 将图像格式HSV转化成BGR cv2.imshow('hist', img) def run(self): #主要功能函数 roi = self.roi # roi存放目标图像 self.start() while True: # 死循环，通过Ctrl + C 退出# for frame in self.cam.capture_continuous(self.rCa, format='bgr', use_video_port=True): ret, self.frame = self.cam.read() # 通过摄像头获取图像# self.frame = frame.array # frame为摄像头获取的图像 vis = self.frame.copy() # vis复制frame# vis = copy.deepcopy(self.frame) hsv = cv2.cvtColor(self.frame, cv2.COLOR_BGR2HSV) mask = cv2.inRange(hsv, np.array((0., 60., 32.)), np.array((180., 255., 255.))) # 掩模图像。要统计整幅图像的直方图就把它设为 None。但是如 果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并 使用它。# self.selection = 1 if self.selection:# x0, y0, x1, y1 = 220, 110, 358, 245 x0, y0, x1, y1 = self.selection self.track_window = (x0, y0, x1-x0, y1-y0) # 窗口缩小# hsv_roi = hsv[y0:y1, x0:x1]# mask_roi = mask[y0:y1, x0:x1] hsv_roi = cv2. cvtColor(roi,cv2. COLOR_BGR2HSV) mask_roi = cv2.inRange(hsv_roi, np.array((0., 60., 32.)), np.array((180., 255., 255.))) #一维直方图 hist = cv2.calcHist( [hsv_roi], [0], mask_roi, [16], [0, 180] ) #二维直方图# hist = cv2.calcHist( [hsv_roi], [0,2],None, [180,256], [0, 180,0 , 255] ) cv2.normalize(hist, hist, 0, 255, cv2.NORM_MINMAX); self.hist = hist.reshape(-1) #二维直方图显示# plt.imshow(hist,interpolation = 'nearest')# plt.show() self.show_hist() vis_roi = vis[y0:y1, x0:x1] cv2.bitwise_not(vis_roi, vis_roi) # 颜色反转 vis[mask == 0] = 0 if self.tracking_state == 1: self.selection = None prob = cv2.calcBackProject([hsv], [0], self.hist, [0, 180], 1) # 计算反向投影参数为：捕获的图片（转化成hsv格式），灰度值方式，目标图像直方图，直方图范围 prob &amp;= mask term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 ) # 跳出条件，迭代10次或至少移动一次 track_box, self.track_window = cv2.CamShift(prob, self.track_window, term_crit) # 利用cameshift算法在追踪窗口中搜寻与直方图分布最相似的窗口，结果返回窗口和track_box# if track_box[0][1] &lt;= 240:# self.ser.write(str(int(track_box[0][0])-320) + " " + str(int(track_box[0][1])-240))# print str(int(track_box[0][0])-320) + " " + str(int(track_box[0][1])-240) if track_box[1][1] &lt;= 1: self.tracking_state = 0 self.start() else: if self.show_backproj: vis[:] = prob[...,np.newaxis] try: cv2.ellipse(vis, track_box, (0, 0, 255), 2)#利用返回的track_box画出椭圆# print track_box a = str(track_box[0][0])+" "+str(track_box[0][1])+" "+str(round(track_box[1][0],2))\ +" "+str(round(track_box[1][1],2))+" "+str(round(track_box[2],2))+"\r\n" print a# self.ser.write(a) except: print track_box cv2.imshow('camshift', vis) # 通过键盘输入来实现一些功能 ch = 0xFF &amp; cv2.waitKey(5) if ch == 27: break if ch == ord('b'): self.show_backproj = not self.show_backproj if ch == ord('r'): self.tracking_state = 0 self.start() cv2.destroyAllWindows()if __name__ == '__main__': import sys try: color = sys.argv[1] except: color = 1 print __doc__ a = App(color) a.run() video.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#!/usr/bin/env python'''Video capture sample.Sample shows how VideoCapture class can be used to acquire videoframes from a camera of a movie file. Also the sample providesan example of procedural video generation by an object, mimickingthe VideoCapture interface (see Chess class).'create_capture' is a convinience function for capture creation,falling back to procedural video in case of error.Usage: video.py [--shotdir &lt;shot path&gt;] [source0] [source1] ...' sourceN is an - integer number for camera capture - name of video file - synth:&lt;params&gt; for procedural videoSynth examples: synth:bg=../cpp/lena.jpg:noise=0.1 synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480Keys: ESC - exit SPACE - save current frame to &lt;shot path&gt; director'''import numpy as npimport cv2from time import clockfrom numpy import pi, sin, cosimport commonclass VideoSynthBase(object): def __init__(self, size=None, noise=0.0, bg = None, **params): self.bg = None self.frame_size = (1000, 480)# self.frame_size = (640, 480) if bg is not None: self.bg = cv2.imread(bg, 1) h, w = self.bg.shape[:2] self.frame_size = (w, h) if size is not None: w, h = map(int, size.split('x')) self.frame_size = (w, h) self.bg = cv2.resize(self.bg, self.frame_size) self.noise = float(noise) def render(self, dst): pass def read(self, dst=None): w, h = self.frame_size if self.bg is None: buf = np.zeros((h, w, 3), np.uint8) else: buf = self.bg.copy() self.render(buf) if self.noise &gt; 0.0: noise = np.zeros((h, w, 3), np.int8) cv2.randn(noise, np.zeros(3), np.ones(3)*255*self.noise) buf = cv2.add(buf, noise, dtype=cv2.CV_8UC3) return True, buf def isOpened(self): return Trueclass Chess(VideoSynthBase): def __init__(self, **kw): super(Chess, self).__init__(**kw) w, h = self.frame_size self.grid_size = sx, sy = 10, 7 white_quads = [] black_quads = [] for i, j in np.ndindex(sy, sx): q = [[j, i, 0], [j+1, i, 0], [j+1, i+1, 0], [j, i+1, 0]] [white_quads, black_quads][(i + j) % 2].append(q) self.white_quads = np.float32(white_quads) self.black_quads = np.float32(black_quads) fx = 0.9 self.K = np.float64([[fx*w, 0, 0.5*(w-1)], [0, fx*w, 0.5*(h-1)], [0.0,0.0, 1.0]]) self.dist_coef = np.float64([-0.2, 0.1, 0, 0]) self.t = 0 def draw_quads(self, img, quads, color = (0, 255, 0)): img_quads = cv2.projectPoints(quads.reshape(-1, 3), self.rvec, self.tvec, self.K, self.dist_coef) [0] img_quads.shape = quads.shape[:2] + (2,) for q in img_quads: cv2.fillConvexPoly(img, np.int32(q*4), color, cv2.CV_AA, shift=2) def render(self, dst): t = self.t self.t += 1.0/30.0 sx, sy = self.grid_size center = np.array([0.5*sx, 0.5*sy, 0.0]) phi = pi/3 + sin(t*3)*pi/8 c, s = cos(phi), sin(phi) ofs = np.array([sin(1.2*t), cos(1.8*t), 0]) * sx * 0.2 eye_pos = center + np.array([cos(t)*c, sin(t)*c, s]) * 15.0 + ofs target_pos = center + ofs R, self.tvec = common.lookat(eye_pos, target_pos) self.rvec = common.mtx2rvec(R) self.draw_quads(dst, self.white_quads, (245, 245, 245)) self.draw_quads(dst, self.black_quads, (10, 10, 10))classes = dict(chess=Chess)presets = dict( empty = 'synth:', lena = 'synth:bg=../cpp/lena.jpg:noise=0.1', chess = 'synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480')def create_capture(source = 0, fallback = presets['chess']): '''source: &lt;int&gt; or '&lt;int&gt;|&lt;filename&gt;|synth [:&lt;param_name&gt;=&lt;value&gt; [:...]]' ''' source = str(source).strip() chunks = source.split(':') # hanlde drive letter ('c:', ...) if len(chunks) &gt; 1 and len(chunks[0]) == 1 and chunks[0].isalpha(): chunks[1] = chunks[0] + ':' + chunks[1] del chunks[0] source = chunks[0] try: source = int(source) except ValueError: pass params = dict( s.split('=') for s in chunks[1:] ) cap = None if source == 'synth': Class = classes.get(params.get('class', None), VideoSynthBase) try: cap = Class(**params) except: pass else: cap = cv2.VideoCapture(source) params["size"] = "320x240" if 'size' in params: w, h = map(int, params['size'].split('x')) cap.set(cv2.CAP_PROP_FRAME_WIDTH, w) cap.set(cv2.CAP_PROP_FRAME_HEIGHT, h) if cap is None or not cap.isOpened(): print('Warning: unable to open video source: ', source) if fallback is not None: return create_capture(fallback, None) return capif __name__ == '__main__': import sys import getopt print(__doc__) args, sources = getopt.getopt(sys.argv[1:], '', 'shotdir=') args = dict(args) shotdir = args.get('--shotdir', '.') if len(sources) == 0: sources = [ 0 ] caps = map(create_capture, sources) shot_idx = 0 while True: imgs = [] for i, cap in enumerate(caps): ret, img = cap.read() imgs.append(img) cv2.imshow('capture %d' % i, img) ch = 0xFF &amp; cv2.waitKey(1) if ch == 27: break if ch == ord(' '): for i, img in enumerate(imgs): fn = '%s/shot_%d_%03d.bmp' % (shotdir, i, shot_idx) cv2.imwrite(fn, img) print(fn, 'saved') shot_idx += 1 cv2.destroyAllWindows() 参考： https://blog.csdn.net/tiemaxiaosu/article/details/51649401 http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/video/doc/motion_analysis_and_object_tracking.html?highlight=camshift#cv2.CamShift]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>OpenCV</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm安装和破解]]></title>
    <url>%2Fpost%2Fb2bb211a.html</url>
    <content type="text"><![CDATA[pycharm2017专业破解版1. 安装pycharm安装包 链接: https://pan.baidu.com/s/1uxmCo8VJiHVbBCQw5RIMEw 提取码: 6666 正常安装即可 2. 下载jar包链接: https://pan.baidu.com/s/1p9DFN0X7rq0N0Y2iapKMDA 提取码: 6666 3. 文件修改 将下载的jar包放入pycharm安装目录的/bin下, 并修改两个以 vmoptions为结尾的启动文件。将改启动文件以记事本形式打开然后分别在最后加上以下内容：1-javaagent:jar包所在目录\JetbrainsCrack-2.6.10-release-enc.jar 4. 破解重启pycharm 后在下图中点击 Activation code 然后复制以下代码后点击Activate ​ 1BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK/3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL/oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw/sCltpoPWlJtDOcw/iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9 5. 查看打开pycharm点击help-&gt;about查看 发现一直到2099年12月31日才过期。]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表二]]></title>
    <url>%2Fpost%2F765aa586.html</url>
    <content type="text"><![CDATA[3. Remove Duplicates from Sorted List Description:Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 Analysis: 迭代法 Solution:12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *pre = head, *p = head-&gt;next; while(p)&#123; if(pre-&gt;val == p-&gt;val) &#123; pre-&gt;next = p-&gt;next; delete p; p = pre-&gt;next; &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125; return head; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表一]]></title>
    <url>%2Fpost%2F4dda8b2f.html</url>
    <content type="text"><![CDATA[从今天起，开启一个新专题，刷 LeetCode! 线性表一&emsp;&emsp;下面都是很简单的小题，先熟悉熟悉。。。 1. Remove Duplicates from Sorted ArrayDescription:&emsp;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&emsp;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1:123Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2:123Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn’t matter what values are set beyond the returned length. Analysis:So easy, nothing to say! Solution: 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int count = 0; for(int i = 1; i &lt; nums.size(); i++)&#123; if(nums[count] != nums[i]) nums[++count] = nums[i]; &#125; return count + 1; &#125;&#125;; 2. Search in Rotated Sorted ArrayDescription: &emsp;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&emsp;You are given a target value to search. If found in the array return its index, otherwise return -1.&emsp;You may assume no duplicate exists in the array.&emsp;Your algorithm’s runtime complexity must be in the order of O(logn). Example 1:12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2:12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 Analysis:O(logn)很明显用二分查找，主要在于判断mid在pivot的左侧还是右侧。 Solution:1234567891011121314151617181920class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); while(left != right) &#123; const int mid = left + (right - left) / 2; // 用const那能显著减少运行时间，不用mid = (left + right) / 2 主要考虑left，right是两个大数相加可能会溢出。 if(nums[mid] == target) return mid; if(nums[mid] &gt;= nums[left]) &#123; // 说明mid在左侧 if(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) right = mid; else left = mid + 1; &#125; else &#123; // mid在右侧 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right-1]) left = mid + 1; else right = mid; &#125; &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS]]></title>
    <url>%2Fpost%2Fdc9314c3.html</url>
    <content type="text"><![CDATA[1. 背包问题 问题描叙：n件物品，物重数组w[i],价值数组c[i],从中取出若干物品放入一容器为V的背包中，使总质量少于V，而背包中物品价值之和最大。求最大价值。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;const int maxn=30;int n,V,maxValue=0;int w[maxn],c[maxn];void DFS(int index,int sumW,int sumC)&#123; //出口为index增长到n，sumW,sumC满足条件时更新maxValue后结束 if(index==n)&#123; if(sumW&lt;=V &amp;&amp; sumC&gt;maxValue) maxValue=sumC; return; &#125; DFS(index+1,sumW,sumC); DFS(index+1,sumW+w[index],sumC+c[index]);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;V); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;w[i]); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;c[i]); DFS(0,0,0); printf("%d\n",maxValue); return 0;&#125; 2. 在DFS的基础上的修改在要进入选择index时，设置进入条件。123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;const int maxn=30;int n,V,maxValue=0;int w[maxn],c[maxn];void DFS(int index,int sumW,int sumC)&#123; if(index==n) return; DFS(index+1,sumW,sumC); if(sumW+w[index]&lt;=V)&#123; if(sumC+c[index]&gt;maxValue) maxValue=sumC+c[index]; DFS(index+1,sumW+w[index],sumC+c[index]); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;V); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;w[i]); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;c[i]); DFS(0,0,0); printf("%d\n",maxValue); return 0;&#125; 3. 延伸 枚举从n个整数中选则K个数的所有方案使其满足某种条件问题描述：n个整数，从中选择K个数，使得这k个数之和恰好等于一个给定的整数X，如果有多个方案，选择他们中平方和最大的一个。 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;vector&gt;const int maxn=10;int n,k,x,maxSumsqu=-1,A[maxn];vector&lt;int&gt; temp,ans;void DFS(int index,int nowk,int sum,int sumsqu)&#123; if(nowk==k &amp;&amp; sum==x)&#123; if(sumsqu&gt;maxSumsqu)&#123; maxSumsqu=sumsqu; ans=temp; &#125; return; &#125; if(index==n || nowk&gt;k || sum&gt;x) return; //选择index时，先要将A[index]放入temp数组中。 temp.push_back(A[index]); DFS(index+1,nowk+1,sum+A[index],sumsqu+A[index]*A[index]); temp.pop_back(); DFS(index+1,nowk,sum,sumsqu);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DFS</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实算实验4之利用队列实现二叉树的层次遍历]]></title>
    <url>%2Fpost%2F7b246c0.html</url>
    <content type="text"><![CDATA[实验4 利用队列实现二叉树的层次遍历（4课时） 1. 实验目的:理解队列的受限操作（在一端插入，另一端删除）以及先进先出的特性，体会队列的应用场景的特点； 能利用《程序员实用算法》的程序清单2-9和2-10中的现有函数来解决实际应用问题。 2. 实验要求:应用需求：要求实现：若键盘输入t，则对当前二叉树进行非递归的层次遍历，并打印出来。（比如，若二叉树为： 则层次遍历后，打印出的结果为“33,23,44,12,37,46”。） 问题描述：利用队列作为数据结构来实现非递归的二叉树层次遍历的函数。 算法思想： 关键：实现非递归的二叉树层次遍历的函数（函数原型为：int LevelTraBintree(Bintree *t, DoFunc df); 输入：二叉排序树t，节点的操作函数df；输出：若是空树，则返回TREE_FAIL；否则，返回TREE_OK. 3. 算法设计思路： 分别创建队列和空闲列表； 为空闲链表分配QMAX个结点； 若二叉树为空，则退出程序； 将二叉树根节点入队； 重复执行下列操作，直至队列为空。 1）将队头节点出队并打印出其值； 2）若出队节点有左子树，则将该节点的左孩子入队； 3）若出队节点有右子树，则将该节点的右孩子入队； 返回成功，程序退出。 4. 代码与分析4.1.1 头文件qapp.h：队列节点的定义与创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*--- qapp.h ------------------------------ Listing 2-9 -------- * Application-specific data items for linked-list queues. *-------------------------------------------------------------*/#ifndef QAPP_H#define QAPP_H 1/* * Our first list's nodes consist of a pointer to * text and a priority level. */#define TEXT_SIZE 20 /* the maximum size of our text string */extern int DataCopy ( void *, void * );/* * The data and functions for the queue */struct NodeData1 &#123; struct NodeData1 *link[2]; char text[20];&#125;;typedef struct NodeData1 * pND1;extern void * CreateData1 ( void * );extern int DeleteData1 ( void * );extern int DuplicatedNode1 ( Link, Link );extern int NodeDataCmp1 ( void *, void * );/* * The free list has identical nodes */struct NodeData2 &#123; struct NodeData2 *link[2]; char text[20];&#125;;typedef struct NodeData2 * pND2;extern void * CreateData2 ( void * );extern int DeleteData2 ( void * );extern int DuplicatedNode2 ( Link, Link );extern int NodeDataCmp2 ( void *, void * );#endif 4.1.2 接口qapp.c：队列函数的具体定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/*--- qapp.c ------------------------------ Listing 2-10 -------- * Application-specific functions for queue examples. * Replace these routines with your own. *-------------------------------------------------------------*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* for free() */#include &lt;string.h&gt; /* for strcmp() and strdup() */#include "llgen.h"#include "qapp.h"/*=== linked-list functions for queue ===*//* * our nodes come from the free list, * so this function is never called. */void * CreateData1 ( void * data )&#123; return ( NULL );&#125;int DeleteData1 ( void * data )&#123; /* * In this case, NodeData1 consists of a pointer and an int. * The integer will be returned to memory when the node * is freed. However, the string must be freed manually. */ //free ( ((pND1) data)-&gt;text );//yyw return ( 1 );&#125;/*--------------------------------------------------------------- * This function determines what to do when inserting a node * into a list if an existing node with the same data is found * in the list. In this case, since we are counting words, if a * duplicate word is found, we simply increment the counter. * * Note this function should return one of the following values: * 0 an error occurred * 1 delete the duplicate node * 2 insert the duplicate node * Any other processing on the duplicate should be done in this * function. *-------------------------------------------------------------*/int DuplicatedNode1 ( Link new_node, Link list_node )&#123; return 2;&#125;/* compare only the priority of the queue data */int NodeDataCmp1 ( void *first, void *second )&#123; return (0);&#125;/*=== Now the functions for the list of free nodes ===*//* data is a priority level (int) and text (string) */void * CreateData2 ( void * data )&#123; struct NodeData2 * new_data; /*--- allocate our data structure ---*/ new_data = (struct NodeData2 *)malloc ( sizeof ( struct NodeData2 )); if ( new_data == NULL ) return ( NULL ); /*--- move the values into the data structure ---*/ /* * we assign a priority of 0 * and allocate a string of TEXT_SIZE + 1 */ new_data-&gt;link[0]=NULL; new_data-&gt;link[1]=NULL; //new_data-&gt;text == (char *)malloc (TEXT_SIZE+1);//yyw if ( new_data-&gt;text == NULL ) /* error copying string */ &#123; free ( new_data ); return ( NULL ); &#125; else return ( new_data ); /* return a complete structure */&#125;int DeleteData2 ( void * data )&#123; /* * In this case, NodeData2 consists of a pointer. * The string must be freed manually. */ //free ( ((pND2) data)-&gt;text ); return ( 1 );&#125;/* this list inserts duplicated nodes */int DuplicatedNode2 ( Link new_node, Link list_node )&#123; return 2;&#125;/* this function is never called */int NodeDataCmp2 ( void *first, void *second )&#123; return ( 0 );&#125;/* function to copy our data */int DataCopy ( void * dest, void * src )&#123; pND2 s,d; s = src; d = dest; if ( dest == NULL || src == NULL ) return ( 0 ); /*printf ( "About to copy %s \n", s-&gt;text );*/ strncpy ( d-&gt;text, s-&gt;text, TEXT_SIZE ); d-&gt;link[0]=s-&gt;link[0]; d-&gt;link[1]=s-&gt;link[1]; return ( 1 );&#125; 4.2.1 头文件llgen.h:链表的声明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*--- llgen.h ----------------------------- Listing 2-2 --------- * Declarations for generic doubly linked lists. * Used in conjunction with llgen.c (Listing 2-3). *-------------------------------------------------------------*/#ifndef LLGEN_H /* make sure it's included only once */#define LLGEN_H 1struct Node &#123; struct Node *prev; /* link to previous node */ struct Node *next; /* link to next node */ void *pdata; /* generic pointer to data */&#125;;typedef struct Node *Link;/* a linked list data structure */struct List &#123; Link LHead; Link LTail; unsigned int LCount; void * ( * LCreateData ) ( void * ); int ( * LDeleteData ) ( void * ); int ( * LDuplicatedNode ) ( Link, Link ); int ( * LNodeDataCmp ) ( void *, void * );&#125;;/* The four functions specific to an individual linked list are: LCreateData: is passed a pointer to an application-defined object and is expected to return a pointer to whatever is to be stored in the linked list. LDeleteData: is passed a pointer to the object an application has stored in a linked list. LDeleteData must destroy the object. LDuplicatedNode: is passed two pointers. The first pointer is to a node that you would like to add to a linked list and the second is to a node that is already in the list but is a duplicate of the first pointer. LDuplicatedNode returns: 0 -&gt; do nothing to list 1 -&gt; destroy duplicate 2 -&gt; add duplicate to list LNodeDataCmp: is passed pointers to two application data objects and must compare them, returning a number that is &lt; 0, zero, or &gt; 0, depending on the relationship between the first and second objects.*//*--- generic linked-list primitives ---*/int AddNodeAscend ( struct List *, void * );int AddNodeAtHead ( struct List *, void * );struct List * CreateLList ( void * ( * ) ( void * ), /* create data */ int ( * ) ( void * ), /* delete data */ int ( * ) ( Link, Link ), /* duplicate */ int ( * ) ( void *, void * )); /* compare */Link CreateNode ( struct List * , void * );int DeleteNode ( struct List *, Link );Link FindNode ( struct List *, void * );Link FindNodeAscend ( struct List *, void * );Link GotoNext ( struct List *, Link );Link GotoPrev ( struct List *, Link );#endif 4.2.2 接口llgen.c：链表函数的具体定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283/*--- llgen.c ------------------------------ Listing 2-3 -------- * Generic primitive functions for doubly linked lists. * Contains no application-specific functions. * Functions are in alphabetical order. *------------------------------------------------------------*/#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define IN_LL_LIB 1 /* in the library of primitives */#include "llgen.h"/*--- Aliases to make the code more readable ---*/#define LLHead (L-&gt;LHead) /* The head of the current list */#define LLTail (L-&gt;LTail) /* The tail of the current list */#define NodeCount (L-&gt;LCount) /* Nodes in the current list */#define CreateData (*(L-&gt;LCreateData))#define DeleteData (*(L-&gt;LDeleteData))#define DuplicatedNode (*(L-&gt;LDuplicatedNode))#define NodeDataCmp (*(L-&gt;LNodeDataCmp))/*---------------------------------------------------- * Add a node at head: first allocate the space for * the data, then allocate a node with a pointer to * the data, then add the node to the list. *--------------------------------------------------*/int AddNodeAtHead ( struct List *L, void *nd )&#123; Link pn; pn = CreateNode ( L, nd ); if ( pn == NULL ) return ( 0 ); /*--- Add the node ---*/ if ( LLHead == NULL ) /* is it the first node? */ &#123; LLHead = LLTail = pn; /*--- yes ---*/ &#125; else /*--- no ---*/ &#123; LLHead-&gt;prev = pn; /* first goes node before Head */ pn-&gt;next = LLHead; /* put Head next */ LLHead = pn; /* then point Head to us */ &#125; NodeCount += 1; return ( 1 );&#125;/*---------------------------------------------------- * Add ascending. Adds a node to an ordered list. *--------------------------------------------------*/int AddNodeAscend ( struct List *L, void *nd )&#123; Link pn; /* to node we're creating */ Link prev, curr; /* our current search */ struct Node dummy; /* a dummy node */ int compare; pn = CreateNode ( L, nd ); if ( pn == NULL ) return ( 0 ); /* attach dummy node to head of list */ dummy.next = LLHead; dummy.prev = NULL; if ( dummy.next != NULL ) dummy.next-&gt;prev = &amp;dummy; prev = &amp;dummy; curr = dummy.next; for ( ; curr != NULL; prev = curr, curr = curr-&gt;next ) &#123; compare = NodeDataCmp ( pn-&gt;pdata, curr-&gt;pdata ); if ( compare &lt;= 0 ) break; /* new node equals or precedes curr */ &#125; if ( curr != NULL &amp;&amp; compare == 0 ) &#123; compare = DuplicatedNode ( pn, curr ); if ( compare == 2 ) /* do nothing -- will get inserted */; else &#123; /* first, repair the linked list */ LLHead = dummy.next; LLHead-&gt;prev = NULL; /* delete the duplicated node, if appropriate */ if ( compare == 1 ) &#123; DeleteData( pn-&gt;pdata ); free ( pn ); &#125; return ( 1 ); &#125; &#125; prev-&gt;next = pn; pn-&gt;prev = prev; pn-&gt;next = curr; if ( curr != NULL ) curr-&gt;prev = pn; else LLTail = pn; /* this node is the new tail */ NodeCount += 1; /* now, unhook the dummy head node */ LLHead = dummy.next; LLHead-&gt;prev = NULL; return ( 1 );&#125;/*--------------------------------------------------------------- * Creates a linked-list structure and returns a pointer to it. * On error, returns NULL. This functions accepts pointers * to the four list-specific functions and initializes the * linked-list structure with them. *-------------------------------------------------------------*/struct List * CreateLList ( void * ( * fCreateData ) ( void * ), int ( * fDeleteData ) ( void * ), int ( * fDuplicatedNode ) ( Link, Link ), int ( * fNodeDataCmp ) ( void *, void * ))&#123; struct List * pL; pL = (struct List *) malloc ( sizeof ( struct List )); if ( pL == NULL ) return NULL; pL-&gt;LHead = NULL; pL-&gt;LTail = NULL; pL-&gt;LCount = 0; pL-&gt;LCreateData = fCreateData; pL-&gt;LDeleteData = fDeleteData; pL-&gt;LDuplicatedNode = fDuplicatedNode; pL-&gt;LNodeDataCmp = fNodeDataCmp; return ( pL );&#125;/*--------------------------------------------------------------- * Creates a node and then calls the application-specific * function CreateData() to create the node's data structure. * Returns NULL on error. *-------------------------------------------------------------*/Link CreateNode ( struct List *L, void *data )&#123; Link new_node; new_node = (Link) malloc ( sizeof ( struct Node )); if ( new_node == NULL ) return ( NULL ); new_node-&gt;prev = NULL; new_node-&gt;next = NULL; /*--- now call the application-specific data allocation ---*/ new_node-&gt;pdata = CreateData( data ); if ( new_node-&gt;pdata == NULL ) &#123; free ( new_node ); return ( NULL ); &#125; else return ( new_node );&#125;/*--------------------------------------------------------------- * Deletes the node pointed to by to_delete. * Function calls list-specific function to delete data. *-------------------------------------------------------------*/int DeleteNode ( struct List *L, Link to_delete )&#123; Link pn; if ( to_delete == NULL ) /* Double check before */ return ( 0 ); /* deleting anything. */ if ( to_delete-&gt;prev == NULL ) /* we're at the head */ &#123; LLHead = to_delete-&gt;next; /* update head */ LLHead-&gt;prev = NULL; /* update next node??? */ &#125; else if ( to_delete-&gt;next == NULL ) &#123; /* we're at the tail */ pn = to_delete-&gt;prev; /* get the previous node */ pn-&gt;next = NULL; //??? LLTail = pn; /* update tail */ &#125; else /* we're in the list */ &#123; pn = to_delete-&gt;prev; /* get the previous node */ pn-&gt;next = to_delete-&gt;next; /* update previous node to */ /* point to the next one. */ pn = to_delete-&gt;next; /* get the next node */ pn-&gt;prev = to_delete-&gt;prev; /* update it to point to */ /* the previous one. */ &#125; DeleteData ( to_delete-&gt;pdata ); /* delete the data */ free ( to_delete ); /* free the node */ NodeCount -= 1; return ( 1 );&#125;/*--------------------------------------------------------------- * Finds node by starting at the head of the list, stepping * through each node, and comparing data items with the search * key. The Ascend version checks that the data in the node * being examined is not larger than the search key. If it is, * we know the key is not in the list. Returns pointer to node * on success or NULL on failure. *-------------------------------------------------------------*/Link FindNode ( struct List *L, void *nd )&#123; Link pcurr; /* the node we're examining */ if ( LLHead == NULL ) /* empty list */ return ( NULL ); for ( pcurr = LLHead; pcurr != NULL; pcurr = pcurr-&gt;next) &#123; if ( NodeDataCmp ( nd, pcurr-&gt;pdata ) == 0 ) return ( pcurr ); &#125; return ( NULL ); /* could not find node */&#125;Link FindNodeAscend ( struct List *L, void *nd )&#123; Link pcurr; /* the node we're examining */ int cmp_result; if ( LLHead == NULL ) /* empty list */ return ( NULL ); for ( pcurr = LLHead; pcurr != NULL; pcurr = pcurr-&gt;next) &#123; cmp_result = NodeDataCmp ( nd, pcurr-&gt;pdata ); if ( cmp_result &lt; 0 ) return ( NULL ); /* too far */ if ( cmp_result == 0 ) /* just right */ return ( pcurr ); &#125; return ( NULL ); /* could not find node */&#125;/*--------------------------------------------------------------- * The Goto functions return the pointer to the requested node * or NULL on error. *-------------------------------------------------------------*/Link GotoNext ( struct List *L, Link pcurr )&#123; if ( pcurr-&gt;next == NULL || pcurr == LLTail ) return ( NULL ); else return ( pcurr-&gt;next );&#125;Link GotoPrev ( struct List *L, Link pcurr )&#123; if ( pcurr-&gt;prev == NULL || pcurr == LLHead ) return ( NULL ); else return ( pcurr-&gt;prev );&#125; 4.3.1 头文件bintree.h：二叉树定义123456789101112131415161718192021222324252627282930313233343536373839404142/*--- bintree.h --------------------------- Listing 6-2 --------- * Binary-tree definitions * *-------------------------------------------------------------*/#define TREE_OK (0)#define TREE_FAIL (-1)#define LEFT 1#define RIGHT 0typedef struct sBnode &#123; struct sBnode *link[2];&#125; Bnode;/* Our binary tree is made up of these */typedef struct sMynode &#123; /* A copy of the items in a Bnode */ struct sMynode *link[2]; char text[20];&#125; Mynode;/* Control structure for a binary tree */typedef int (*CompFunc) (void *node1, void *node2);typedef int (*DoFunc) (void *node, int level);typedef struct sBintree &#123; Bnode *DummyHead; CompFunc Compare; int DuplicatesOk; size_t NodeSize;&#125; Bintree;/* Prototypes */Bintree *NewBintree (Bnode *dummy, CompFunc cf, int dup_ok, size_t node_size);Bnode *FindBintree(Bintree *t, Bnode *n);int InsBintree (Bintree *t, Bnode *n);Bnode *DelBintree (Bintree *t, Bnode *n);int WalkBintree(Bintree *t, DoFunc df);Bnode *InitBintreeNode(size_t size);int LevelTraBintree(Bintree *t, DoFunc df); 4.3.2 bintree.c：二叉树主要功能定义和问题算法思路的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713/*--- bintree.c --------------------------- Listing 6-1 --------- * Binary tree routines. Provides plain binary search * *-------------------------------------------------------------*/#define TEST#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include "bintree.h"#include "llgen.h"#include "qapp.h"#define QMAX 100 /* maximum number of elements in a queue */ //yyw/* A safe malloc() */static void * tmalloc(size_t size)&#123; void *p; if ((p = malloc(size)) == NULL) &#123; printf("Out of memory\n"); exit(1); &#125; return p;&#125;/* * Create and initialize a node for the user. 'size' both can * and should be greater than sizeof(Bnode) to allow for a * data area for the user. */Bnode *InitBintreeNode(size_t size)&#123; Bnode *n; n = tmalloc(size); n -&gt; link[LEFT] = n -&gt; link[RIGHT] = NULL; return n;&#125;/* Create an empty tree */Bintree *NewBintree (Bnode *dummy, CompFunc cf, int dup_ok, size_t node_size)&#123; Bintree *t; t = tmalloc(sizeof(Bintree)); t -&gt; DummyHead = dummy; t -&gt; Compare = cf; t -&gt; DuplicatesOk = dup_ok; t -&gt; NodeSize = node_size; return t;&#125;/* Find node n in tree t */Bnode *FindBintree(Bintree *t, Bnode *n)&#123; Bnode *s; int dir; s = t -&gt; DummyHead -&gt; link[RIGHT]; while (s != NULL) &#123; dir = (t -&gt; Compare) (n, s); /* * If a match, we're done. * For Red-Black, must also be a leaf. */ if (dir == 0 ) return s; dir = dir &lt; 0; s = s -&gt; link[dir]; &#125; return NULL; /* no match */&#125;Bnode * DelBintree (Bintree *t, Bnode *n)&#123; Bnode *p, *s, *save; int dir, dir_old; p = t -&gt; DummyHead; s = p -&gt; link[RIGHT]; dir_old = dir = RIGHT; /* Look for a match */ while (s != NULL &amp;&amp; (dir = (t-&gt;Compare)(n, s)) != 0) &#123; p = s; dir = dir &lt; 0; dir_old = dir; s = p -&gt; link[dir]; &#125; if (s == NULL) return NULL; /* no match found */ save = s; /* * First case: if s has no right child, then replace s * with s's left child. */ if (s -&gt; link[RIGHT] == NULL) s = s -&gt; link[LEFT]; /* * Second case: if s has a right child that lacks a left * child, then replace s with s's right child and * copy s's left child into the right child's left child. */ else if (s -&gt; link[RIGHT] -&gt; link[LEFT] == NULL) &#123; s = s -&gt; link[RIGHT]; s -&gt; link[LEFT] = save -&gt; link[LEFT]; &#125; /* * Final case: find leftmost (smallest) node in s's right * subtree. By definition, this node has an empty left * link. Free this node by copying its right link to * its parent's left link and then give it both of s's * links (thus replacing s). */ else &#123; Bnode *small; small = s -&gt; link[RIGHT]; while (small -&gt; link[LEFT] -&gt; link[LEFT]) small = small -&gt; link[LEFT]; s = small -&gt; link[LEFT]; small -&gt; link[LEFT] = s -&gt; link[RIGHT]; s -&gt; link[LEFT] = save -&gt; link[LEFT]; s -&gt; link[RIGHT] = save -&gt; link[RIGHT]; &#125; p -&gt; link[dir_old] = s; return save;&#125;/* Insert node n into tree t */int InsBintree (Bintree *t, Bnode *n)&#123; int p_dir; Bnode *p, *s; /* Search until we find an empty arm. */ p = t -&gt; DummyHead; p_dir = RIGHT; /* direction from p to s */ s = p -&gt; link[RIGHT]; while (s != NULL) &#123; p = s; p_dir = (t -&gt; Compare) (n, s); if (p_dir == 0 &amp;&amp; t -&gt; DuplicatesOk == 0) return TREE_FAIL; /* duplicate */ p_dir = p_dir &lt; 0; //printf(" Compare with '%s'.", ((struct sMynode *)s) -&gt; text); s = s -&gt; link[p_dir]; &#125; /* Add the new node */ p -&gt; link[p_dir] = n; //printf("\n"); return TREE_OK;&#125;/* * Recursive tree walk routines. The entry point is * WalkBintree. It will do an inorder traversal of the * tree, call df() for each node and leaf. */void rWalk(Bnode *n, int level, DoFunc df)&#123; if (n != NULL) &#123; rWalk(n -&gt; link[LEFT], level + 1, df); df(n, level); rWalk(n -&gt; link[RIGHT], level + 1, df); &#125;&#125;int WalkBintree(Bintree *t, DoFunc df)&#123; if (t -&gt; DummyHead -&gt; link[RIGHT] == NULL) &#123; fputs("Empty tree\n", stdout); return TREE_FAIL; &#125; rWalk(t -&gt; DummyHead -&gt; link[RIGHT], 0, df); return TREE_OK;&#125;#if defined(TEST)/* * Test driver */#define BUFLEN 100int LoadString(Bintree *t, char *string)&#123; Mynode *m; m = (Mynode *) InitBintreeNode(sizeof(Mynode)); strncpy(m-&gt;text, string, sizeof(m-&gt;text)); m-&gt;text[sizeof(m-&gt;text) - 1] = 0; return InsBintree(t, (Bnode *) m);&#125;void FindString(Bintree *t, char *string)&#123; Mynode m, *r; strncpy(m.text, string, sizeof(m.text)); m.text[sizeof(m.text) - 1] = 0; if ((r = (Mynode *) FindBintree(t, (Bnode *) &amp;m)) == NULL) puts(" Not found.\n"); else printf(" Found '%s'.\n", r -&gt; text);&#125;void DeleteString(Bintree *t, char *string)&#123; Mynode m, *n; strncpy(m.text, string, sizeof(m.text)); m.text[sizeof(m.text) - 1] = 0; n = (Mynode *) DelBintree(t, (Bnode *) &amp;m); if (n) free (n); else fprintf(stdout, " Did not find '%s'.\n", string);&#125;void LoadFile(Bintree *t, char *fname)&#123; FILE *infile; char buffer[BUFLEN], *s; int i = 0, j = 0; if ((infile = fopen(fname, "r")) == NULL) &#123; fputs(" Couldn't open the file.\n", stdout); return; &#125; while (fgets(buffer, BUFLEN, infile)) &#123; s = buffer + strlen(buffer); while(iscntrl(*s)) *s-- = 0; if (buffer[0] == ';') /* a comment */ ; else if (buffer[0] == '-' &amp;&amp; buffer[1] != 0) &#123; DeleteString(t, buffer+1); j++; &#125; else &#123; LoadString(t, buffer); i++; &#125; &#125; fclose(infile); printf("Loaded %d items and deleted %d from %s.\n", i, j, fname);&#125;/* * A sample action function: it prints out the data * at each node along with the node's level in the tree */int ShowFunc(void *m, int level)&#123; fprintf(stdout, "%s (%d)\n", ((Mynode *)m) -&gt; text, level); return TREE_OK;&#125;/* * A pair of functions to print the tree as a diagram. */#if !defined(ALTDRAW) #define TOP '+' //yyw #define BOT '+' //yyw #define HOR '-' //yyw #define VRT '|' //yyw //#define TOP '? //#define BOT '? //#define HOR '? //#define VRT '?#else #define TOP '/' #define BOT '\\' #define HOR '-' #define VRT '|'#endif#define DRAWBUF 100char draw[DRAWBUF];char work[DRAWBUF * 2];int maxdepth;FILE *outfile;void xrWalk(Bnode *n, int level)&#123; int i; if (n != NULL) &#123; /* Monitor */ if (level &gt; maxdepth) maxdepth = level; /* * Go right */ draw[level * 2] = TOP; draw[level * 2 + 1] = ' '; xrWalk(n -&gt; link[RIGHT], level + 1); /* * Show current node */ strncpy(work, draw, level * 2); if (level &gt; 0) &#123; int c; c = work[0]; for (i = 2; i &lt; level * 2; i += 2) if (work[i] == c) work[i - 2] = ' '; else c = work[i]; work[level * 2 - 1] = HOR; for (i = 0; i &lt; level * 2 - 2; i += 2) if (work[i] != ' ') &#123; work[i] = VRT; &#125; &#125; sprintf(work + level * 2, "%s (%d)", ((Mynode *)n)-&gt;text, level); fputs(work, outfile); fputs("\n", outfile); /* * Go left */ draw[level * 2] = BOT; draw[level * 2 + 1] = ' '; xrWalk(n -&gt; link[LEFT], level + 1); &#125;&#125;int xWalkBintree(Bintree *t, char *name, char *mode)&#123; if (t -&gt; DummyHead -&gt; link[RIGHT] == NULL) &#123; fputs("Empty tree\n", stdout); return TREE_FAIL; &#125; maxdepth = -1; outfile = stdout; if (name) &#123; outfile = fopen(name, mode); if (outfile == NULL) &#123; fprintf(stdout, "Can't open %s.\n", name); name = NULL; outfile = stdout; &#125; &#125; xrWalk(t -&gt; DummyHead -&gt; link[RIGHT], 0); fprintf(outfile, "Max depth %d.\n", maxdepth); if (name) fclose(outfile); /* a real file */ else fflush(outfile); /* stdout */ return TREE_OK;&#125;int compare_length = 0;int CompareFunc(void *n1, void *n2)&#123; if (compare_length) return strncmp(((Mynode *)n1)-&gt;text, ((Mynode *)n2)-&gt;text, compare_length); else return strcmp(((Mynode *)n1)-&gt;text, ((Mynode *)n2)-&gt;text);&#125;/*--------------------------------------------------------------- * enqueue loads the data items in entry into the head node of * the free list, then adds that node to the queue based on * priority. *-------------------------------------------------------------*/int enqueue ( struct List *lqueue, struct List *lfree, void *new_entry )&#123; Link curr, new_node; /* Are there any free nodes left? */ if ( lfree-&gt;LCount == 0 ) &#123; fprintf ( stderr, "Exceeded maximum queue size\n" ); return ( 0 ); &#125; /* load the data into the head of the free list */ new_node = lfree-&gt;LHead; if ( DataCopy ( new_node-&gt;pdata, new_entry ) == 0 ) return ( 0 ); lfree-&gt;LHead = lfree-&gt;LHead-&gt;next; /* adding to an empty list? */ if ( lqueue-&gt;LCount == 0 ) &#123; new_node-&gt;prev = NULL; new_node-&gt;next = NULL; lqueue-&gt;LTail = new_node; lqueue-&gt;LHead = new_node; lqueue-&gt;LCount = 1; lfree-&gt;LCount -= 1; &#125; /* Traverse the list to find the insertion position */ else &#123; new_node-&gt;prev = lqueue-&gt;LTail; new_node-&gt;next = NULL; new_node-&gt;prev-&gt;next = new_node; lqueue-&gt;LTail = new_node; lqueue-&gt;LCount += 1; /* update the free list */ lfree-&gt;LCount -= 1; &#125; return ( 1 );&#125;/*--------------------------------------------------------------- * dequeue takes a pointer that will be set to the data in the * node at the head of the queue. It then moves the node being * dequeued from the queue to the free list. Note that if you do * not use the dequeued data before next queue operation, the * data is lost, so copy it if you need to. Returns 0 on error. *-------------------------------------------------------------*/int dequeue ( struct List *lqueue, struct List *lfree, void * our_data )&#123; Link dequeued_link; /* is there anything to dequeue? */ if ( lqueue-&gt;LCount == 0 ) &#123; fprintf ( stderr, "Error dequeue from empty queue\n" ); return ( 0 ); &#125; /* make a copy of the data being dequeued */ if ( DataCopy ( our_data, lqueue-&gt;LHead-&gt;pdata ) == 0 ) return ( 0 ); /* remove the node from the queue */ dequeued_link = lqueue-&gt;LHead; lqueue-&gt;LHead = lqueue-&gt;LHead-&gt;next; lqueue-&gt;LCount -= 1; /* add the node to the free list */ dequeued_link-&gt;prev = NULL; dequeued_link-&gt;next = lfree-&gt;LHead; lfree-&gt;LHead = dequeued_link; lfree-&gt;LCount += 1; return ( 1 );&#125;int LevelTraBintree(Bintree *t, DoFunc df)&#123; // 层序遍历 int count; void *temp;/* temporary data area*/ struct List *queue, *free_list; /* our two queues */ int level=0; Mynode * PCurrTnode;//指向当前要操作的节点 /*--- set up linked-list data structures for queues ---*/ queue = CreateLList ( CreateData1, /* in qapp.c */ DeleteData1, /* " */ DuplicatedNode1, /* " */ NodeDataCmp1 ); /* " */ free_list = CreateLList ( CreateData2, /* in qapp.c */ DeleteData2, /* " */ DuplicatedNode2, /* " */ NodeDataCmp2 ); /* " */ if ( queue == NULL || free_list == NULL ) //要求queue,free_list 指向非空 &#123; fprintf ( stderr, "Error creating queue\n" ); exit ( EXIT_FAILURE ); &#125; /*--- allocate the free list ---*/ for ( count = 0; count &lt; QMAX; count++ ) // 向free_list中填充所需节点 &#123; if ( ! AddNodeAtHead ( free_list, PCurrTnode )) &#123; fprintf ( stderr, "Could not create queue of %d\n", QMAX ); exit ( EXIT_FAILURE ); &#125; &#125; /*--- begin processing file ---*/ if (t -&gt; DummyHead -&gt; link[RIGHT] == NULL) &#123; // 要求树非空 fputs("Empty tree\n", stdout); return TREE_FAIL; &#125; PCurrTnode = CreateData2 ( NULL ); if ( PCurrTnode == NULL ) // PCurrTnode 创建失败处理 &#123; fprintf ( stderr, "Error creating temporary data area\n" ); exit ( EXIT_FAILURE ); &#125; if ( DataCopy ( PCurrTnode, t -&gt; DummyHead -&gt; link[RIGHT] ) == 0 ) // 树头节点值赋给PCurrTnode return ( 0 ); if ( enqueue ( queue, free_list, PCurrTnode ) == 0 )//将树的根节点入队 &#123; printf ( "Error enqueueing %s\n", ((pND2)PCurrTnode)-&gt;text ); exit ( EXIT_FAILURE ); &#125; else printf ( "Enqueued %s\n", ((pND2)PCurrTnode)-&gt;text ); while ( queue-&gt;LCount &gt; 0 ) //队非空时循环操作，队空结束循环 &#123; if ( dequeue ( queue, free_list, PCurrTnode ) == 0 ) // 队首元素出队，即PCurrTnode所指向的元素 &#123; printf ( "Error dequeueing %s\n", ((pND2)PCurrTnode)-&gt;text ); return ( EXIT_FAILURE ); &#125; else printf ( "Dequeued %s\n", ((pND2)PCurrTnode)-&gt;text ); df(PCurrTnode, level++); if (PCurrTnode -&gt; link[LEFT] != NULL) if ( enqueue ( queue, free_list, PCurrTnode -&gt; link[LEFT] ) == 0 )//将PCurrTnode所指节点的左孩子入队 &#123; printf ( "Error enqueueing %s\n", ((pND2)PCurrTnode -&gt; link[LEFT])-&gt;text ); exit ( EXIT_FAILURE ); &#125; else printf ( "Enqueued %s\n", ((pND2)PCurrTnode -&gt; link[LEFT])-&gt;text ); if (PCurrTnode -&gt; link[RIGHT] !=NULL) if ( enqueue ( queue, free_list, PCurrTnode -&gt; link[RIGHT] ) == 0 )//将PCurrTnode所指节点的右孩子入队 &#123; printf ( "Error enqueueing %s\n", ((pND2)PCurrTnode -&gt; link[RIGHT])-&gt;text ); exit ( EXIT_FAILURE ); &#125; else printf ( "Enqueued %s\n", ((pND2)PCurrTnode -&gt; link[RIGHT])-&gt;text ); &#125; return TREE_OK;&#125;main(int argc, char **argv)&#123; char inbuf[BUFLEN], *s; Bintree *tree; Mynode *dummy; /* create a dummy node for the tree algorithms */ dummy = (Mynode *) InitBintreeNode(sizeof(Mynode)); dummy-&gt;text[0] = 0; /* must contain valid data */ /* create a tree */ tree = NewBintree((Bnode *) dummy, CompareFunc, 1, sizeof(Mynode)); for (;;) &#123; fputs("Action (? for help): ", stdout); fflush(stdout); fgets(inbuf, BUFLEN, stdin); s = inbuf + strlen(inbuf); while(iscntrl(*s)) *s-- = 0; switch (inbuf[0]) &#123; case '?': fputs( "@file - Load strings in file to tree\n" "d string - Delete string from tree\n" "dup [0|1] - Disallow/allow duplicates\n" "s [file] - Display tree (overwrite file)\n" "w - Walk tree, running ShowFunc()\n" "t - travel tree by level, running ShowFunc()\n" "q - Quit\n" , stdout); fflush(stdout); break; case '@': LoadFile(tree, inbuf + 1); break; case 'd': if (inbuf[1] == 'u' &amp;&amp; inbuf[2] == 'p') &#123; if (inbuf[3] == ' ' &amp;&amp; (inbuf[4] == '0' || inbuf[4] == '1')) tree -&gt; DuplicatesOk = inbuf[4] == '0' ? 0 : 1; fputs("Duplicates are ", stdout); if (tree -&gt; DuplicatesOk == 0) fputs("not ", stdout); fputs("allowed.\n", stdout); break; &#125; if (inbuf[1] != ' ' || inbuf[2] == 0) fputs(" Not a valid command\n", stdout); else DeleteString(tree, inbuf + 2); break; case 's': if (inbuf[1] == ' ' &amp;&amp; inbuf[2] != 0) xWalkBintree(tree, inbuf + 2, inbuf[0] == 's' ? "w" : "a"); else xWalkBintree(tree, NULL, NULL); break; case 'w': WalkBintree(tree, ShowFunc); break; case 't': LevelTraBintree(tree, ShowFunc); break; case 'q': return; case ';': break; /* comment */ default: fputs(" Not a valid command\n", stdout); break; &#125; &#125;&#125;#endif 5. 测试5.1 若键盘依次输入3个命令“@Lab4.DAT”、“s”和“t”，则程序运行结果为： 5.2 若键盘依次输入3个命令：“d 12”、“s”和“t”，则程序运行结果: 5.3 若键盘依次输入3个命令：“d 20”、“s”和“t”，则程序运行结果： 附件：文件Lab4.DAT内容如下：1234567891020102212150608012500]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>queue</tag>
        <tag>layer travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS之迷宫最小步数]]></title>
    <url>%2Fpost%2Fe3e5434c.html</url>
    <content type="text"><![CDATA[问题：给定一个n*m大小迷宫，@代表不可通过墙壁，.代表平地，S起点，T终点。 12345......*.*..*S*..***....T* 代码与解析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100;struct node&#123; int x, y; int step;&#125;S, T, Node;int n, m;char maze[maxn][maxn]; //迷宫信息bool inq[maxn][maxn] = &#123;false&#125;; //记录是否入过队int X[] = &#123;0, 0, -1, 1&#125;;//用X，Y数组来来表示上下左右移动大小int Y[] = &#123;-1, 1, 0, 0&#125;;//测试（x, y）是否有效bool test(int x, int y)&#123; if(x &gt;= n || x &lt; 0 || y &gt;= m || y &gt; 0) return false; if(inq[x][y] == true) return false; if(maze[x][y] == '*') return false; return true;&#125;//BFS算法int BFS()&#123; queue&lt;node&gt; q; q.push(S); while(!q.empty())&#123; node top = q.front(); q.pop(); if(top.x == T.x &amp;&amp; top.y == T.y) return top.step; for (int i = 0; i &lt; 4; ++i) &#123; int newX = top.x + X[i]; int newY = top.y + Y[i]; if(test(newX, newY))&#123; Node.x = newX; Node.y = newY; Node.step = top.step + 1; q.push(Node); inq[newX][newY] = true; &#125; &#125; &#125; return -1;&#125;int main(int argc, char const *argv[])&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; getchar(); for (int j = 0; j &lt; m; ++j) &#123; maze[i][j] = getchar(); &#125; maze[i][m+1] = '\0'; &#125; scanf("%d%d%d%d", &amp;S.x, &amp;S.y, &amp;T.x, &amp;T.y); S.step = 0; printf("The layer: %d\n", BFS()); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise6]]></title>
    <url>%2Fpost%2F8be67e2d.html</url>
    <content type="text"><![CDATA[Case Study: Dice Poker1. Program Specification&ensp;&ensp;Our goal is to write a game program that allows a user to play video poker using dice. The program will display a hand consisting of five dice. The basic set of rules is as follows: The player starts with $100. Each round costs $10 to play. This amount is subtracted from the player’s money at the start of the round. The player initially rolls a completely random hand (i.e., all five dice are rolled). The player gets two chances to enhance the hand by rerolling some or all of the dice. At the end of the hand, the player’s money is updated according to the following payout schedule: hand pay Two Pairs $5 Three of a Kind $8 Full House (A Pair and a Three of a Kind) $12 Four of a Kind $15 Straight (1-5 or 2-6) $20 Five of a Kind $30 &ensp;&ensp;Ultimately, we want this program to present a nice graphical interface. Our interaction will be through mouse clicks. The interface should have the following characteristics: The current score (amount of money) is constantly displayed. The program automatically terminates if the player goes broke. The player may choose to quit at appropriate points during play. The interface will present visual cues to indicate what is going on at any given moment and what the valid user responses are. The interface looks like: 2. Identifying Candidate ObjectsCandidate Objects including: the Dice class constuctor rollAll roll values score A PokerApp object run playRound doRolls A PokerInterface object setMoney setDice wantToPlay showResult chooseDice 3.Implementing the Model3.1 Implementing Dice&ensp;&ensp;The Dice class implements a collection of dice, which are just changing numbers. The obvious representation is to use a list of five ints. 12345678910111213141516171819202122232425262728293031323334353637383940from random import *class Dice: def __init__(self): self.dice = [0]*5 self.rollAll() def roll(self, which): for pos in which: self.dice[pos] = randrange(1, 7) def rollAll(self): self.roll(range(5)) def values(self): return self.dice[:] def score(self): # Create the counts list # Counts[i] will be the number of times that the value i occurs in dice. # if the dice are: [3,2,5,2,3] then the counts list would be [0,0,2,2,0,1,0] counts = [0]*7 for value in self.dice: counts[value] = counts[value] + 1 # score the hand if 5 in counts: return &quot;Five of a Kind&quot; , 30 elif 4 in counts: return &quot;Four of a Kind&quot; , 15 elif (3 in counts) and (2 in counts) : return &quot;Full House&quot;, 12 elif 3 in counts: return &quot;Three of a Kind&quot;, 8 elif not (2 in counts) and (counts[1] == 0 or counts[6] == 0): return &quot;Straight&quot;, 20 elif counts.count(2) == 2: return &quot;Two Pairs&quot;, 5 else: return &quot;Garb age&quot;, 0 &ensp;&ensp;At this point, we could try out the Dice class to make sure that it is working correctly. Here is a short interaction showing some of what the class can do: 1234from dice import Diced = Dice()print(d.values())print(d.score()) 3.2 Implementing PokerApp&ensp;&ensp;Now we are ready to turn our attention to the task of actually implementing the poker game. We can use top-down design to flesh out the details and also suggest what methods will have to be implemented in the Poker Interface class. 1234567891011121314151617181920212223242526272829303132from dice import Diceclass PokerApp: def __init__(self, interface): self.dice = Dice() self.money = 100 self.interface = interface def run(self): while self.money &gt;= 10 and self.interface.wantToPlay(): self.playRound() self.interface.close() def playRound(self): self.money = self.money - 10 self.interface.setMoney(self.money) self.doRolls() result, score = self.dice.score() self. interface. showResult (result, score) self.money = self.money + score self.interface.setMoney(self.money) def doRolls(self): self.dice.rollAll() roll = 1 self.interface.setDice(self.dice.values()) toRoll = self.interface.chooseDice() while roll &lt; 3 and toRoll != []: self.dice.roll(toRoll) roll = roll + 1 self.interface.setDice(self.dice.values()) if roll &lt; 3: toRoll = self.interface.chooseDice() 3.3 A Text-Based Ul&ensp;&ensp;In designing PokerApp, we have also developed a specification for a generic Pokerinterface class. Our interface must support the methods for displaying information: setMoney, setDice, and showResul t. It must also have methods that allow for input from the user: wantToPlay and chooseDice. These methods can be implemented in many different ways, producing programs that look quite different even though the underlying model, PokerApp, remains the same. 12345678910111213141516171819202122class TextInterface: def __init__(self): print(&quot;Welcome to video poker.&quot;) def setMoney(self, amt): print(&quot;You currently have $&#123;0&#125;.&quot;.format(amt)) def setDice(self, values): print(&quot;Dice:&quot;, values) def wantToPlay(self): ans = input(&quot;Do you wish to try your luck? &quot;) return ans[0] in &quot;yY&quot; def close(self): print(&quot;\nThanks for playing!&quot;) def showResult(self, msg, score): print(&quot;&#123;0&#125;. You win $&#123;1&#125;.&quot;.format(msg, score)) def chooseDice(self): return eval(input(&quot;Enter list of which to change ([] to stop) &quot;)) &ensp;&ensp;Using this interface, we can test out our PokerApp program to see whether we have implemented a correct model. Here is a complete program making use of the modules that we have developed: 123456from pokerapp import PokerAppfrom textpoker import TextInterfaceinter = TextInterface()app = PokerApp(inter)app.run() &ensp;&ensp;Basically, all this program does is create a text -based interface and then build a PokerApp using this interface and start it running. Instead of creating a separate module for this, we could also just add the necessary launching code at the end of our textpoker module. When running this program, we get a rough but usable interaction: 1234567891011121314151617181920212223242526272829Welcome to video poker.Do you wish to try your luck? yYou currently have $90 .Dice: [6 , 4, 4, 2, 4]Enter list of which to change ([] to stop) [0 ,4]Dice: [1, 4, 4, 2, 2]Enter list of which to change ([] to stop) [0]Dice: [2 , 4, 4, 2, 2]Full House. You win $12.You currently have $102 .Do you wish to try your luck? yYou currently have $92 .Dice: [5 , 6, 4, 4, 5]Enter list of which to change ( [] to stop) [1]Dice: [5&apos; 5&apos; 4&apos; 4&apos; 5]Enter list of which to change ( [] to stop) []Full House. You win $12.You currently have $104 .Do you wish to try your luck? yYou currently have $94 .Dice: [3&apos; 2, 1, 1, 1]Enter list of which to change ( [] to stop) [0&apos; 1]Dice: [5&apos; 6&apos; 1, 1, 1]Enter list of which to change ( [] to stop) [0&apos; 1]Dice: [1&apos; 5&apos; 1, 1, 1]Four of a Kind. You win $15.You currently have $109 .Do you wish to try your luck? nThanks for playing! &ensp;&ensp;You can see how this interface provides just enough so that we can test out the model. In fact, we’ve got a game that’s already quite a bit of fun to play! 4. Developing a GUI&ensp;&ensp;Now that we have a working program, let’s turn our attention to a graphical interface. Our first step must be to decide exactly how we want our interface to look and function. The interface will have to support the various methods found in the text-based version and will also probably have some additional helper methods. 4.1 Designing the Interaction&ensp;&ensp;Let’s start with the basic methods that must be supported and decide exactly how interaction with the user will occur. Clearly, in a graphical interface, the faces of the dice and the current score should be continuously displayed. The setDice and setMoney methods will be used to change those displays. That leaves one output method, showResult, that we need to accommodate. One common way to handle this sort of transient information is with a message at the bottom of the window. This is sometimes called a status bar.&ensp;&ensp;To get information from the user, we will make use of buttons. In wantToPlay, the user will have to decide between either rolling the dice or quitting. We could include “Roll Dice” and “Quit” buttons for this choice. That leaves us with figuring out how the user should choose dice.&ensp;&ensp;To implement chooseDice, we could provide a button for each die and have the user click the buttons for the dice they want to roll. When the user is done choosing the dice, they could click the “Roll Dice” button again to roll the selected dice. Elaborating on this idea, it would be nice if we allowed the user to change his or her mind while selecting the dice. Perhaps clicking the button of a currently selected die would cause it to become deselected. The clicking of the button will serve as a sort of toggle that selects/unselects a particular die. The user commits to a certain selection by clicking on “Roll Dice.”&ensp;&ensp;Our vision for chooseDice suggests a couple of tweaks for the interface. First, we should have some way of showing the user which dice are currently selected. There are lots of ways we could do this. One simple approach would be to change the color of the dice. Let’s “gray out” the pips on the dice selected for rolling. Second, we need a good way for the user to indicate that they wish to stop rolling. That is, they would like the dice scored just as they stand. We could handle this by having them click the “Roll Dice” button when no dice are selected, hence asking the program to roll no dice. Another approach would be to provide a separate button to click that causes the dice to be scored. The latter approach seems a bit more intuitive/informative. Let’s add a “Score” button to the interface.&ensp;&ensp;Now we have a basic idea of how the interface will function. We still need to figure out how it will look. What is the exact layout of the widgets? The figure above is a sample of how the interface might look. I’m sure those of you with a more artistic eye can come up with a more pleasing interface, but we’ll use this one as our working design. 4.2 Managing the Widgets&ensp;&ensp;The graphical interface that we are developing makes use of buttons and dice. Our intent is to reuse the Button and DieView classes. Button This class needs the graphics class that we developed in previous exercise. 1234567891011121314151617181920212223242526272829303132333435363738394041from graphics import *class Button: &quot;&quot;&quot; A button is a labeled rectangle in a window. It is activated or deactivated with the activate() and deactivate() methods.The clicked(p) method returns true if the button is active and pi s inside it. &quot;&quot;&quot; def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = False DieView the class constructor draws a square and seven circles to represent the positions where the pips of various values will appear. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from graphics import *class DieView: &quot;&quot;&quot; DieView is a widget that displays a graphical representation of a standard six-sided die. &quot;&quot;&quot; def __init__(self, win, center, size): &quot;&quot;&quot;Create a view of a die, e.g. : d1 = GDie(myWin, Point (40,50) , 20) creates a die centered at (40,50) having sides of length 20.&quot;&quot;&quot; # first define some standard values self.win = win self.background = &quot;white&quot; # color of die face self.foreground = &quot;black&quot; # color of the pips self.psize = 0.1 * size #radius of each pip hsize = size/2.0 # half of size offset = 0.6 * hsize # distance from center to outer pips # create a square for the face cx, cy = center.getX(), center.getY() p1 = Point(cx - hsize, cy - hsize) p2 = Point(cx + hsize, cy + hsize) rect = Rectangle(p1, p2) rect.draw(win) rect.setFill(self.background) # Create 7 circles for standard pip locations self.pips = [self.__makePip(cx - offset, cy - offset), self.__makePip(cx - offset, cy), self.__makePip(cx - offset, cy + offset), self.__makePip(cx, cy), self.__makePip(cx + offset, cy - offset), self.__makePip(cx + offset, cy), self.__makePip(cx + offset, cy + offset)] # Create a table for which pips are on for each value self.onTable = [[], [3], [2, 4], [2, 3, 4], [0, 2, 4, 6],[0,2,3,4,6],[0, 1, 2, 4, 5, 6]] self.setValue(1) def __makePip(self, x, y): &quot;&quot;&quot;Internal helper method to draw a pip at(x, y)&quot;&quot;&quot; pip = Circle(Point(x, y), self.psize) pip.setFill(self.background) pip.setOutline(self.background) pip.draw(self.win) return pip def setValue(self, value): &quot;&quot;&quot; Set this die to display value.&quot;&quot;&quot; # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground)class ColorDieView(DieView): def setValue(self, value): self.value = value DieView.setValue(self, value) def setColor(self, color): self.foreground = color self.setValue(self.value) 4.3 Creating the Interface&ensp;&ensp;Now that we have our widgets under control, we are ready to actually implement our GUI poker interface. The constructor will create all of our widgets, setting up the interface for later interactions: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from button import Buttonfrom graphics import *from dieview2 import DieView, ColorDieViewfrom dice import Diceclass Graphicsinterface: def __init__(self): self.win = GraphWin(&quot;Dice Poker&quot;, 600, 400) self.win.setBackground(&quot;green3&quot;) banner = Text(Point(300, 30), &quot;Python Poker Parlor&quot;) banner.setSize(24) banner.setFill(&quot;yellow2&quot;) banner.setStyle(&quot;bold&quot;) banner.draw(self.win) self.msg = Text(Point(300, 380), &quot;Welcome to the Dice Table&quot;) self.msg.setSize(18) self.msg.draw(self.win) self.createDice(Point(300, 100), 75) self.buttons = [] self.addDiceButtons(Point(300, 170), 75, 30) b = Button(self.win, Point(300, 230), 400, 40, &quot;Roll Dice&quot;) self.buttons.append(b) b = Button(self.win, Point(300, 280), 150, 40, &quot;Score&quot;) self.buttons.append(b) b = Button(self.win, Point(570, 375), 40, 30, &quot;Quit&quot;) self.buttons.append(b) self.money = Text(Point(300, 325), &quot;$100&quot;) self.money.setSize(18) self.money.draw(self.win) def choose(self, choices): buttons = self.buttons # activate choice buttons, deactivate others for b in buttons: if b.getLabel() in choices: b.activate() else: b.deactivate() # get mouse clicks unt il an active button is clicked while True: p = self.win.getMouse() for b in buttons: if b.clicked(p): return b.getLabel() # function ex it here. def setValue(self, value): # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground) def createDice(self, center, size): center.move(-3 * size, 0) self.dice = [] for i in range(5): view = ColorDieView(self.win, center, size) self.dice.append(view) center.move(1.5 * size, 0) def setColor(self, color): self.foreground = color self.setValue(self.value) def addDiceButtons(self, center, width, height): center.move(-3 * width, 0) for i in range(1, 6): label = &quot;Die &#123;0&#125;&quot;.format(i) b = Button(self.win, center, width, height, label) self.buttons.append(b) center.move(1.5 * width, 0) def setMoney(self, amt): self.money.setText(&quot;$&#123;0&#125;&quot;.format(amt)) def showResult(self, msg, score): if score &gt; 0: text = &quot;&#123;0&#125; ! You win $&#123;1&#125;&quot;.format(msg, score) else: text = &quot;You rolled &#123;0&#125;&quot;.format(msg) self.msg.setText(text) def setDice(self, values): for i in range(5): self.dice[i].setValue(values[i]) def wantToPlay(self): ans = self.choose([&quot;Roll Dice&quot;, &quot;Quit&quot;]) self.msg.setText(&quot;&quot;) return ans == &quot;Roll Dice&quot; def chooseDice(self): # choices is a list of the indexes of the selected dice choices = [] # No dice chosen yet while True: # wait for user to click a valid button b = self.choose([&quot;Die 1&quot;, &quot;Die 2&quot;, &quot;Die 3&quot;, &quot;Die 4&quot;, &quot;Die 5&quot;, &quot;Roll Dice&quot;, &quot;Score&quot;]) if b[0] == &quot;D&quot;: i = int(b[4]) - 1 if i in choices: choices.remove(i) self.dice[i].setColor(&quot;black&quot;) else: choices.append(i) self.dice[i].setColor(&quot;gray&quot;) else: for d in self.dice: d.setColor(&quot;black&quot;) if b == &quot;Score&quot;: return [] elif choices != []: return choices def close(self): self.win.close() &ensp;&ensp;Finally, we need a few lines to actually get our graphical poker-playing program started. This code is exactly like the start code for the textual version, except that we use a Graphicsinterface in place of the Textinterface: 123456from graphicspoker import Graphicsinterfacefrom pokerapp import PokerAppinter = Graphicsinterface()app = PokerApp(inter)app.run() 5. The Completed Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290from graphics import *from random import randrangefrom random import *class Dice: def __init__(self): self.dice = [0]*5 self.rollAll() def roll(self, which): for pos in which: self.dice[pos] = randrange(1, 7) def rollAll(self): self.roll(range(5)) def values(self): return self.dice[:] def score(self): # Create the counts list # Counts[i] will be the number of times that the value i occurs in dice. # if the dice are: [3,2,5,2,3] then the counts list would be [0,0,2,2,0,1,0] counts = [0]*7 for value in self.dice: counts[value] = counts[value] + 1 # score the hand if 5 in counts: return &quot;Five of a Kind&quot; , 30 elif 4 in counts: return &quot;Four of a Kind&quot; , 15 elif (3 in counts) and (2 in counts) : return &quot;Full House&quot;, 12 elif 3 in counts: return &quot;Three of a Kind&quot;, 8 elif not (2 in counts) and (counts[1] == 0 or counts[6] == 0): return &quot;Straight&quot;, 20 elif counts.count(2) == 2: return &quot;Two Pairs&quot;, 5 else: return &quot;Garbage&quot;, 0class PokerApp: def __init__(self, interface): self.dice = Dice() self.money = 100 self.interface = interface def run(self): while self.money &gt;= 10 and self.interface.wantToPlay(): self.playRound() self.interface.close() def playRound(self): self.money = self.money - 10 self.interface.setMoney(self.money) self.doRolls() result, score = self.dice.score() self. interface. showResult (result, score) self.money = self.money + score self.interface.setMoney(self.money) def doRolls(self): self.dice.rollAll() roll = 1 self.interface.setDice(self.dice.values()) toRoll = self.interface.chooseDice() while roll &lt; 3 and toRoll != []: self.dice.roll(toRoll) roll = roll + 1 self.interface.setDice(self.dice.values()) if roll &lt; 3: toRoll = self.interface.chooseDice()class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = Falseclass DieView: &quot;&quot;&quot; DieView is a widget that displays a graphical representation of a standard six-sided die.&quot;&quot;&quot; def __init__(self, win, center, size): &quot;&quot;&quot;Create a view of a die, e.g. : d1 = GDie(myWin, Point (40,50) , 20) creates a die centered at (40,50) having sides of length 20.&quot;&quot;&quot; # first define some standard values self.win = win self.background = &quot;white&quot; # color of die face self.foreground = &quot;black&quot; # color of the pips self.psize = 0.1 * size #radius of each pip hsize = size/2.0 # half of size offset = 0.6 * hsize # distance from center to outer pips # create a square for the face cx, cy = center.getX(), center.getY() p1 = Point(cx - hsize, cy - hsize) p2 = Point(cx + hsize, cy + hsize) rect = Rectangle(p1, p2) rect.draw(win) rect.setFill(self.background) # Create 7 circles for standard pip locations self.pips = [self.__makePip(cx - offset, cy - offset), self.__makePip(cx - offset, cy), self.__makePip(cx - offset, cy + offset), self.__makePip(cx, cy), self.__makePip(cx + offset, cy - offset), self.__makePip(cx + offset, cy), self.__makePip(cx + offset, cy + offset)] # Create a table for which pips are on for each value self.onTable = [[], [3], [2, 4], [2, 3, 4], [0, 2, 4, 6],[0,2,3,4,6],[0, 1, 2, 4, 5, 6]] self.setValue(1) def __makePip(self, x, y): &quot;&quot;&quot;Internal helper method to draw a pip at(x, y)&quot;&quot;&quot; pip = Circle(Point(x, y), self.psize) pip.setFill(self.background) pip.setOutline(self.background) pip.draw(self.win) return pip def setValue(self, value): &quot;&quot;&quot; Set this die to display value.&quot;&quot;&quot; # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground)class ColorDieView(DieView): def setValue(self, value): self.value = value DieView.setValue(self, value) def setColor(self, color): self.foreground = color self. setValue(self.value)class Graphicsinterface: def __init__(self): self.win = GraphWin(&quot;Dice Poker&quot;, 600, 400) self.win.setBackground(&quot;green3&quot;) banner = Text(Point(300, 30), &quot;Python Poker Parlor&quot;) banner.setSize(24) banner.setFill(&quot;yellow2&quot;) banner.setStyle(&quot;bold&quot;) banner.draw(self.win) self.msg = Text(Point(300, 380), &quot;Welcome to the Dice Table&quot;) self.msg.setSize(18) self.msg.draw(self.win) self.createDice(Point(300, 100), 75) self.buttons = [] self.addDiceButtons(Point(300, 170), 75, 30) b = Button(self.win, Point(300, 230), 400, 40, &quot;Roll Dice&quot;) self.buttons.append(b) b = Button(self.win, Point(300, 280), 150, 40, &quot;Score&quot;) self.buttons.append(b) b = Button(self.win, Point(570, 375), 40, 30, &quot;Quit&quot;) self.buttons.append(b) self.money = Text(Point(300, 325), &quot;$100&quot;) self.money.setSize(18) self.money.draw(self.win) def choose(self, choices): buttons = self.buttons # activate choice buttons, deactivate others for b in buttons: if b.getLabel() in choices: b.activate() else: b.deactivate() # get mouse clicks unt il an active button is clicked while True: p = self.win.getMouse() for b in buttons: if b.clicked(p): return b.getLabel() # function ex it here. def setValue(self, value): # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground) def createDice(self, center, size): center.move(-3 * size, 0) self.dice = [] for i in range(5): view = ColorDieView(self.win, center, size) self.dice.append(view) center.move(1.5 * size, 0) def setColor(self, color): self.foreground = color self.setValue(self.value) def addDiceButtons(self, center, width, height): center.move(-3 * width, 0) for i in range(1, 6): label = &quot;Die &#123;0&#125;&quot;.format(i) b = Button(self.win, center, width, height, label) self.buttons.append(b) center.move(1.5 * width, 0) def setMoney(self, amt): self.money.setText(&quot;$&#123;0&#125;&quot;.format(amt)) def showResult(self, msg, score): if score &gt; 0: text = &quot;&#123;0&#125; ! You win $&#123;1&#125;&quot;.format(msg, score) else: text = &quot;You rolled &#123;0&#125;&quot;.format(msg) self.msg.setText(text) def setDice(self, values): for i in range(5): self.dice[i].setValue(values[i]) def wantToPlay(self): ans = self.choose([&quot;Roll Dice&quot;, &quot;Quit&quot;]) self.msg.setText(&quot;&quot;) return ans == &quot;Roll Dice&quot; def chooseDice(self): # choices is a list of the indexes of the selected dice choices = [] # No dice chosen yet while True: # wait for user to click a valid button b = self.choose([&quot;Die 1&quot;, &quot;Die 2&quot;, &quot;Die 3&quot;, &quot;Die 4&quot;, &quot;Die 5&quot;, &quot;Roll Dice&quot;, &quot;Score&quot;]) if b[0] == &quot;D&quot;: i = int(b[4]) - 1 if i in choices: choices.remove(i) self.dice[i].setColor(&quot;black&quot;) else: choices.append(i) self.dice[i].setColor(&quot;gray&quot;) else: for d in self.dice: d.setColor(&quot;black&quot;) if b == &quot;Score&quot;: return [] elif choices != []: return choices def close(self): self.win.close()def main(): inter = Graphicsinterface() app = PokerApp(inter) app.run()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BST Summary]]></title>
    <url>%2Fpost%2Ffdb1de24.html</url>
    <content type="text"><![CDATA[Data Structure – BST1. 定义：BST(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 2.基本操作主要包括：查找、插入、建立、删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798struct node &#123; int data; node *lchild; node *rchild;&#125;;// 新建节点，返回一个节点指针node* newNode(int v)&#123; node* Node = new node; Node-&gt;data = v; Node-&gt;lchild = Node-&gt;rchild = NULL; return Node;&#125;// search x 只需搜索一边子树即可,O(h) h表示树高void search(node* root, int x)&#123; if(root == NULL) &#123; printf(&quot;search failed!\n&quot;); return; &#125; if(x == root-&gt;data) printf(&quot;%d\n&quot;, root-&gt;data); else if(x &lt; root-&gt;data) search(root-&gt;lchild, int x); else search(root-&gt;rchild, int x);&#125;// insert x 当root==NULL时，即为插入之处 O(h)void insert(node* &amp;root, int x)&#123; if(root == NULL)&#123; root = newNode(x); return; &#125; if(x == root-&gt;data) return; else if(x &lt; root-&gt;data) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// BST的建立(注意：同一组数据，如果插入的顺序不同最后形成的BST可能也不同)// 复杂度O(h)*n = O(nlog2n)node *Create(int data[], int n)&#123; node* root = NULL; for (int i = 0; i &lt; n; ++i) &#123; insert(root, data[i]); &#125; return root;&#125;//BST的节点删除，删除根节点//删除根节点后，用直接后继或者直接前驱来替换//直接前驱：左子树一直向右直到某一节点的右子树为NULL的节点//直接后继：右子树一直向左直到某一节点的左子树为NULL的节点//FindMin()函数用于寻找树root的最小权值节点node* FindMin(node* root)&#123; while(root-&gt;lchild != NULL) root = root-&gt;lchild; return root;&#125;//FindMax()函数用于寻找树root的最大权值节点node* FindMax(node* root)&#123; while(root-&gt;rchild != NULL) root = root-&gt;rchild; return root;&#125;/*BST删除节点步骤:1. 当前节点root空，直接返回2. 当前节点root的data值等于x，进入删除操作 a)当前节点root为叶子节点，直接删除。 b)当前节点root存在左子树，找到前驱pre，覆盖root，删除pre c)当前节点root存在右子树，找到后继next，覆盖root，删除next3. 若当前节点root权值大于x，则root = root-&gt;lchild 递归删除4. 若当前节点root权值小于x，则root = root-&gt;rchild 递归删除*/void deleteNode(node* &amp;root, int x)&#123; if(root == NULL) return; if(root-&gt;data == x) &#123; if(root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) root = NULL; else if(root-&gt;lchild != NULL) &#123; node *pre = FindMax(root-&gt;lchild); root-&gt;data = pre-&gt;data; deleteNode(root-&gt;lchild, pre-&gt;data); //删除pre节点 &#125; else &#123; node* next = FindMin(root-&gt;rchild); root-&gt;data = next-&gt;data; deleteNode(root-&gt;rchild, next-&gt;data); //删除next 节点 &#125; &#125; else if(root-&gt;data &gt; x) deleteNode(root-&gt;lchild, x); else deleteNode(root-&gt;rchild, x);&#125; 3. 应用利用PAT1043_Is It a Binary Search Tree 来练习一下BST。 1043 Is It a Binary Search Tree （25 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST.Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:1278 6 5 7 10 8 11 Sample Output 1:12YES5 7 6 8 11 10 8 Sample Input 2:1278 10 11 8 6 7 5 Sample Output 2:12YES11 8 10 7 5 6 8 Sample Input 3:1278 6 8 5 10 9 11 Sample Output 3:1NO Code and Analysis:(1) 题意：判断给定序列是不是BST或者BST的镜像的先序遍历序列。是，输出YES和后序遍历序列；否，输出NO结束。(2) 思路步骤： 对给定的序列建立BST 对BST先序遍历，后序遍历，BST镜像先序遍历，BST镜像后序遍历 将给定序列与BST先序遍历，BST镜像先序遍历比较，相等，输出YES和对应后序序列，不相等，输出NO。 (3) 数据结构：用vector存储给定序列origin, BST先序序列pre, BST后序序列post, BST镜像先序序列preM, BST镜像后序序列postM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int data; node* lchild; node* rchild;&#125;;void insert(node* &amp;root, int x)&#123; if(root == NULL) &#123; root = new node; root-&gt;data = x; root-&gt;lchild = root-&gt;rchild = NULL; return; &#125; else if(root-&gt;data &gt; x) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// 先序遍历：中左右 --- 镜像先序遍历：中右左// 后序遍历：左右中 --- 镜像后序遍历：右左中// 中序遍历：左中右 --- 镜像中序遍历：右中左void preOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preOrder(root-&gt;lchild, vi); preOrder(root-&gt;rchild, vi);&#125;void preMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preMirror(root-&gt;rchild, vi); preMirror(root-&gt;lchild, vi);&#125;void postOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postOrder(root-&gt;lchild, vi); postOrder(root-&gt;rchild, vi); vi.push_back(root-&gt;data);&#125;void postMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postMirror(root-&gt;rchild, vi); postMirror(root-&gt;lchild, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, post, preM, postM;int main(int argc, char const *argv[])&#123; int n, data; node* root = new node; root = NULL; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;data); origin.push_back(data); insert(root, data); &#125; preOrder(root, pre); preMirror(root, preM); postOrder(root, post); postMirror(root, postM); if(origin == pre)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;,post[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else if(origin == preM)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;, postM[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else printf(&quot;NO\n&quot;); return 0;&#125;/*78 6 5 7 10 8 11 */]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Traversal</tag>
        <tag>Order</tag>
        <tag>BST</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise5]]></title>
    <url>%2Fpost%2F12ef2f97.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是我们老师布置的作业，以下是我的一些总结。 1. Programming Exercise Modify the cannonball simulation from the chapter so that it also calculates the maximum height achieved by the cannonball. Program Specification Suppose we want to write a program that simulates the flight of a cannonball (or any other projectile such as a bullet, baseball, or shot put). We are particularly interested in finding out how far the cannonball will travel when fired at various launch angles and initial velocities. The input to the program will be the launch angle (in degrees), the initial velocity (in meters per second), and the initial height (in meters) of the cannonball. The output will be the distance that the projectile travels before striking the ground (in meters). In addition, the program also can calculate the maximum height. 2. Code and Analysis2.1 The First Version&ensp;&ensp;Let’s start by designing an algorithm. Given the problem statement, it’s clear that we need to consider the flight of the cannonball in two dimensions: height, so we know when it hits the ground; and distance, to keep track of how far it goes. We can think of the position of the cannonball as a point ( x, y) in a 2D graph where the value of y gives the height above the ground and the value of x gives the distance from the starting point. &ensp;&ensp;The Projectile class must have an init method that uses these values to initialize the instance variables of cball. But what should the instance variables be? Of course, they will be the four pieces of information that characterize the flight of the cannonball: xpos, ypos, xvel, yvel and MaxHeight. &ensp;&ensp; Notice how we have created five instance variables inside the object using the self dot notation. The value of theta is not needed after ini t terminates, so it is just a normal (local) function variable. The methods for accessing the position of our projectiles are straightforward; the current position is given by the instance variables xpos, ypos and MaxHeight. We just need a couple of methods that return these values. &ensp;&ensp;Finally, we come to the update method. This method takes a single normal parameter that represents an interval of time. We need to update the state of the projectile to account for the passage of that much time. Here’s the code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from math import sin, cos, radiansclass Projectile: def __init__(self, angle, velocity, height): self.xpos = 0.0 self.ypos = height theta = radians(angle) self.xvel = velocity * cos(theta) self.yvel = velocity * sin(theta) self.MaxHeight = self.ypos def update(self, time): self.xpos = self.xpos + time * self.xvel yvel1 = self.yvel - 9.8 * time self.ypos = self.ypos + time * (self.yvel + yvel1) / 2.0 self.yvel = yvel1 if self.ypos &gt; self.MaxHeight: self.MaxHeight = self.ypos def getY(self): return self.ypos def getX(self): return self.xpos def getMaxHeight(self): return self.MaxHeightdef getInputs(): a = float(input(&quot;Enter the launch angle (in degrees): &quot;)) v = float(input(&quot;Enter the initial velocity (in meters/sec): &quot;)) h = float(input(&quot;Enter the initial height (in meters): &quot;)) t = float(input(&quot;Enter the time interval between position calculations: &quot;)) return a, v, h, tdef main(): angle, vel, h0, time = getInputs() cball = Projectile(angle, vel, h0) cball.update(time) while cball.getY() &gt;= 0: cball.update(time) print(&quot;\nDistance traveled: &#123;0:0.1f&#125; meters.&quot;. format(cball.getX())) print(cball.xvel) print(cball.getMaxHeight())if __name__ == &quot;__main__&quot;: main() 2.2 The Second Version&ensp;&ensp;Based on the first version, let’s use our new object ideas to add a nicer interface to the cannonball example that started the chapter. Instead of having a boring text -based interface, the program would be more fun to use if it had a graphical interface. It would be nice to actually “see” where the canonball ends up and how it gets there. Figure 10.4 shows what I have in mind. Here you can see a cannonball currently in flight as well as where two previous shots ended. 2.2.1 Creating a Graphics Window&ensp;&ensp;The first step in the program is to create a graphics window and draw the appropriate scale line across the bottom. Using our graphics library; this is straightforward. Here’s the start of the program:123456789101112def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) 2.2.2 ShotTracker Class&ensp;&ensp;The next thing we need is a graphical object that acts like a cannonball. We can use our existing Projectile class to model the flight of a cannonball, but a Projectile is not a graphics object; we can’t draw it in the window. On the other hand, a Circle is a good candidate for the graphical representation of the cannonball, but it does not know how to model projectile flight. What we really want is something that has elements of both. We can create this new hybrid circle-projectile by defining a suitable class for it. Let’s call it a ShotTracker. &ensp;&ensp;Our Shot Tracker will contain both a Projectile and a Circle. Its job is to make sure that these instance variables stay in sync with each other. &ensp;&ensp;Notice how the parameters provide all of the information needed to create both a Projectile and a Circle, which are stored in the instance variables proj and marker, respectively. I used the name marker because the circle is graphically marking the projectile’s current location. I chose the radius 3 because it shows up nicely in the animation. Realistically, a 3-meter radius would be way too large for an actual cannonball. Now that we have a suitable projectile and circle, we just need to ensure that whenever an update occurs, both the projectile and the position of the circle are modified appropriately. We can do that by giving our ShotTracker an update method that handles both pieces. Updating the Projectile object is a simple matter of calling its own update method with the appropriate time interval. For the circle, we calculate the distance it must move in the x and y directions to put the center of the circle where the updated projectile is located. 12345678910111213141516171819202122232425262728293031323334353637class ShotTracker(object): def __init__(self, win, angle, velocity, height): &quot;&quot;&quot; win is the GraphWin to display the shot. angle, velocity, and height are initial projectile parameters. &quot;&quot;&quot; self.proj = Projectile(angle, velocity, height) self.marker = Circle(Point(0, height), 3) self.marker.setFill(&quot;red&quot;) self.marker.setOutline(&quot;red&quot;) self.marker.draw(win) def update(self, dt): &quot;&quot;&quot; Move the shot dt seconds farther along its flight &quot;&quot;&quot; # update the projectile self.proj.update(dt) # move the circle to the new projectile location center = self.marker.getCenter() dx = self.proj.getX() - center.getX() dy = self.proj.getY() - center.getY() self.marker.move(dx, dy) def getX(self): return self.proj.getX() def getY(self): return self.proj.getY() def getMaxHeight(self): return self.proj.getMaxHeight() def undraw(self): self.marker.undraw() 2.2.3 Creating a Button Class&ensp;&ensp;Our buttons will support the following methods: constructor Creates a button in a window. We will have to specify the window in which the button will be displayed, the location/size of the button, and the label that will be on the button. activate Sets the state of the button to active. deactivate Sets the state of the button to inactive. clicked Indicates whether the button was clicked. If the button is active, this method will determine if the point clicked is inside the button region. The point will have to be sent as a parameter to the method. getLabel Returns the label string of the button. This is provided so that we can identify a particular button.Here’s the code:1234567891011121314151617181920212223242526272829303132class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = False 2.2.4 Creating an Input Dialog&ensp;&ensp;Before we actually put a cannonball in flight, we’ll need to get the projectile parameters angle, velocity, and initial height from the user. We could do this using input, just as in the original program. But as long as we’re designing a graphical interface, we may as well handle the input in a more graphical fashion as well. A common way of getting user input in a GUI is to use a dialog box. For example, in Chapter 5 I discussed using pre-built system dialogs that allow users to select file names. Using the graphics library, we can easily create our own simple dialogs to get information from the user. A dialog box is a sort of miniGUI that serves as an independent component of a larger program. Something like Figure 10.5 will do the trick. The user can change the input values and select either “Fire!” to launch the cannonball or “Quit” to exit the program. As you can see, this is just a Graph Win containing a few Text, Entry, and Button objects.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class InputDialog: def __init__(self, angle, vel, height): self.win = GraphWin(&quot;Initial Values&quot;, 200, 300) win = self.win win.setCoords(0, 5.5, 4, .5) Text(Point(1, 1), &quot;Angle&quot;).draw(win) self.angle = Entry(Point(3, 1), 5).draw(win) self.angle.setText(str(angle)) Text(Point(1, 2), &quot;Velocity&quot;).draw(win) self.vel = Entry(Point(3, 2), 5).draw(win) self.vel.setText(str(vel)) Text(Point(1, 3), &quot;Height&quot;).draw(win) self.height = Entry(Point(3, 3), 5).draw(win) self.height.setText(str(height)) Text(Point(1, 4), &quot;MaxHeight&quot;).draw(win) self.maxheight = Entry(Point(3, 4), 5).draw(win) self.fire = Button(win, Point(1, 5), 1.25, .5, &quot;Fire!&quot;) self.fire.activate() self.quit = Button(win, Point(3, 5), 1.25, .5, &quot;Quit&quot;) self.quit.activate() def interact(self): &quot;&quot;&quot; wait for user to click Quit or Fire button Returns a string indicating which button was clicked &quot;&quot;&quot; while True: pt = self.win.getMouse() if self.quit.clicked(pt): return &quot;Quit&quot; if self.fire.clicked(pt): return &quot;Fire!&quot; def getValues(self): a = float(self.angle.getText()) v = float(self.vel.getText()) h = float(self.height.getText()) return a, v, h def close(self): self.win.close() 2.2.5 The Main Event Loop&ensp;&ensp;Now we are ready to finish our program by filling in the main event loop. Here’s the completed main function:123456789101112131415161718192021222324252627282930313233343536def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) angle, vel, height = 45.0, 40.0, 2.0 inputwin = InputDialog(angle, vel, height) while True: # interact with the user choice = inputwin.interact() #inputwin.close() if choice == &quot;Quit&quot;: # loop exit break break angle, vel, height = inputwin.getValues() shot = ShotTracker(win, angle, vel, height) while 0 &lt;= shot.getY() &lt;=155 and -10 &lt; shot.getX() &lt;= 210: shot.update(1 / 50) update(50) inputwin.maxheight.setText(str(shot.getMaxHeight())) #inputwin.close() win.close() The completed program looks like this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204from math import *import mathfrom turtle import *from graphics import *class Projectile(object): def __init__(self, angle, velocity, height): self.xpos = 0.0 self.ypos = height theta = math.pi * angle / 180 self.xvel = velocity * cos(theta) self.yvel = velocity * sin(theta) self.MaxHeight = self.ypos #保存最大高度 def update(self, time): self.xpos = self.xpos + time * self.xvel yvel1 = self.yvel - 9.8 * time self.ypos = self.ypos + time * (self.yvel + yvel1) / 2.0 self.yvel = yvel1 # 获取最大高度保存到Self.MaxHeight中 if self.ypos &gt; self.MaxHeight: self.MaxHeight = self.ypos def getY(self): return self.ypos def getX(self): return self.xpos def getMaxHeight(self): return self.MaxHeight# def getInputs():# a = float(input(&quot;Enter the launch angle (in degrees): &quot;))# v = float(input(&quot;Enter the initial velocity (in meters/sec): &quot;))# h = float(input(&quot;Enter the initial height (in meters): &quot;))# t = float(input(&quot;Enter the time interval between position calculations: &quot;))## return a, v, h, tclass ShotTracker(object): def __init__(self, win, angle, velocity, height): &quot;&quot;&quot; win is the GraphWin to display the shot. angle, velocity, and height are initial projectile parameters. &quot;&quot;&quot; self.proj = Projectile(angle, velocity, height) self.marker = Circle(Point(0, height), 3) self.marker.setFill(&quot;red&quot;) self.marker.setOutline(&quot;red&quot;) self.marker.draw(win) def update(self, dt): &quot;&quot;&quot; Move the shot dt seconds farther along its flight &quot;&quot;&quot; # update the projectile self.proj.update(dt) # move the circle to the new projectile location center = self.marker.getCenter() dx = self.proj.getX() - center.getX() dy = self.proj.getY() - center.getY() self.marker.move(dx, dy) def getX(self): return self.proj.getX() def getY(self): return self.proj.getY() def getMaxHeight(self): return self.proj.getMaxHeight() def undraw(self): self.marker.undraw()class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = Falseclass InputDialog: def __init__(self, angle, vel, height): self.win = GraphWin(&quot;Initial Values&quot;, 200, 300) win = self.win win.setCoords(0, 5.5, 4, .5) Text(Point(1, 1), &quot;Angle&quot;).draw(win) self.angle = Entry(Point(3, 1), 5).draw(win) self.angle.setText(str(angle)) Text(Point(1, 2), &quot;Velocity&quot;).draw(win) self.vel = Entry(Point(3, 2), 5).draw(win) self.vel.setText(str(vel)) Text(Point(1, 3), &quot;Height&quot;).draw(win) self.height = Entry(Point(3, 3), 5).draw(win) self.height.setText(str(height)) Text(Point(1, 4), &quot;MaxHeight&quot;).draw(win) self.maxheight = Entry(Point(3, 4), 5).draw(win) self.fire = Button(win, Point(1, 5), 1.25, .5, &quot;Fire!&quot;) self.fire.activate() self.quit = Button(win, Point(3, 5), 1.25, .5, &quot;Quit&quot;) self.quit.activate() def interact(self): &quot;&quot;&quot; wait for user to click Quit or Fire button Returns a string indicating which button was clicked &quot;&quot;&quot; while True: pt = self.win.getMouse() if self.quit.clicked(pt): return &quot;Quit&quot; if self.fire.clicked(pt): return &quot;Fire!&quot; def getValues(self): a = float(self.angle.getText()) v = float(self.vel.getText()) h = float(self.height.getText()) return a, v, h def close(self): self.win.close()def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) angle, vel, height = 45.0, 40.0, 2.0 inputwin = InputDialog(angle, vel, height) while True: # interact with the user choice = inputwin.interact() #inputwin.close() if choice == &quot;Quit&quot;: # loop exit break break angle, vel, height = inputwin.getValues() shot = ShotTracker(win, angle, vel, height) while 0 &lt;= shot.getY() &lt;=155 and -10 &lt; shot.getX() &lt;= 210: shot.update(1 / 50) update(50) inputwin.maxheight.setText(str(shot.getMaxHeight())) #inputwin.close() win.close()if __name__ == &quot;__main__&quot;: main() Appendix: The graphics library summary: https://blog.csdn.net/winycg/article/details/78066044?locationNum=4&amp;fps=1]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子向量中最大和的四种算法]]></title>
    <url>%2Fpost%2F7e551515.html</url>
    <content type="text"><![CDATA[一、问题描述：来自一维的模式识别输入与输出 输入：具有n个浮点数的向量x 输出：输入向量的任何连续子向量中的最大和。假定输出的最大和为非负数。 二、四种算法与分析 暴力法： 基本思路：对所有满足0 ≤ i ≤ j &lt; n的整数对(i,j)进行检查，判断x[i..j]的总和Sum(x[i..j])是否最大？其中Sum(x[i..j]) 该算法时间复制度为O(n^3) 123456789101112131415float alg1()&#123; int i, j, k; float sum, maxsofar = 0; for (i = 0; i &lt; n; i++) for (j = i; j &lt; n; j++) &#123; sum = 0; for (k = i; k &lt;= j; k++) sum += x[k]; if (sum &gt; maxsofar) maxsofar = sum; &#125; return maxsofar;&#125; 暴力法的一些简化基本思路： 对所有满足0 ≤ i ≤ j &lt; n的整数对(i,j)进行检查，判断x[i..j]的总和sum(x[i..j])是否最大？ 如何计算sum(x[i..j])？ sum(x[i..j]) = sum(x[i..j-1])+x[j] sum(x[i..j]) = sum(x[0..j])-sum(x[0..i-1]) 该算法时间复制度为O(n^2)由以上两种计算sum(x[i..j])，可以得到两种算法 12345678910111213141516171819202122232425262728293031323334353637383940414243//第一种float alg2()&#123; int i, j, k; float sum, maxsofar = 0; for (i = 0; i &lt; n; i++) &#123; sum = 0; for (j = i; j &lt; n; j++) &#123; sum += x[j]; if(sum &gt; maxsofar) maxsofar = sum; &#125; &#125; return maxsofar;&#125;//第二种float cumvec[MAXN + 1];float alg2b()&#123; int i, j, k; float *cumarr, sum, maxsofar = 0; cumarr = cumvec + 1; cumarr[-1] = 0; for(i = 0; i &lt; n; i++) cumarr[i] = cumarr[i - 1] = x[i]; for(i = 0; i &lt; n; i++) &#123; for(j = i; j &lt; n; j++) &#123; sum = cumarr[j] - cumarr[i - 1]; if(sum &gt; maxsofar) maxsofar = sum; &#125; &#125; return maxsofar;&#125; 分治法 分治原理：要解决规模为n的问题，可递归地解决两个规模近似为n/2的子问题，然后对它们的答案进行合并以得到整个问题的答案。 初始问题：找出大小为n的向量x中连续子向量中的最大和mx Step1:将向量x划分为两个大小近似相等的子向量a和b Step2:分别递归地找出a、b中连续子向量中的最大和为ma,mb Step3:mx=max(ma,mb,mc)，其中mc=max(sum(x[i..n/2-1])) +max(sum(x[n/2..j])) 该算法时间复制度为O(nlogn)123456789101112131415161718192021222324252627282930313233343536float maxfun(float a, float b)&#123; return a &gt; b ? a : b;&#125;#define max(a, b) maxfun(a, b)float alg3()&#123; return recmax(0, n-1);&#125;float recmax(int l, int u)&#123; int i, m; float lmax, rmax, sum; if (l &gt; u) /* zero elements */ return 0; if (l == u) /* one element */ return max(0, x[l]); m = (l+u) / 2;// find max crossing to left lmax = sum = 0; for(i = m; i &gt;= l; i--)&#123; sum += x[i]; if(sum &gt; lmax) lmax = sum; &#125; rmax = sum = 0; for(i = m+1; i &lt;= u; i++)&#123; sum += x[i]; if(sum &gt; rmax) rmax = sum; &#125; return max(lmax + rmax, max(recmax(l, m),recmax(m+1, u)));&#125; 扫描法 初始问题：找出大小为n的向量x中连续子向量中的最大和mx 利用分治原理 假设现在已解决了大小为(i-1)的向量x[0..i-2]的问题，那么如何计算大小为i的向量x[0..i-1]的问题呢？ 大小为i的向量x[0..i-1]中连续子向量中的最大和mx[0..i-1] =max(mx[0..i-2],maxendinghere[i-1])其中maxendinghere[i-1]表示向量x[0..i-1]中结束位置为(i-1)的连续子向量的最大和，即maxendinghere[i-1]=max(sum(x[0..i-1]), sum(x[1..i-1]), … , sum(x[i-1..i-1]))。假定maxendinghere≥0. 该算法时间复制度为O(n) 12345678910111213141516171819202122232425262728293031323334353637383940// 第一种float alg4()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; if (maxendinghere &lt; 0) maxendinghere = 0; if (maxsofar &lt; maxendinghere) maxsofar = maxendinghere; &#125; return maxsofar;&#125;//第二种#define maxmac(a, b) ((a) &gt; (b) ? (a) : (b) )float alg4b()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; maxendinghere = maxmac(maxendinghere, 0); maxsofar = maxmac(maxsofar, maxendinghere);&#125; return maxsofar;&#125;//第三种float maxfun(float a, float b)&#123; return a &gt; b ? a : b;&#125;float alg4c()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; maxendinghere = maxfun(maxendinghere, 0); maxsofar = maxfun(maxsofar, maxendinghere);&#125; return maxsofar;&#125; 实际运行时间对比 这篇文章是对老师上课内容的一次回顾]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>分治法</tag>
        <tag>扫描法</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表基本操作二]]></title>
    <url>%2Fpost%2Fed29cf9.html</url>
    <content type="text"><![CDATA[三、链表实现代码与分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct Node &#123; char *SchoolNumber; char *Name; int Age; struct Node *Next;&#125;;typedef struct Node *Link;// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); //字符串的分割 while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); n.Next = NULL; return n;&#125;// 打印单个节点void Print(Link &amp;Head, int op_number)&#123; if(op_number == 0)&#123; printf(&quot;Error!\n&quot;); return ; &#125; Link p; p = Head; for(int i = 0; i &lt; op_number; i++)&#123; p = p-&gt;Next; &#125; printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, p); printf(&quot;%-15s&quot;, p-&gt;SchoolNumber); printf(&quot;%-15s&quot;, p-&gt;Name); printf(&quot;%-15d\n&quot;, p-&gt;Age);&#125;//插入节点void InsertNode(Link &amp;Head, Node n, int &amp;NodeCount, int i)&#123; Link p; p = Head; for(int j = 0; j &lt; i-1; j++)&#123; p = p-&gt;Next; &#125; n.Next = p-&gt;Next; p-&gt;Next = &amp;n; NodeCount++;&#125;//删除节点void DeleteNode(Link &amp;Head, int &amp;NodeCount, int i)&#123; Link p, r; p = Head; for(int j = 0; j &lt; i; j++ ) &#123; r = p; p = p-&gt;Next; &#125; r-&gt;Next = p-&gt;Next; free(p); NodeCount--;&#125;// 主函数int main()&#123; FILE *fp; char buffer[100]; char operate[50]; int op_number; Link Head = (Link)malloc(sizeof(struct Node)); Head-&gt;Next = NULL; int NodeCount = 0; Link p = (Link)malloc(sizeof(struct Node)); p = Head; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); if((fp = fopen(&quot;Lab1test.DAT&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; Link temp = (Link)malloc(sizeof(struct Node)); *temp = Str_Node(buffer); p-&gt;Next = temp; p = p-&gt;Next; NodeCount++; &#125; fclose(fp); &#125; for(int i = 0; i &lt; NodeCount; i++) Print(Head, i+1); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); Print(Head, op_number); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(Head, n, NodeCount, number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(Head, NodeCount, op_number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 四、所遇到的“坑” 在布局输出结果时，使用\t并不能解决，需要使用类似于”%-15x”的格式化输出搞定。 在打印节点时，老是从学号后面开始出现乱码，这种情况，要么是转化时出现问题，要么是创建链表时出问题。在103行，进行节点输出，发现没问题，那么就是转化出问题。将这部分进行单拎出来，用char buffer[] = “SA12345678,小明,22”测试，发现乱码，果然是这部分有问题。与顺序表的转化部分对比，发现一个返回结构体，一个返回结构体指针。以下是出错代码：123456789101112131415161718192021Link Str_Node(char *buffer) &#123; char *p[3]; char *temp; Link NewNode = (Link)malloc(sizeof(struct Node)); int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; NewNode-&gt;SchoolNumber = p[0]; NewNode-&gt;Name = p[1]; NewNode-&gt;Age = atoi(p[2]); NewNode-&gt;Next = NULL; return NewNode;&#125; 将其改为返回结构体得以解决。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表的操作一]]></title>
    <url>%2Fpost%2F555915f5.html</url>
    <content type="text"><![CDATA[Data Structure – Linear_list一、要求：&emsp;&emsp;首先，逐行读取指定文件中的数据，并进行解析后保存在顺序表中。其中，文件中每行数据格式为“学号,姓名,年龄”，比如“SA10225048,张三,24”。（提示：采用顺序表结构时，顺序表中每个表元素包含三类信息：学号，姓名，和年龄；采用单链表结构时，单链表中每个结点的数据域包含三类信息：学号，姓名，和年龄。）再根据键盘输入进行相关操作（查找，删除和插入）。比如，若键盘输入为“P3”，则表示打印出第3项的信息（注意：采用顺序表结构时，第3项数据对应下标为2的表元素；采用单链表结构时，第3项数据对应链表中第3个结点的信息；）；若键盘输入为“D3”，则表示删除第3个表元素；若键盘输入为“I3,SA10225038,张四,24”，则表示在第3项前插入一个学生的信息（SA10225038,张四,24）。 附件可以把以下数据复制到txt文档，然后改名为studentinfo.data。将这个文件和cpp文件放在同一个目录下。 SA10225048,张三,24SG10225132,李四,22连续子向量中的最大和SG10225027,王五,24SA10225213,赵六,25SA10225197,欧阳奋强,23SG10225059,孙八,24SA10225083,余久,23SA10225112,张唯一,24 二、顺序表实现代码与分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define maxn 100struct Node &#123; char *SchoolNumber; char *Name; int Age;&#125;ArrNode[maxn];// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); return n;&#125;// 打印所有节点void Print(int NodeCount)&#123; for(int i = 0; i &lt; NodeCount; i++)&#123; printf(&quot;%-10d&quot;, i+1); printf(&quot;%-15x&quot;, ArrNode + i); printf(&quot;%-15s&quot;, ArrNode[i].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[i].Name); printf(&quot;%-15d\n&quot;, ArrNode[i].Age); &#125;&#125;// 插入节点void InsertNode(struct Node n, int &amp;NodeCount, int i)&#123; for(int j = NodeCount; j &gt;= i; j--)&#123; ArrNode[j].SchoolNumber = ArrNode[j-1].SchoolNumber; ArrNode[j].Name = ArrNode[j-1].Name; ArrNode[j].Age = ArrNode[j-1].Age; &#125; ArrNode[i-1].SchoolNumber = n.SchoolNumber; ArrNode[i-1].Name = n.Name; ArrNode[i-1].Age = n.Age; NodeCount++;&#125;// 删除节点void DeleteNode(int &amp;NodeCount, int i)&#123; for(int j = i; j &lt; NodeCount; j++)&#123; ArrNode[j - 1].SchoolNumber = ArrNode[j].SchoolNumber; ArrNode[j - 1].Name = ArrNode[j].Name; ArrNode[j - 1].Age = ArrNode[j].Age; &#125; NodeCount--;&#125;int main()&#123; FILE *fp; char buffer[100]; int NodeCount = 0; char operate[30]; int op_number; if((fp = fopen(&quot;studentinfo.data&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; ArrNode[NodeCount++] = Str_Node(buffer); &#125; fclose(fp); &#125; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); Print(NodeCount); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, ArrNode + op_number - 1); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].Name); printf(&quot;%-15d\n&quot;, ArrNode[op_number - 1].Age); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; struct Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(n, NodeCount, number); Print(NodeCount); &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(NodeCount, op_number); Print(NodeCount); &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 使用的是顺序表结构来实现线性表的基本操作，明天采用链表结构来实现。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习二]]></title>
    <url>%2Fpost%2F52f58e7a.html</url>
    <content type="text"><![CDATA[八、矩阵运算 1234567891011121314151617181920212223242526272829303132In [103]:A = np.arange(4).reshape(2, 2) B = np.full((2, 2), 10) A, BOut[103]:(array([[0, 1], [2, 3]]), array([[10, 10], [10, 10]]))In [104]:A + BOut[104]:array([[10, 11], [12, 13]])In [105]:A - BOut[105]:array([[-10, -9], [ -8, -7]])In [106]:A * B #对应元素相乘Out[106]:array([[ 0, 10], [20, 30]])In [107]:A.dot(B) #矩阵乘法Out[107]:array([[10, 10], [50, 50]])In [108]:A.T#转置Out[108]:array([[0, 2], [1, 3]]) 九、向量和矩阵运算12345678910111213141516171819202122232425262728In [109]:v=np.array([1,2]) v + A # v向量分别与A矩阵每一行相加，实际上不合法Out[109]:array([[1, 3], [3, 5]])In [110]:np.vstack([v] * A.shape[0]) #将v落成A一样高，即同行数然后在与A相加可 实现上面要求Out[110]:array([[1, 2], [1, 2]])In [111]:np.tile(v, (2,1)) # 将v向量在行上堆叠两次，在列上堆叠一次Out[111]:array([[1, 2], [1, 2]])In [112]:v * A # v与A中每一行各元素对应相乘所得Out[112]:array([[0, 2], [2, 6]])In [113]:v.dot(A)Out[113]:array([4, 7])In [114]:A.dot(v) #由于v没有规定是行还是列向量，所以np会自动判断使其合理的方式运算Out[114]:array([2, 8]) 十、矩阵的逆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768In [115]:A = np.arange(24).reshape(4,6)In [116]:AOut[116]:array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]])In [117]:B=np.arange(0,24).reshape(6,4)In [118]:z=A.dot(B) zOut[118]:array([[ 220, 235, 250, 265], [ 580, 631, 682, 733], [ 940, 1027, 1114, 1201], [1300, 1423, 1546, 1669]])In [119]:arr1=z%11 arr1Out[119]:array([[0, 4, 8, 1], [8, 4, 0, 7], [5, 4, 3, 2], [2, 4, 6, 8]], dtype=int32)In [120]:inv1=np.linalg.inv(arr1+1) #np.linalg中有逆的运算 inv1Out[120]:array([[ 1.68884986e+15, 1.68884986e+15, -2.25179981e+15, -1.12589991e+15], [-3.37769972e+15, -3.37769972e+15, 4.50359963e+15, 2.25179981e+15], [ 1.68884986e+15, 1.68884986e+15, -2.25179981e+15, -1.12589991e+15], [-1.36363636e-01, -4.54545455e-02, 0.00000000e+00, 1.81818182e-01]])In [121]:pinvx=np.linalg.pinv(A) #当A不是方阵时，A没有逆可以有伪逆In [122]:pinvxOut[122]:array([[-0.12619048, -0.06587302, -0.00555556, 0.0547619 ], [-0.07904762, -0.04063492, -0.00222222, 0.03619048], [-0.03190476, -0.01539683, 0.00111111, 0.01761905], [ 0.0152381 , 0.00984127, 0.00444444, -0.00095238], [ 0.06238095, 0.03507937, 0.00777778, -0.01952381], [ 0.10952381, 0.06031746, 0.01111111, -0.03809524]])In [123]:pinvx.shapeOut[123]:(6, 4)In [124]:A.dot(pinvx)Out[124]:array([[ 0.7, 0.4, 0.1, -0.2], [ 0.4, 0.3, 0.2, 0.1], [ 0.1, 0.2, 0.3, 0.4], [-0.2, 0.1, 0.4, 0.7]])In [125]:pinvx.dot(x)Out[125]:array([[ 0.34920635, 0.20634921, 0.06349206], [ 0.25396825, 0.16825397, 0.08253968], [ 0.15873016, 0.13015873, 0.1015873 ], [ 0.06349206, 0.09206349, 0.12063492], [-0.03174603, 0.05396825, 0.13968254], [-0.12698413, 0.01587302, 0.15873016]])In [126]:np.linalg.pinv? 十一、np中的聚合运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899In [127]:L = np.random.random(100)In [128]:LOut[128]:array([0.29365293, 0.13349054, 0.72296127, 0.20339775, 0.79085149, 0.72289686, 0.34664717, 0.21922709, 0.2347296 , 0.10934288, 0.93987847, 0.54118002, 0.89582475, 0.88657711, 0.01363686, 0.86886947, 0.30145564, 0.94794894, 0.01607689, 0.97629271, 0.81439886, 0.31815539, 0.29844493, 0.41129176, 0.33999991, 0.95050074, 0.43841296, 0.30775838, 0.69076609, 0.09082456, 0.95063683, 0.83411245, 0.71913127, 0.72244065, 0.11435661, 0.48092918, 0.56755408, 0.30867441, 0.79659891, 0.88179918, 0.70385178, 0.95382592, 0.40178135, 0.52124991, 0.77764132, 0.01151922, 0.56330513, 0.49297281, 0.6472458 , 0.8703968 , 0.59602549, 0.3425843 , 0.32778162, 0.8072212 , 0.90542921, 0.64954137, 0.2699948 , 0.03288953, 0.04912259, 0.46259617, 0.16843821, 0.92318423, 0.56270712, 0.15915484, 0.35922195, 0.04674703, 0.39876266, 0.94110829, 0.76153611, 0.3938261 , 0.78600756, 0.33429112, 0.16921891, 0.67781051, 0.84572637, 0.38719376, 0.17431285, 0.56729794, 0.98401691, 0.52914654, 0.43819623, 0.91374443, 0.73249185, 0.14618544, 0.20060762, 0.42209825, 0.10296695, 0.6020364 , 0.24532492, 0.98187115, 0.08073652, 0.63580472, 0.11326209, 0.25617199, 0.32379328, 0.66696424, 0.81302027, 0.83596411, 0.32551382, 0.8484381 ])In [129]:sum(L)Out[129]:51.443603284608905In [130]:np.sum(L) #与前者时间不一样Out[130]:51.4436032846089In [131]:np.min(L)Out[131]:0.011519220430084354In [132]:np.max(L)Out[132]:0.9840169068335332In [133]:L.min() # 面对对象，还是np型都可以，不过后者包含的函数更全Out[133]:0.011519220430084354In [134]:X = np.arange(16).reshape(4, -1) XOut[134]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [135]:np.sum(X) #对应多维矩阵，sum为所有元素之和Out[135]:120In [136]:np.sum(X, axis = 1) #每一列元素相加之和Out[136]:array([ 6, 22, 38, 54])In [137]:np.prod(X + 1) #所有元素之积Out[137]:2004189184In [138]:np.prod(X, axis = 1) #沿着列相乘Out[138]:array([ 0, 840, 7920, 32760])In [139]:np.mean(X) #平均值Out[139]:7.5In [140]:np.median(X) #中位数，中间有两个就这两个数的平均值Out[140]:7.5In [141]:np.percentile(X,q=10) #百分位点，指有10%的数都小于等于1.5，当q=50表示中位数，q=100表示最大值，q = 0表示最小值Out[141]:1.5In [142]:np.percentile(X, q= 100)Out[142]:15.0In [143]:rad = np.random.random(100) for percent in [0, 25, 50, 100]: print(np.percentile(rad, q=percent))0.023267903753504850.26171186382127440.50112193791323390.998188987589012In [144]:np.var(rad) #求方差Out[144]:0.07112525170741578In [145]:np.std(rad) #标准差Out[145]:0.26669317896679656 十二、索引12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364In [146]:np.argmin(rad) #表示最小值所在的索引下标Out[146]:80In [147]:x = np.arange(16) xOut[147]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [158]:np.random.shuffle(x) #对x使用乱序化,x本身会改变 xOut[158]:array([10, 12, 3, 7, 4, 5, 6, 2, 9, 13, 14, 11, 0, 15, 8, 1])In [159]:np.sort(x) #x并不会改变Out[159]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [157]:x.sort() #x会改变 xOut[157]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [161]:X = np.random.randint(0,10,size=(4,4)) #在[0,10)之间随机生成4X4 的二维整型矩阵 XOut[161]:array([[6, 6, 4, 0], [3, 8, 2, 7], [7, 1, 1, 2], [0, 2, 1, 7]])In [163]:np.sort(X) #各行进行排序Out[163]:array([[0, 4, 6, 6], [2, 3, 7, 8], [1, 1, 2, 7], [0, 1, 2, 7]])In [165]:np.sort(X,axis = 0) #沿着行排序Out[165]:array([[0, 1, 1, 0], [3, 2, 1, 2], [6, 6, 2, 7], [7, 8, 4, 7]])In [167]:np.argsort(X) #排序的索引Out[167]:array([[3, 2, 0, 1], [2, 0, 3, 1], [1, 2, 3, 0], [0, 2, 1, 3]], dtype=int64)In [168]:xOut[168]:array([10, 12, 3, 7, 4, 5, 6, 2, 9, 13, 14, 11, 0, 15, 8, 1])In [169]:np.partition(x, 3) #使3前面都比3小，后面都比3大Out[169]:array([ 0, 1, 2, 3, 4, 5, 7, 8, 9, 6, 10, 11, 14, 15, 12, 13])In [170]:np.argpartition(x,3) #返回其索引Out[170]:array([12, 15, 7, 2, 4, 5, 3, 14, 8, 6, 0, 11, 10, 13, 1, 9], dtype=int64) 十三、Fancy Indexing123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111In [171]:x = np.arange(16)In [172]:ind = [3, 5, 8]In [173]:x[ind] #将索引放进数组，然后进行访问Out[173]:array([3, 5, 8])In [174]:ind = np.array([[2, 4, 1], [0, 10, 3]])In [175]:x[ind] # 根据索引来返回相应的值Out[175]:array([[ 2, 4, 1], [ 0, 10, 3]])In [176]:X = x.reshape(4, -1) XOut[176]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [177]:row = np.array([0, 1, 2]) col = np.array([1, 2, 3])In [178]:X[row,col] #根据row，col所得交集来访问Out[178]:array([ 1, 6, 11])In [179]:X[:2,col]Out[179]:array([[1, 2, 3], [5, 6, 7]])In [180]:X&lt;5 #返回bool值Out[180]:array([[ True, True, True, True], [ True, False, False, False], [False, False, False, False], [False, False, False, False]])In [184]:3 * X== 4*X-1 #返回满足改条件的值的真假Out[184]:array([[False, True, False, False], [False, False, False, False], [False, False, False, False], [False, False, False, False]])In [186]:xOut[186]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [187]:np.sum(x &lt;= 3) #返回x中小于等于3的个数Out[187]:4In [188]:np.any(x &lt;=3 ) #返回x中是否有小于等于3的数Out[188]:TrueIn [189]:np.count_nonzero(x &lt;= 3) #表示x&lt;=3这个bool数组中有多少个非零元素（false为0，true为1）Out[189]:4In [190]:np.all(x&gt;=0) #all判断x&gt;=0这个bool数组中是不是都大于0Out[190]:TrueIn [192]:np.all(x)Out[192]:FalseIn [193]:np.sum((x&gt;3) &amp; (x&lt;7)) # &amp;为和不能用and, 因为这两边都是数组，要求的是两个数组中的交集而不是一个值Out[193]:3In [195]:np.sum((x&gt;3) | (x&lt;7))Out[195]:16In [196]:np.sum(~(x==3))Out[196]:15​In [149]:arr4 = np.arange(10).reshape(2,5) arr4Out[149]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])In [150]:ind = [True ,False, True, False,True]In [151]:arr4[:,ind]Out[151]:array([[0, 2, 4], [5, 7, 9]])In [152]:np.any(arr4&gt;2)Out[152]:TrueIn [153]:np.all(arr4&lt;=1)Out[153]:FalseIn [154]:np.sum(arr4&gt;3)Out[154]:6In [155]:import numpy as np arr4 = np.arange(0,10).reshape(2,5) np.sum(arr4[:,0])Out[155]:5]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习一]]></title>
    <url>%2Fpost%2F6975a0d3.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;本期将会涉及到Python模块中的numpy，这是一个处理数组的强大模块，而该模块也是其他数据分析模块（如pandas和scipy）的核心。 一、数组的创建 np.array(list,tuple,array类型) np.arange,一维数组中的range ones,ones_like,zeros,zeros_like,empty,empty_like eye,identity #单位矩阵 full #全为指定数矩阵 linspace(0,20,10)In:1234567arr1 = np.array(range(10)).reshape(2,5)arr2 = np.arange(10).reshape(2,5)arr3 = np.ones((2,5))arr4 = np.zeros_like(arr1)arr5 = np.eye(5)arr6 = np.full((2, 5), 3)np.linspace(0,20,10) #在0 和 20 包括0,20等长的截取10个点 Out:123456789101112131415161718192021222324252627282930313233343536arr1Out[5]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr2Out[6]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr3Out[7]:array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])arr4Out[8]:array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])arr5Out[9]:array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.]])arr6Out[10]:array([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3]])Out[11]:array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 二、数组的基本操作123456789101112131415161718192021In[25]:arr1Out[25]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])In [26]:arr2Out[26]:array([ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19])In [28]:arr3=arr2.reshape(2,5) #reshape 改变类型In [29]:arr3.shape#不该变arr3自身Out[29]:(2, 5)In [30]:arr3.size #元素个数Out[30]:10In [31]:arr3.ndim #元素维度Out[31]:2 三、矩阵元素访问123456789101112131415161718192021222324252627282930313233343536373839In [32]:arr3[:]Out[32]:array([[ 1, 3, 5, 7, 9], [11, 13, 15, 17, 19]])In [33]:arr3[1,3] #arr3[1,3]和arr3[1][3]一样但是推荐使用前者Out[33]:17In [34]:x = np.array(range(12)).reshape(3, 4) xOut[34]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])In [35]:x[::-1,::-1] #步长为-1表示从后往前数Out[35]:array([[11, 10, 9, 8], [ 7, 6, 5, 4], [ 3, 2, 1, 0]])In [36]:subx=x[:2,:3] #切片访问 subx改变值不会改变arr3值 subxOut[36]:array([[0, 1, 2], [4, 5, 6]])In [37]:subx=x[:2,2:] subxOut[37]:array([[2, 3], [6, 7]])In [38]:subx[0,1]=100In [39]:print(arr3)#改变arr3中子矩阵，arr3也会改变，是引用方式Out[39]:[[ 1 3 5 7 9] [11 13 15 17 19]] 四、合并操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061In [40]:x=np.array([1,2,3]) y=np.array([3,1,2])In [41]:np.concatenate([x,y])Out[41]:array([1, 2, 3, 3, 1, 2])In [42]:np.concatenate([x,y],axis=0)Out[42]:array([1, 2, 3, 3, 1, 2])In [43]:A = np.array([[1,2,3], [4,5,6]])In [44]:np.concatenate([A,A]) #默认垂直合并 concatenate只能处理同类型矩阵Out[44]:array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]])In [45]:np.concatenate([A,A],axis = 1)Out[45]:array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]])In [46]:z = np.array([666,666,666])In [47]:np.concatenate([A, z.reshape(1,-1)]) #针对concatenate只能同类型矩阵，可以用（1，-1）表示一行，列数随机的方法Out[47]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [48]:np.vstack([A,z])#垂直堆叠合并Out[48]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [49]:B = np.full((2,2),100) BOut[49]:array([[100, 100], [100, 100]])In [50]:arr4 = np.array(range(12)).reshape(3,4)In [51]:print(arr4)Out[51]:[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]In [52]:np.hstack([arr4,arr4]) #水平堆叠合并Out[52]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]])In [53]:np.hstack([arr4,arr4])Out[53]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]]) 五、分割 split12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485In [54]:arr5=np.array(range(10))In [55]:x1,x2,x3=np.split(arr5,[3,7])#arr5 分割矩阵，【3,7】为分割点列表In [56]:print(x1)Out[56]:[0 1 2]In [57]:x2Out[57]:array([3, 4, 5, 6])In [58]:x3Out[58]:array([7, 8, 9])In [59]:x1,x2 = np.split(arr5,[5]) x1,x2Out[59]:(array([0, 1, 2, 3, 4]), array([5, 6, 7, 8, 9]))In [60]:arr6=np.array(range(16)).reshape(4,4) arr6Out[60]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [61]:a1,a2 = np.split(arr6, [2]) #当arr6为二维数组时，【2】表示前两行为分割处 a1Out[61]:array([[0, 1, 2, 3], [4, 5, 6, 7]])In [62]:a2Out[62]:array([[ 8, 9, 10, 11], [12, 13, 14, 15]])In [63]:A1,A2 = np.split(arr6, [2], axis = 1) #axis=1 表示列分割 A1,A2Out[63]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [64]:up,down =np.vsplit(arr6,[-1]) #垂直切割，表示分成上下部分In [65]:up,downOut[65]:(array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]), array([[12, 13, 14, 15]]))In [66]:left,right = np.hsplit(arr6,[2]) #水平切割，表示分成左右部分 left,rightOut[66]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [67]:data = np.arange(16).reshape(4,4) dataOut[67]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [82]:x,y = np.hsplit(data,[-1]) # data表示数据集，前三个为特征，后一个为标签，这样切割为x，y x,yOut[82]:(array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]), array([[ 3], [ 7], [11], [15]])) 六、矩阵的标量运算12345678910111213141516171819In [83]:%%timeit #计算单元格内运算时间 n = 10 A = [i for i in range(n)] A858 ns ± 7.77 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [84]:%%timeit n = 10 B = [] for i in range(n): B.append(i) B1.51 µs ± 85.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [85]:%%timeit n = 10 A = np.arange(n) A881 ns ± 93.5 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 七、Universal Function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687In [87]:A = [i for i in range(10)] AOut[87]:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [88]:arrA = np.array(A).reshape(2, 5)In [89]:arrA * 2Out[89]:array([[ 0, 2, 4, 6, 8], [10, 12, 14, 16, 18]])In [90]:arrA - 1Out[90]:array([[-1, 0, 1, 2, 3], [ 4, 5, 6, 7, 8]])In [91]:arrA/2Out[91]:array([[0. , 0.5, 1. , 1.5, 2. ], [2.5, 3. , 3.5, 4. , 4.5]])In [92]:arrA **2Out[92]:array([[ 0, 1, 4, 9, 16], [25, 36, 49, 64, 81]], dtype=int32)In [93]:arrA //2 #整除Out[93]:array([[0, 0, 1, 1, 2], [2, 3, 3, 4, 4]], dtype=int32)In [94]:np.abs(arrA-4)Out[94]:array([[4, 3, 2, 1, 0], [1, 2, 3, 4, 5]])In [95]:np.sin(arrA)Out[95]:array([[ 0. , 0.84147098, 0.90929743, 0.14112001, -0.7568025 ], [-0.95892427, -0.2794155 , 0.6569866 , 0.98935825, 0.41211849]])In [96]:np.arcsin(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in arcsin &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[96]:array([[0. , 1.57079633, nan, nan, nan], [ nan, nan, nan, nan, nan]])In [97]:np.power(arrA,3)Out[97]:array([[ 0, 1, 8, 27, 64], [125, 216, 343, 512, 729]], dtype=int32)In [98]:1/arrAC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in true_divide &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[98]:array([[ inf, 1. , 0.5 , 0.33333333, 0.25 ], [0.2 , 0.16666667, 0.14285714, 0.125 , 0.11111111]])In [99]:np.exp(arrA)Out[99]:array([[1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01], [1.48413159e+02, 4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03]])In [100]:np.log2(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log2 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[100]:array([[ -inf, 0. , 1. , 1.5849625 , 2. ], [2.32192809, 2.5849625 , 2.80735492, 3. , 3.169925 ]])In [101]:np.log10(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log10 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[101]:array([[ -inf, 0. , 0.30103 , 0.47712125, 0.60205999], [0.69897 , 0.77815125, 0.84509804, 0.90308999, 0.95424251]])In [102]:np.log(arrA) #log默认为eC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[102]:array([[ -inf, 0. , 0.69314718, 1.09861229, 1.38629436], [1.60943791, 1.79175947, 1.94591015, 2.07944154, 2.19722458]])]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux1]]></title>
    <url>%2Fpost%2F652da2f1.html</url>
    <content type="text"><![CDATA[Linux命令格式: command [-options] [parameter1] … 说明：command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，[]代表可选 parameter1 …：传给命令的参数：可以是零个一个或多个 一、基本技能 在linux终端时：Ctrl Shift + 三个键字体扩大，Ctrl - 字体缩小 自动补全：在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令 历史命令：当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来 多个命令同时使用用 ; ，不建议使用 Ctrl c 终止命令 几个目录符号含义： ~ 用户目录 / 根目录 . 当前路径 .. 上一路径 -回看 清屏：clear 显示当前路径：pwd（不带参数） 二、文件、磁盘管理 查看文件信息：ls 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 输出重定向命令：&gt;Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 ) 注意：&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 分屏显示：more查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助 管道：|管道：一个命令的输出可以通过管道做为另一个命令的输入。管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。 切换工作目录： cd在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。Linux所有的目录和文件名大小写敏感cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。例如：cd / 到根目录 目录操作： 创建目录：mkdir通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。 删除目录：rmdir可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。 删除文件：rm可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。 参数 含义 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹时必须加此参数 建立链接文件：lnLinux链接文件类似于Windows下的快捷方式。链接文件分为软链接和硬链接。软链接：软链接不占用磁盘空间，源文件删除则软链接失效。硬链接：硬链接只能链接普通文件，不能链接目录。使用格式： ln 源文件 链接文件ln -s 源文件 链接文件 如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。 注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。 查看或者合并文件内容：cat 文本搜索：grepLinux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。 grep一般格式为： grep [-选项] ‘搜索内容串’文件名 在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。 常用选项说明： 选项 含义 -v 显示不包含匹配文本的所有行（相当于求反） -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式。 &emsp;&emsp;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 grep常用正则表达式： 参数 含义 ^a 行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt ke$ 行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt [Ss]igna[Ll] 匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt . (点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt 查找文件：findfind命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 常用用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name ‘*.sh’ 查找当前目录下所有后缀为.sh的文件 find ./ -name “[A-Z]*” 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp 目录下等于2M的文件 find /tmp -size +2M 查找在/tmp 目录下大于2M的文件 find /tmp -size -2M 查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k，小于5M的文件 find ./ -perm 777 查找当前目录下权限为 777 的文件或目录 拷贝文件：cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。 常用选项说明： 选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 移动文件：mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项说明： 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 归档管理：tar计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 tar使用格式 tar [参数] 打包文件名 文件 tar命令很特殊，其参数前面可以使用“-”，也可以不使用。 常用参数： 参数 含义 -c 生成档案文件，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 注意：除了f需要放在参数的最后，其它参数的顺序任意。 文件压缩解压：gziptar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。 gzip使用格式如下： gzip [选项] 被压缩文件 常用选项： 选项 含义 -d 解压 -r 压缩所有子目录 tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar cvzf 压缩包包名 文件1 文件2 ... -z ：指定压缩包的格式为：file.tar.gz 解压用法： tar zxvf 压缩包包名 -z:指定压缩包的格式为：file.tar.gz 解压到指定目录：-C （大写字母“C”） 文件压缩解压：bzip2tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。 tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。 在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *.c) 解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2) 文件压缩解压：zip、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 压缩文件：zip [-r] 目标文件(没有扩展名) 源文件 解压文件：unzip -d 解压后目录文件 压缩文件 查看命令位置：which例如：which ls]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise4]]></title>
    <url>%2Fpost%2F65e81f01.html</url>
    <content type="text"><![CDATA[python项目之2048小游戏&emsp;&emsp;2048是一个非常简单的小游戏，对于刚学python的萌新来说，用来练练手也是非常不错的选择。下面利用python自带的tkinter来实现2048的界面设计。 一、总体框架设计 首先设计大的窗口，然后是4x4小格子 然后在下面显示分数，上下左右，重置，退出。通过鼠标点击来实现操作12345678910111213141516171819202122232425262728# 大窗口window=tk.Tk()window.title(&apos;2048&apos;)window.geometry(&apos;330x560&apos;) # 绘制初始的界面lab = &#123;&#125;Ox, Oy = 10, 10for i in range(4): for j in range(4): tlx=Ox+j*80 tly=Oy+i*80 num = i * 4 + j key = str(board[i][j]) # height，width值按字符来设置 l = tk.Label(window, text=board[i][j], bg=color[key], font=(&apos;Arial&apos;, 20), height=2, width=4) lab[num] = l l.place(x=tlx,y=tly)# 下面的控制，分数显示窗口，分数用数组中最大值表示tk.Label(window,text=&apos;分数:&apos;,bg=&apos;gray96&apos;,font=(&apos;微软雅黑&apos;,15)).place(x=10,y=330)tk.Label(window, textvariable=va, bg=&apos;gray96&apos;, font=(&apos;微软雅黑&apos;, 15)).place(x=70, y=330)tk.Button(window, text=&apos;上&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=up_op).place(x=130, y=360)tk.Button(window, text=&apos;下&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=down_op).place(x=130, y=465)tk.Button(window, text=&apos;左&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=left_op).place(x=55, y=410)tk.Button(window, text=&apos;右&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=right_op).place(x=205, y=410)tk.Button(window, text=&apos;重置&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=restart_op).place(x=20,y=510)tk.Button(window, text=&apos;退出&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=exit_op).place(x=245,y=510) 二、功能具体实现 初始化操作：随机在数组中找两个位置，然后各随机分配2或4,2概率为75%，initi之前应该将数组清零。 状态机： 初始化后游戏进入game状态，然后游戏可能进入win，gameover这两种状态，还可以人为的重置退出。而在win，gameover状态也可以人为的重置退出。那怎样判断win，gameover呢？当分数值为2048时进入win状态，当数组中非零个数为16且没有两个相同数字相邻时进入gameover状态代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243def is_same_neibor(a): for i in range(4): for j in range(4): if i &lt; 3 and j &lt; 3: if a[i][j] == a[i][j+1] or a[i][j] == a[i+1][j]: return True elif i == 3 and j &lt; 3: if a[i][j] == a[i][j+1]: return True elif j == 3 and i &lt; 3: if a[i][j] == a[i+1][j]: return True return False def judge_state(a): # 判定数组此时状态，max_num记录数组中最大值且为当前分值 count = update(a) max_num=np.max(a) va.set(max_num) if max_num == 2048: round_over=True var1 = tk.messagebox.askyesno(title=&apos;闯关成功！&apos;, message=&apos;你想再来一次吗？&apos;) if var1: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() if count == 16 and is_same_neibor(a) == False: round_over=True var2 = tk.messagebox.askyesno(title=&apos;闯关失败！&apos;, message=&apos; Game Over!\n你想再试一次吗？&apos;) if var2: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() 六种运算操作： 向左移动且合并 向右移动且合并 向上移动且合并 向下移动且合并 重置 退出以向左移动且合并为例，向右移动且合并可以根据向左操作模仿操作，向上向下可通过转置和向左来实现1234567891011121314151617 def left_move(a): # 将非零数字左移 k = 0 for i in range(4): if a[i] != 0: a[k] = a[i] k += 1 if k &lt; 4: for j in range(k, 4): a[j] = 0def left_add(a): #将非零相同数字左合并 for i in range(3): if a[i] == a[i + 1]: a[i] = a[i] * 2 if i + 1 &lt; 3: for k in range(i + 1, 3): a[k] = a[k + 1] a[3] = 0 重置和退出： 123456789def restart_op(): for i in range(4): for j in range(4): board[i][j] = 0 initi(board) update(board)def exit_op(): window.destroy() game状态随机数产生和产生时机 123456789101112131415 def compare(a,b): # 数组移动前后比较，若不同则产生随机数，否则不产生 n_equal=False for i in range(4): for j in range(4): if a[i][j]!=b[i][j]: n_equal=True break return n_equaldef produce_rand(a): #在随机为零的位置随机产生一个数 p = random.randint(0, 3) q = random.randint(0, 3) while (board[p][q] != 0): p = random.randint(0, 3) q = random.randint(0, 3) board[p][q] = random.choice([2, 2, 2, 4]) 移动后更新： 12345678910def update(a): #更新，统计数组中非零元素个数且返回，用于后面判断数组状态。并更新颜色 count = 0 for i in range(4): for j in range(4): if a[i][j]: count += 1 num = i * 4 + j c_key = str(a[i][j]) lab[num].config(text=a[i][j], bg=color[c_key]) return count 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229from tkinter import messageboximport tkinter as tkimport numpy as npimport randomdef main(): # 初始化，创造一个窗口，显示title，窗口大小 window=tk.Tk() window.title(&apos;2048&apos;) window.geometry(&apos;330x560&apos;) # 不同的分数不同的颜色 round_over=False color = &#123;&apos;0&apos;: &apos;gray86&apos;, &apos;2&apos;: &apos;green1&apos;, &apos;4&apos;: &apos;cyan&apos;, &apos;8&apos;: &apos;blue1&apos;, &apos;16&apos;: &apos;pink4&apos;, &apos;32&apos;: &apos;yellow1&apos;, &apos;64&apos;: &apos;yellow4&apos;, &apos;128&apos;: &apos;pink&apos;,&apos;256&apos;: &apos;green4&apos;, &apos;512&apos;: &apos;yellow4&apos;, &apos;1024&apos;: &apos;orange4&apos;, &apos;2048&apos;: &apos;red&apos;&#125; # 初始化，随机在数组中找两个位置，然后各随机分配2或4,2概率为75%，initi之前应该将数组清零。 def initi(a): m1 = random.randint(0, 3) #从0到3之间产生一个随机整数（包含端点） n1 = random.randint(0, 3) m2 = random.randint(0, 3) n2 = random.randint(0, 3) while ((m1 == m2) and (n1 == n2)): m2 = random.randint(0, 3) n2 = random.randint(0, 3) a[m1][n1] = random.choice([2, 2, 2, 4]) #从列表中随机选中一个数 a[m2][n2] = random.choice([2, 2, 2, 4]) # 创建原始数组 board = np.zeros((4, 4), dtype=np.int16) initi(board) # 绘制初始的界面 lab = &#123;&#125; Ox, Oy = 10, 10 for i in range(4): for j in range(4): tlx=Ox+j*80 tly=Oy+i*80 num = i * 4 + j key = str(board[i][j]) # height，width值按字符来设置 l = tk.Label(window, text=board[i][j], bg=color[key], font=(&apos;Arial&apos;, 20), height=2, width=4) lab[num] = l l.place(x=tlx,y=tly) # 定义各种操作函数 def left_move(a): # 将非零数字左移 k = 0 for i in range(4): if a[i] != 0: a[k] = a[i] k += 1 if k &lt; 4: for j in range(k, 4): a[j] = 0 def right_move(a): k = 3 for i in range(4): if a[3 - i] != 0: a[k] = a[3 - i] k -= 1 if k &gt; 0: for j in range(0, k + 1): a[j] = 0 def left_add(a): #将非零相同数字左合并 for i in range(3): if a[i] == a[i + 1]: a[i] = a[i] * 2 if i + 1 &lt; 3: for k in range(i + 1, 3): a[k] = a[k + 1] a[3] = 0 def right_add(a): for i in range(3): if a[3 - i] == a[2 - i]: a[3 - i] = a[3 - i] * 2 if 2 - i &gt; 0: for k in range(1, 3 - i): a[3 - i - k] = a[2 - i - k] a[0] = 0 def produce_rand(a): #在随机为零的位置随机产生一个数 p = random.randint(0, 3) q = random.randint(0, 3) while (board[p][q] != 0): p = random.randint(0, 3) q = random.randint(0, 3) board[p][q] = random.choice([2, 2, 2, 4]) def update(a): #更新，统计数组中非零元素个数且返回，用于后面判断数组状态。并更新颜色 count = 0 for i in range(4): for j in range(4): if a[i][j]: count += 1 num = i * 4 + j c_key = str(a[i][j]) lab[num].config(text=a[i][j], bg=color[c_key]) return count def is_same_neibor(a): for i in range(4): for j in range(4): if i &lt; 3 and j &lt; 3: if a[i][j] == a[i][j+1] or a[i][j] == a[i+1][j]: return True elif i == 3 and j &lt; 3: if a[i][j] == a[i][j+1]: return True elif j == 3 and i &lt; 3: if a[i][j] == a[i+1][j]: return True return False def judge_state(a): # 判定数组此时状态，max_num记录数组中最大值且为当前分值 count = update(a) max_num=np.max(a) va.set(max_num) if max_num == 2048: round_over=True var1 = tk.messagebox.askyesno(title=&apos;闯关成功！&apos;, message=&apos;你想再来一次吗？&apos;) if var1: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() if count == 16 and is_same_neibor(a) == False: round_over=True var2 = tk.messagebox.askyesno(title=&apos;闯关失败！&apos;, message=&apos; Game Over!\n你想再试一次吗？&apos;) if var2: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() def compare(a,b): n_equal=False for i in range(4): for j in range(4): if a[i][j]!=b[i][j]: n_equal=True break return n_equal # 进行运算操作 def up_op(): ob=board.copy() tb = board.T for i in range(4): left_move(tb[i]) left_add(tb[i]) m = tb.T for i in range(4): for j in range(4): board[i][j] = m[i][j] if compare(ob,board): produce_rand(board) judge_state(board) def down_op(): ob = board.copy() tb = board.T for i in range(4): right_move(tb[i]) right_add(tb[i]) m = tb.T for i in range(4): for j in range(4): board[i][j] = m[i][j] if compare(ob, board): produce_rand(board) judge_state(board) def left_op(): ob = board.copy() for i in range(4): left_move(board[i]) left_add(board[i]) if compare(ob, board): produce_rand(board) judge_state(board) def right_op(): ob = board.copy() for i in range(4): right_move(board[i]) right_add(board[i]) if compare(ob, board): produce_rand(board) judge_state(board) def restart_op(): for i in range(4): for j in range(4): board[i][j] = 0 initi(board) update(board) def exit_op(): window.destroy() # 创建按钮和标签 va=tk.StringVar() va.set(0) tk.Label(window,text=&apos;分数:&apos;,bg=&apos;gray96&apos;,font=(&apos;微软雅黑&apos;,15)).place(x=10,y=330) tk.Label(window, textvariable=va, bg=&apos;gray96&apos;, font=(&apos;微软雅黑&apos;, 15)).place(x=70, y=330) tk.Button(window, text=&apos;上&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=up_op).place(x=130, y=360) tk.Button(window, text=&apos;下&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=down_op).place(x=130, y=465) tk.Button(window, text=&apos;左&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=left_op).place(x=55, y=410) tk.Button(window, text=&apos;右&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=right_op).place(x=205, y=410) tk.Button(window, text=&apos;重置&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=restart_op).place(x=20,y=510) tk.Button(window, text=&apos;退出&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=exit_op).place(x=245,y=510) window.mainloop()if __name__==&apos;__main__&apos;: main() 相关链接 http://python.jobbole.com/84971/ https://www.shiyanlou.com/courses/reports/1283118 https://blog.csdn.net/qq_39451109/article/details/78161438 https://blog.csdn.net/yjy_aii/article/details/78071955]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>tkinter</tag>
        <tag>2048</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_3_飞机大战]]></title>
    <url>%2Fpost%2Fb1eae7a3.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个小练习，飞机大战，主要有四个类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227import pygamefrom pygame.locals import *import randomimport time&apos;&apos;&apos;说明爆炸效果的原理是:换图片&apos;&apos;&apos;class Hero(object): def __init__(self, screen_temp): self.x = 210 self.y = 590 self.image = pygame.image.load(&quot;./feiji/hero1.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 &quot;&quot;&quot; #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n4.png&quot;)) &quot;&quot;&quot; def display(self, enemy_temp): &quot;&quot;&quot;显示玩家的飞机&quot;&quot;&quot; #如果被击中,就显示爆炸效果,否则显示普通的飞机效果 &quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 &quot;&quot;&quot; #else: self.screen.blit(self.image,(self.x, self.y)) #不管玩家飞机是否被击中,都要显示发射出去的子弹 for bullet in self.bullet_list: bullet.display() bullet.move(enemy_temp) if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move_left(self): self.x -= 8 def move_right(self): self.x += 8 def fire(self): &quot;&quot;&quot;通过创建一个子弹对象,完成发射子弹&quot;&quot;&quot; print(&quot;-----1----&quot;) bullet = Bullet(self.screen, self.x, self.y)#创建一个子弹对象 self.bullet_list.append(bullet) def bomb(self): self.hit = Trueclass Bullet(object): def __init__(self, screen_temp, x_temp, y_temp): self.x = x_temp+40 self.y = y_temp-20 self.image = pygame.image.load(&quot;./feiji/bullet.png&quot;) self.screen = screen_temp def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self, enemy_temp): if self.x &gt; enemy_temp.x and self.x &lt; enemy_temp.x + 50 and self.y &lt; 40: enemy_temp.bomb() else: self.y -= 20 def judge(self): if self.y&lt;0: return True else: return Falseclass EnemyPlane(object): def __init__(self, screen_temp): self.x = 0 self.y = 0 self.image = pygame.image.load(&quot;./feiji/enemy0.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 self.direction = &quot;right&quot;#用来设置这个飞机默认的移动方向 #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down4.png&quot;)) def display(self): &quot;&quot;&quot;显示敌人的飞机&quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 else: self.screen.blit(self.image,(self.x, self.y)) for bullet in self.bullet_list: bullet.display() bullet.move() if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move(self): if self.direction == &quot;right&quot;: self.x+=5 elif self.direction == &quot;left&quot;: self.x-=5 if self.x&gt;480-50: self.direction=&quot;left&quot; elif self.x&lt;0: self.direction=&quot;right&quot; def fire(self): random_num = random.randint(1,100) if random_num == 8 or random_num == 20: self.bullet_list.append(EnemyBullet(self.screen, self.x, self.y)) def bomb(self): self.hit = Trueclass EnemyBullet(object): def __init__(self, screen_temp, x, y): self.x = x+25 self.y = y+40 self.screen = screen_temp self.image = pygame.image.load(&quot;./feiji/bullet1.png&quot;) def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self): self.y+=5 def judge(self): if self.y&gt;720: return True else: return Falsedef key_control(hero_temp): #获取事件，比如按键等 for event in pygame.event.get(): #判断是否是点击了退出按钮 if event.type == QUIT: print(&quot;exit&quot;) exit() #判断是否是按下了键 elif event.type == KEYDOWN: #检测按键是否是a或者left if event.key == K_a or event.key == K_LEFT: print(&apos;left&apos;) hero_temp.move_left() #检测按键是否是d或者right elif event.key == K_d or event.key == K_RIGHT: print(&apos;right&apos;) hero_temp.move_right() #检测按键是否是空格键 elif event.key == K_SPACE: print(&apos;space&apos;) hero_temp.fire() #elif event.key == K_b: #print(&apos;b&apos;) #hero_temp.bomb()def main(): screen = pygame.display.set_mode((480,720),0,32) background = pygame.image.load(&quot;./feiji/background.png&quot;) #创建玩家飞机 hero = Hero(screen) #创建敌机 enemy = EnemyPlane(screen) while True: screen.blit(background,(0,0)) hero.display(enemy) enemy.display() enemy.move() enemy.fire() pygame.display.update() key_control(hero) time.sleep(0.01)if __name__ == &quot;__main__&quot;: main()]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>pygame</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排]]></title>
    <url>%2Fpost%2Fe9d8c1ec.html</url>
    <content type="text"><![CDATA[快排算法： 1、快速排序的基本思想：&emsp;&emsp;快排主要使用分治思想，基于pivot，通过一趟排序将待排序列分割成两部分，左边都不大于pivot，右边都不小于pivot。之后分别对这两部分继续进行排序，以达到整个序列有序的目的。 2、快速排序的三个步骤：(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot） ，这里将第一个元素作为第一个基准。(2)分割操作：以pivot为基准分割该序列为两部分。(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;#define n 10//对[left, right]进行划分，使pivot 左边都小于该值，右边都大于该值int Part(int A[], int left, int right)&#123; int pivot = A[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; pivot &lt; A[right]) right--; A[left] = A[right]; while(left &lt; right &amp;&amp; pivot &gt;= A[left]) left++; A[right] = A[left]; &#125; A[left] = pivot; return left;&#125;//利用上面的part函数，且采用递归的方式实现快速排序void Quicksort(int A[], int left, int right)&#123; if(left &lt; right) &#123; int temp = Part(A, left, right); Quicksort(A, left, temp-1); Quicksort(A, temp+1, right); &#125;&#125;//对快排进行测试int main(int argc, char const *argv[])&#123; int array[n]; for (int i = 0; i &lt; n; ++i) cin&gt;&gt;array[i]; Quicksort(array, 0, n-1); cout&lt;&lt;array[0]; for (int i = 0; i &lt; n; ++i) cout&lt;&lt;&quot; &quot;&lt;&lt;array[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_2_老王开枪]]></title>
    <url>%2Fpost%2Fe0505a69.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个小小项目，主要练习类，对象的使用流程。下面是代码来自网上学习视频，作为练习所用:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189class Person(object): &quot;&quot;&quot;人的类&quot;&quot;&quot; def __init__(self, name): super(Person, self).__init__() self.name = name self.gun = None#用来保存枪对象的引用 self.hp = 100 def anzhuang_zidan(self, dan_jia_temp, zi_dan_temp): &quot;&quot;&quot;把子弹装到弹夹中&quot;&quot;&quot; #弹夹.保存子弹(子弹) dan_jia_temp.baocun_zidan(zi_dan_temp) def anzhuang_danjia(self, gun_temp, dan_jia_temp): &quot;&quot;&quot;把弹夹安装到枪中&quot;&quot;&quot; #枪.保存弹夹(弹夹) gun_temp.baocun_danjia(dan_jia_temp) def naqiang(self, gun_temp): &quot;&quot;&quot;拿起一把枪&quot;&quot;&quot; self.gun = gun_temp def __str__(self): if self.gun: return &quot;%s的血量为:%d, 他有枪 %s&quot;%(self.name, self.hp, self.gun) else: if self.hp&gt;0: return &quot;%s的血量为%d, 他没有枪&quot;%(self.name, self.hp) else: return &quot;%s 已挂....&quot;%self.name def kou_ban_ji(self, diren): &quot;&quot;&quot;让枪发射子弹去打敌人&quot;&quot;&quot; #枪.开火(敌人) self.gun.fire(diren) def xiao_xue(self, sha_shang_li): &quot;&quot;&quot;根据杀伤力，掉相应的血量&quot;&quot;&quot; self.hp -= sha_shang_liclass Gun(object): &quot;&quot;&quot;枪类&quot;&quot;&quot; def __init__(self, name): super(Gun, self).__init__() self.name = name#用来记录枪的类型 self.danjia = None#用来记录弹夹对象的引用 def baocun_danjia(self, dan_jia_temp): &quot;&quot;&quot;用一个属性来保存这个弹夹对象的引用&quot;&quot;&quot; self.danjia = dan_jia_temp def __str__(self): if self.danjia: return &quot;枪的信息为:%s, %s&quot;%(self.name, self.danjia) else: return &quot;枪的信息为:%s,这把枪中没有弹夹&quot;%(self.name) def fire(self, diren): &quot;&quot;&quot;枪从弹夹中获取一发子弹，然后让这发子弹去击中敌人&quot;&quot;&quot; #先从弹夹中取子弹 #弹夹.弹出一发子弹() zidan_temp = self.danjia.tanchu_zidan() #让这个子弹去伤害敌人 if zidan_temp: #子弹.打中敌人(敌人) zidan_temp.dazhong(diren) else: print(&quot;弹夹中没有子弹了。。。。&quot;)class Danjia(object): &quot;&quot;&quot;弹夹类&quot;&quot;&quot; def __init__(self, max_num): super(Danjia, self).__init__() self.max_num = max_num#用来记录弹夹的最大容量 self.zidan_list = []#用来记录所有的子弹的引用 def baocun_zidan(self, zi_dan_temp): &quot;&quot;&quot;将这颗子弹保存&quot;&quot;&quot; self.zidan_list.append(zi_dan_temp) def __str__(self): return &quot;弹夹的信息为:%d/%d&quot;%(len(self.zidan_list), self.max_num) def tanchu_zidan(self): &quot;&quot;&quot;弹出最上面的那颗子弹&quot;&quot;&quot; if self.zidan_list: return self.zidan_list.pop() else: return Noneclass Zidan(object): &quot;&quot;&quot;子弹类&quot;&quot;&quot; def __init__(self, sha_shang_li): super(Zidan, self).__init__() self.sha_shang_li = sha_shang_li#这颗子弹的威力 def dazhong(self, diren): &quot;&quot;&quot;让敌人掉血&quot;&quot;&quot; #敌人.掉血(一颗子弹的威力) diren.xiao_xue(self.sha_shang_li)def main(): &quot;&quot;&quot;用来控制整个程序的流程&quot;&quot;&quot; #1. 创建老王对象 laowang = Person(&quot;老王&quot;) #2. 创建一个枪对象 ak47 = Gun(&quot;AK47&quot;) #3. 创建一个弹夹对象 dan_jia = Danjia(20) #4. 创建一些子弹 for i in range(15): zi_dan = Zidan(10) #5. 老王把子弹安装到弹夹中 #老王.安装子弹到弹夹中(弹夹，子弹) laowang.anzhuang_zidan(dan_jia, zi_dan) #6. 老王把弹夹安装到枪中 #老王.安装弹夹到枪中(枪，弹夹) laowang.anzhuang_danjia(ak47, dan_jia) #test:测试弹夹的信息 #print(dan_jia) #test:测试枪的信息 #print(ak47) #7. 老王拿枪 #老王.拿枪(枪) laowang.naqiang(ak47) #test:测试老王对象 print(laowang) #8. 创建一个敌人 gebi_laosong = Person(&quot;隔壁老宋&quot;) print(gebi_laosong) #9. 老王开枪打敌人 #老王.扣扳机(隔壁老宋) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang)if __name__ == &apos;__main__&apos;: main() 配上下面的图更好理解：]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>类，对象</tag>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1090 危险品装箱 （25 分）]]></title>
    <url>%2Fpost%2F2dc86a28.html</url>
    <content type="text"><![CDATA[1090 危险品装箱 （25 分）集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式：输入第一行给出两个正整数：N (≤10$^{4}$) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： K G[1] G[2] … G[K]其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式：对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例：123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例：123NoYesYes 解题思路： map&lt;int, vector &gt; mp字典用来将每个物品与其不相容的物品序列配对 a[10000] = {0}：用来标记物品是否存在 vector g(count): 存放每箱物品清单编号 思路：先配对，然后对每箱物品清单的每个物品判断它的不相容数组中是否有标记，有的话no, 用flag == 1表示。最后为1，即有不相容物品对。若最后还是初始时的0则表示无不相容物品对。12345678910111213141516171819202122232425262728#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, number1, number2; map&lt;int,vector&lt;int&gt;&gt; mp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;number1&gt;&gt;number2; mp[number1].push_back(number2); mp[number2].push_back(number1); &#125; while (m--) &#123; int count, flag = 0, a[100000] = &#123;0&#125;; scanf(&quot;%d&quot;, &amp;count); vector&lt;int&gt; g(count); for (int i = 0; i &lt; count; i++) &#123; cin&gt;&gt;g[i]; a[g[i]] = 1; &#125; for (int i = 0; i &lt; g.size(); i++) for (int j = 0; j &lt; mp[g[i]].size(); j++) if (a[mp[g[i]][j]] == 1) flag = 1; printf(&quot;%s\n&quot;,flag ==0 ? &quot;Yes&quot; :&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
        <tag>map</tag>
        <tag>配对问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1089 狼人杀-简单版 （20 分）]]></title>
    <url>%2Fpost%2F7a56b95d.html</url>
    <content type="text"><![CDATA[1089 狼人杀-简单版 （20 分）以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？ 输入格式：输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。 输出格式：如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤ k&lt; M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。输入样例 1：5-2+3-4+5+4输出样例 1：1 4输入样例 2：6+6+3+1-5-2+4输出样例 2（解不唯一）：1 5输入样例 3：5-2-3-4-5-1输出样例 3：No Solution 解题思路： speak[k]数组用来保存k号玩家所说的话 lang_hao[k] 表示k号玩家是狼人还是好人，好人为1，狼人为-1 lie[]存放说谎者的序号 思路：先存speak；然后用两循环令i，j为狼人遍历这n个玩家。当狼人确定后，好人同时确认。接着再用一层循环来判断k号玩家是否说谎，说谎者序号放进lie[]。最后，当lie[]数组大小为2且一个为狼人一个为好人时，输出i，j并结束程序。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; speak(n + 1); for (int i = 1; i &lt;= n; ++i) cin&gt;&gt;speak[i]; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = i + 1; j &lt;= n; ++j) &#123; vector&lt;int&gt; lie, lang_hao(n + 1, 1); lang_hao[i] = lang_hao[j] = -1; for(int k = 1; k&lt;=n; k++)&#123; if(speak[k] * lang_hao[abs(speak[k])] &lt; 0) lie.push_back(k); &#125; if(lie.size() == 2 &amp;&amp; lang_hao[lie[0]] + lang_hao[lie[1]] == 0)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
        <tag>狼人杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1088 三人行 （20 分）]]></title>
    <url>%2Fpost%2F9b06ffb2.html</url>
    <content type="text"><![CDATA[1088 三人行 （20 分）子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。输入格式：输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式：在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：48 3 7输出样例 1：48 Ping Cong Gai输入样例 2：48 11 6输出样例 2：No Solution 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int i, j; int m, x, y; double a[3] = &#123;0&#125;;//丙可能是小数，所以用double cin&gt;&gt;m&gt;&gt;x&gt;&gt;y; for(i = 99; i &gt;= 10; --i)&#123;//i表示甲，j为乙 j = i%10*10 + i/10; if(j * x == y * abs(j - i))&#123;1089 狼人杀-简单版 （20 分） printf(&quot;%d&quot;,i); a[0] = i; a[1] = j; a[2] = j * 1.0/y; break; &#125; &#125; for(int i = 0; i &lt; 3; i++)&#123; if(a[i] == 0) &#123; printf(&quot;No Solution&quot;); break; &#125; else if(m &gt; a[i]) printf(&quot; Gai&quot;); else if(m == a[i]) printf(&quot; Ping&quot;); else printf(&quot; Cong&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1087 有多少不同的值]]></title>
    <url>%2Fpost%2F43c853ae.html</url>
    <content type="text"><![CDATA[1087 有多少不同的值 （20 分）&emsp;&emsp;当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。）输入格式：输入给出一个正整数 N（2 ≤ N ≤ 10$^{4}$)。1088 三人行 （20 分）输出格式：在一行中输出题面中算式取到的不同值的个数。 输入样例：12017 输出样例：11480 有两种解法：第一种：12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int maxn = 100001;int main() &#123; bool flag[maxn] = &#123;false&#125;;//通过hash表来去重 int n, temp; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++) &#123; temp = i/2 +i/3 + i/5; flag[temp] = true; &#125; int count = 0; for(int i = 0; i &lt; maxn; i++)&#123; if(flag[i] == true) count++; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125; 第二种：123456789101112131415#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); set&lt;int&gt; st; //通过集合来去重 for (int i = 1; i &lt;= n; i++) &#123; st.insert(i/2 + i/3 + i/5); &#125; printf(&quot;%d&quot;, st.size()); return 0;&#125; &emsp;&emsp;太简单了没啥好讲的。。。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1086 就不告诉你 （15 分）]]></title>
    <url>%2Fpost%2F6b78c7e9.html</url>
    <content type="text"><![CDATA[1086 就不告诉你 （15 分）&emsp;&emsp;做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。 输入格式：&emsp;&emsp;输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 输出格式：&emsp;&emsp;在一行中倒着输出 A 和 B 的乘积。输入样例：15 7 输出样例：153 注意：100的倒序为1。这个很重要，没有得满分的基本都是没注意这点，其他没啥好讲的。 1234567891011121314151617181920#include &lt;cstdio&gt;int main()&#123; int a, b, count = 0, c, ans[10];//基本输入和计算 bool flag = false; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); c = a * b; while(c &gt; 0)&#123;//得到倒序的各元素数组 ans[count++] = c % 10; c /= 10; &#125; for(int i = 0; i &lt; count; i++) &#123;//将前面的0去掉 if(ans[i] != 0) flag = true; if(flag == true) printf(&quot;%d&quot;, ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_1]]></title>
    <url>%2Fpost%2F72b78552.html</url>
    <content type="text"><![CDATA[这个系统非常简单，主要目的是练习python的基本操作 下面是主要功能:12345678 名片管理系统 V0.011. 添加一个新名片2. 删除一个名片3. 修改一个名片4. 查询一个名片5. 显示所有名片6. 保存名片7. 退出系统 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# -*- coding: utf-8 -*-card_infors = []def print_menu(): &quot;&apos;完成打印功能菜单&apos;&quot; print(&quot;=&quot; * 50) print(&quot; 名片管理系统 V0.01&quot;) print(&quot;1. 添加一个新名片&quot;) print(&quot;2. 删除一个名片&quot;) print(&quot;3. 修改一个名片&quot;) print(&quot;4. 查询一个名片&quot;) print(&quot;5. 显示所有名片&quot;) print(&quot;6. 保存名片&quot;) print(&quot;7. 退出系统&quot;) print(&quot;=&quot; * 50)def add_new_card_infor(): &quot;&apos;完成添加一个新名片&apos;&quot; new_name = input(&quot;请输入新的名字:&quot;) new_qq = input(&quot;请输入新的QQ:&quot;) new_weixin = input(&quot;请输入新的微信:&quot;) new_addr = input(&quot;请输入新的住址:&quot;) #定义一个新的字典,用来存储一个新的名片 new_infor = &#123;&#125;5 new_infor[&apos;name&apos;] = new_name new_infor[&apos;qq&apos;] = new_qq new_infor[&apos;weixin&apos;] = new_weixin new_infor[&apos;addr&apos;] = new_addr #将一个字典,添加到列表中 global card_infors card_infors.append(new_infor) #print(card_infors)# for testdef find_card_infor(): &quot;&quot;&quot;用来查询一个名片&quot;&quot;&quot; global card_infors find_name = input(&quot;请输入要查找的姓名:&quot;) find_flag = 0#默认表示没有找到 for temp in card_infors: if find_name == temp[&quot;name&quot;]: print(&quot;%s\t%s\t%s\t%s&quot;%(temp[&apos;name&apos;], temp[&apos;qq&apos;], temp[&apos;weixin&apos;], temp[&apos;addr&apos;])) find_flag=1#表示找到了 break #判断是否找到了 if find_flag == 0: print(&quot;查无此人....&quot;)def show_all_infor(): &quot;&quot;&quot;显示所有的名片信息&quot;&quot;&quot; global card_infors print(&quot;姓名\tQQ\t微信\t住址&quot;) for temp in card_infors: print(&quot;%s\t%s\t%s\t%s&quot;%(temp[&apos;name&apos;], temp[&apos;qq&apos;], temp[&apos;weixin&apos;], temp[&apos;addr&apos;]))def save_2_file(): &quot;&quot;&quot;把已经添加的信息保存到文件中&quot;&quot;&quot; f = open(&quot;backup.data&quot;, &quot;w&quot;) f.write(str(card_infors)) f.close()def load_infor(): global card_infors try: f = open(&quot;backup.data&quot;) card_infors = eval(f.read()) f.close() except Exception: passdef main(): &quot;&quot;&quot;完成对整个程序的控制&quot;&quot;&quot; #恢复(加载)之前的数据到程序中 load_infor()#刚开始启动程序就会加载内容，所以刚开始由于没有back.data文件会报错#但第二次运行时由于前面已经创建了文件不会报错，所以在load_infor()#函数中使用try，Exception #1. 打印功能提示 print_menu() while True: #2. 获取用户的输入 num = int(input(&quot;请输入操作序号:&quot;)) #3. 根据用户的数据执行相应的功能 if num==1: add_new_card_infor() elif num==2: pass elif num==3: pass elif num==4: find_card_infor() elif num==5: show_all_infor() elif num==6: save_2_file() elif num==7: break else: print(&quot;输入有误,请重新输入&quot;) print(&quot;&quot;)if __name__ == &quot;__main__&quot;: //用于测试中，当调用别的模块时，值为别的模块名字符串，调用自己时为&quot;__main__&quot; #调用主函数 main() &emsp;&emsp;该项目是学习过程中，参照学习视频所做的练习题]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 使用指南一]]></title>
    <url>%2Fpost%2F57d30a97.html</url>
    <content type="text"><![CDATA[markdown 使用指南一 目录: 基本操作 专用操作 Markdow工具 1. 基本语法： 字体常见设置：下划线，加粗，删除线 字体深度设置：字体，字号，颜色，背景色 分级标题 分割线 链接 引用 列表 Todo列表 行首缩进，换行 特殊字符输入 (1) 字体常见设置：斜体，加粗，删除线&emsp;&emsp; 用一对单星号把要处理的文字包起来就会呈现斜体；用一对双星号把要处理的文字包起来就会呈现加粗；用一对双波浪线把要处理的文字包起来就会呈现斜体。1234*感觉萌萌哒***感觉萌萌哒*****感觉萌萌哒***~~ 感觉萌萌哒~~ 效果如下： 感觉萌萌哒感觉萌萌哒感觉萌萌哒感觉萌萌哒 (2) 字体深度设置：字体，字号，颜色，背景色markdown本身不支持修改字体、字号与颜色等功能，但是使用内嵌HTML的方法来实现。123&lt;font face=&quot;微软雅黑&quot;&gt;感觉萌萌哒&lt;/font&gt;&lt;font color=#0000ff size=5 face=&quot;黑体&quot;&gt;感觉萌萌哒&lt;/font&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;感觉萌萌哒&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 感觉萌萌哒 感觉萌萌哒 感觉萌萌哒 注意：Size：字体大小，范围是1到7，浏览器默认值是3。 (3) 分级标题12345使用#来实现分级标题，使用&lt;center&gt;&lt;/center&gt;来居中# 感觉萌萌哒## 感觉萌萌哒### 感觉萌萌哒### &lt;center&gt;感觉萌萌哒&lt;/center&gt; 效果如下： 感觉萌萌哒感觉萌萌哒感觉萌萌哒感觉萌萌哒(4) 分割线三个连续星号(*)、减号(-)、底线(_)来实现123***---___ 效果如下： (5) 链接a. 插入图片12格式：![图片描述](图片本地或互联网url)例如：![女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下： b. 文字加链接12格式：[文字或(本地图片位置)](url)例如：[女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下：女神刘亦菲 c. 图片加链接12格式：[![图片描述](图片互联网url或这本地相对链接)](url)例如：[![女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg)](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下： (6) 引用 在正文前使用&gt;符号和空格 123&gt; 感觉萌萌哒&gt;&gt; 感觉萌萌哒&gt;&gt;&gt; 感觉萌萌哒 效果如下： 感觉萌萌哒 感觉萌萌哒 感觉萌萌哒 (7) 列表 列表有两种：无序列表和有序列表 a. 无序列表: 使用 *，+，-，再加上一个空格1234我是无序列表：- 萌萌哒一遍- 萌萌哒二遍- 萌萌哒三遍 我是无序列表： 萌萌哒一遍 萌萌哒二遍 萌萌哒三遍 c. 有序列表：使用数字和一个英文句点，再加上一个空格1234我是有序列表：1. 萌萌大2. 萌萌中3. 萌萌小 效果如下： 我是有序列表： 萌萌大 萌萌中 萌萌小 (8) Todo列表 用- [ ]，- [X]表示事件有没有完成(减号空格左中括号空格右中括号，减号空格左中括号x大写或小写右中括号。都这么直接了，应该不会用错了吧) 如图 今天要做的事： 吃饭 看剧 写代码 上课 (9) 行首缩进，换行直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，&ensp; 代表半角空格，&emsp; 代表全角空格。换行：连续两个以上空格+回车或者举个栗子：1&amp;emsp;&amp;emsp;你爱不爱我，我都是萌萌哒。&lt;br&gt;感觉萌萌哒&lt;br/&gt;萌萌哒 示例效果： &emsp;&emsp;你爱不爱我，我都是萌萌哒。感觉萌萌哒萌萌哒 (10) 特殊字符输入a. 前面加反斜线\ 即可显示符号本身。12345678\\\*\.\_\-\#\&#123;\&#125;\! 效果如下：\*._-#{}!b. 特殊的转义字符12345678910111213141516171819符号 说明 对应编码¶ 段落符号 &amp;para;§ 章节符 &amp;sect;± 加减号 &amp;plusmn;ƒ function &amp;fnof;√ 根号 &amp;radic;∞ 无穷大 &amp;infin;° 度 &amp;deg;≠ 不等号 &amp;ne;≡ 恒等于 &amp;equiv;≤ 小于等于 &amp;le;≥ 大于等于 &amp;ge;♠ 黑桃 &amp;spades;♥ 红桃 &amp;hearts;♣ 梅花 &amp;clubs;♦ 方块 &amp;diams;举个栗子：黑桃&amp;spades;大于红桃&amp;hearts;大于梅花&amp;clubs;方块&amp;diams;不管是人民币&amp;yen;、欧元&amp;euro;、英磅&amp;pound;还是美元 &amp;dollar;，我都喜欢。 效果：黑桃&spades;大于红桃&hearts;大于梅花&clubs;方块&diams;不管是人民币&yen;、欧元&euro;、英磅&pound;还是美元 &dollar;，我都喜欢。本特殊符号来源自该博文 &emsp;&emsp;终于写完了第一个博客，作为一个糙老爷们用了这么多萌萌哒，我先吐会儿。。。。 &emsp;&emsp;等我吐完了再来接着写第二篇哈。。。。 本文参考文章： https://blog.csdn.net/jaywon/article/details/77992082 https://www.jianshu.com/p/c0a2897ad4eb https://blog.csdn.net/u010177286/article/details/50358720]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
</search>
